<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>滚~韬的博客</title>
  
  <subtitle>滚~</subtitle>
  <link href="https://gwtt.github.io/atom.xml" rel="self"/>
  
  <link href="https://gwtt.github.io/"/>
  <updated>2022-11-04T14:47:05.055Z</updated>
  <id>https://gwtt.github.io/</id>
  
  <author>
    <name>滚~韬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bean注解</title>
    <link href="https://gwtt.github.io/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/"/>
    <id>https://gwtt.github.io/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-11-04T05:35:36.000Z</published>
    <updated>2022-11-04T14:47:05.055Z</updated>
    
    <content type="html"><![CDATA[<p>因为实践周，这几周天天写代码，没有时间更新博客。学会了很多go相关的东西，下次补充。</p><h3 id="什么是Bean"><a href="#什么是Bean" class="headerlink" title="什么是Bean"></a>什么是Bean</h3><p>这个概念网上也是老生常谈了。</p><p>Spring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。</p><p>SpringIOC 容器管理一个或者多个bean，这些bean都需要在@Configuration注解下进行创建，在一个方法上使用@Bean注解就表明这个方法需要交给Spring进行管理。</p><p>案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">  <span class="comment">// 使用@Bean 注解表明myBean需要交给Spring进行管理</span></span><br><span class="line">  <span class="comment">// 未指定bean 的名称，默认采用的是 &quot;方法名&quot; + &quot;首字母小写&quot;的配置方式</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyBean Initializing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBeanApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        context.getBean(<span class="string">&quot;myBean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 MyBean Initializing</span></span><br></pre></td></tr></table></figure><p>下面是实战经历代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalTimeConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title function_">jackson2ObjectMapperBuilderCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; &#123;</span><br><span class="line">            <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//返回时间数据序列化</span></span><br><span class="line">            builder.serializerByType(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(formatter));</span><br><span class="line">            <span class="comment">//接收时间数据反序列化</span></span><br><span class="line">            builder.deserializerByType(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(formatter));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到返回了一个函数式接口</p><h3 id="Bean的基本构成"><a href="#Bean的基本构成" class="headerlink" title="Bean的基本构成"></a>Bean的基本构成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="meta">@AliasFor(&quot;name&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    Autowire <span class="title function_">autowire</span><span class="params">()</span> <span class="keyword">default</span> Autowire.NO;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">initMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">destroyMethod</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;(inferred)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Bean不仅可以作用在方法上，也可以作用在注解类型上，在运行时提供注册。</p><p><strong>value</strong>： name属性的别名，在不需要其他属性时使用，也就是说value 就是默认值</p><p><strong>name</strong>： 此bean 的名称，或多个名称，主要的bean的名称加别名。如果未指定，则bean的名称是带注解方法的名称。如果指定了，方法的名称就会忽略，如果没有其他属性声明的话，bean的名称和别名可能通过value属性配置</p><p><strong>autowire</strong> ： 此注解的方法表示自动装配的类型，返回一个<code>Autowire</code>类型的枚举，我们来看一下<code>Autowire</code>枚举类型的概念</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举确定自动装配状态：即，bean是否应该使用setter注入由Spring容器自动注入其依赖项。</span></span><br><span class="line"><span class="comment">// 这是Spring DI的核心概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Autowire</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常量，表示根本没有自动装配。</span></span><br><span class="line">NO(AutowireCapableBeanFactory.AUTOWIRE_NO),</span><br><span class="line"><span class="comment">// 常量，通过名称进行自动装配</span></span><br><span class="line">BY_NAME(AutowireCapableBeanFactory.AUTOWIRE_BY_NAME),</span><br><span class="line"><span class="comment">// 常量，通过类型进行自动装配</span></span><br><span class="line">BY_TYPE(AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">Autowire(<span class="type">int</span> value) &#123;</span><br><span class="line"><span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAutowire</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span> == BY_NAME || <span class="built_in">this</span> == BY_TYPE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autowire的默认值为<code>No</code>，默认表示不通过自动装配。</p><p><strong>initMethod</strong>: 这个可选择的方法在bean实例化的时候调用，<code>InitializationBean</code>接口允许bean在合适的时机通过设置注解的初始化属性从而调用初始化方法，InitializationBean 接口有一个定义好的初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure><blockquote><p>Spring不推荐使用InitializationBean 来调用其初始化方法，因为它不必要地将代码耦合到Spring。Spring推荐使用<code>@PostConstruct</code>注解或者为POJO类指定其初始化方法这两种方式来完成初始化。</p></blockquote><p><strong>不推荐使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>destroyMethod</strong>: 方法的可选择名称在调用bean示例在关闭上下文的时候，例如JDBC的close()方法，或者SqlSession的close()方法。<code>DisposableBean</code> 接口的实现允许在bean销毁的时候进行回调调用，DisposableBean 接口之后一个单个的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure><blockquote><p>Spring不推荐使用DisposableBean 的方式来初始化其方法，因为它会将不必要的代码耦合到Spring。作为替代性的建议，Spring 推荐使用<code>@PreDestory</code>注解或者为<code>@Bean</code>注解提供 destroyMethod 属性，</p></blockquote><p><strong>不推荐使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DestroyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">推荐使用：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyBean Initializing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean 初始化方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean 销毁方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 修改一下测试类，测试其初始化方法和销毁方法在何时会被调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBeanApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------------------ 测试一  ------------------------------</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">   <span class="comment">//context.getBean(&quot;myBean&quot;);</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 变体</span></span><br><span class="line">        context.getBean(<span class="string">&quot;myBean&quot;</span>);</span><br><span class="line">        ((AnnotationConfigApplicationContext) context).destroy();</span><br><span class="line"><span class="comment">//((AnnotationConfigApplicationContext) context).close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化方法在得到Bean的实例的时候就会被调用，销毁方法在容器销毁或者容器关闭的时候会被调用。</p></blockquote><h3 id="Bean与其他注解的配合"><a href="#Bean与其他注解的配合" class="headerlink" title="Bean与其他注解的配合"></a>Bean与其他注解的配合</h3><blockquote><h3 id="Profile-注解"><a href="#Profile-注解" class="headerlink" title="@Profile 注解"></a>@Profile 注解</h3><p>@Profile的作用是把一些meta-data进行分类，分成Active和InActive这两种状态，然后你可以选择在active 和在Inactive这两种状态下配置bean，在Inactive状态通常的注解有一个！操作符，通常写为：@Profile(“!p”),这里的p是Profile的名字。</p><p><strong>三种设置方式：</strong></p><ul><li><p>可以通过ConfigurableEnvironment.setActiveProfiles()以编程的方式激活</p></li><li><p>可以通过AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME (spring.profiles.active )属性设置为</p></li></ul><p> JVM属性</p><ul><li>作为环境变量，或作为web.xml 应用程序的Servlet 上下文参数。也可以通过@ActiveProfiles 注解在集成测试中以声明方式激活配置文件。</li></ul><p><strong>作用域</strong></p><ul><li>作为类级别的注释在任意类或者直接与@Component 进行关联，包括@Configuration 类</li><li>作为原注解，可以自定义注解</li><li>作为方法的注解作用在任何方法</li></ul><p><strong>注意</strong>:</p><p>如果一个配置类使用了Profile 标签或者@Profile 作用在任何类中都必须进行启用才会生效，如果@Profile({“p1”,”!p2”}) 标识两个属性，那么p1 是启用状态 而p2 是非启用状态的。</p><p>现有一个POJO类为Subject学科类，里面有两个属性，一个是like(理科)属性，一个是wenke(文科)属性，分别有两个配置类，一个是<code>AppConfigWithActiveProfile</code> ，一个是<code>AppConfigWithInactiveProfile</code>，当系统环境是 “like”的时候就注册 AppConfigWithActiveProfile ，如果是 “wenke”，就注册 AppConfigWithInactiveProfile，来看一下这个需求如何实现</p><p>Subject.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 学科</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 理科</span></span><br><span class="line">   <span class="keyword">private</span> String like;</span><br><span class="line">   <span class="comment">// 文科</span></span><br><span class="line">   <span class="keyword">private</span> String wenke;</span><br><span class="line"></span><br><span class="line">  get and set ...</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;Subject&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;like=&#x27;&quot;</span> + like + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, wenke=&#x27;&quot;</span> + wenke + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>AppConfigWithActiveProfile.java 注册Profile 为like 的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Profile(&quot;like&quot;)</span></span><br><span class="line">&gt;<span class="meta">@Configuration</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfigWithActiveProfile</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Subject <span class="title function_">subject</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">       subject.setLike(<span class="string">&quot;物理&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> subject;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>AppConfigWithInactiveProfile.java 注册Profile 为wenke 的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Profile(&quot;wenke&quot;)</span></span><br><span class="line">&gt;<span class="meta">@Configuration</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfigWithInactiveProfile</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Subject <span class="title function_">subject</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">       subject.setWenke(<span class="string">&quot;历史&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> subject;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>修改一下对应的测试类，设置系统环境，当Profile 为like 和 wenke 的时候分别注册各自对应的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ------------------------------ 测试 profile  ------------------------------</span></span><br><span class="line">&gt;<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">&gt;<span class="comment">// 激活 like 的profile</span></span><br><span class="line">&gt;context.getEnvironment().setActiveProfiles(<span class="string">&quot;like&quot;</span>);</span><br><span class="line">&gt;context.register(AppConfigWithActiveProfile.class,AppConfigWithInactiveProfile.class);</span><br><span class="line">&gt;context.refresh();</span><br><span class="line">&gt;<span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> (Subject) context.getBean(<span class="string">&quot;subject&quot;</span>);</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;subject = &quot;</span> + subject);</span><br></pre></td></tr></table></figure><blockquote><p>把context.getEnvironment().setActiveProfiles(“wenke”) 设置为wenke，观察其对应的输出内容发生了变化，这就是@Profile的作用，有一层可选择性注册的意味。</p></blockquote><h3 id="Scope-注解"><a href="#Scope-注解" class="headerlink" title="@Scope 注解"></a>@Scope 注解</h3><p>在Spring中对于bean的默认处理都是单例的，我们通过上下文容器.getBean方法拿到bean容器，并对其进行实例化，这个实例化的过程其实只进行一次，即多次getBean 获取的对象都是同一个对象，也就相当于这个bean的实例在IOC容器中是public的，对于所有的bean请求来讲都可以共享此bean。</p><p><img src="/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/1515111-20190713092501745-1843106227.png" alt="img"></p><p>那么假如我不想把这个bean被所有的请求共享或者说每次调用我都想让它生成一个bean实例该怎么处理呢？</p><p><strong>多例Bean</strong></p><p>bean的非单例原型范围会使每次发出对该特定bean的请求时都创建新的bean实例，也就是说，bean被注入另一个bean，或者通过对容器的getBean()方法调用来请求它，可以用如下图来表示：</p><p><img src="/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/1515111-20190713092513090-1380293645.png" alt="img"></p><p>通过一个示例来说明bean的多个实例</p><p>新建一个<code>AppConfigWithAliasAndScope</code>配置类，用来定义多例的bean，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Configuration</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfigWithAliasAndScope</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 为myBean起两个名字，b1 和 b2</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Scope</span> 默认为 singleton，但是可以指定其作用域</span></span><br><span class="line"><span class="comment">    * prototype 是多例的，即每一次调用都会生成一个新的实例。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean(&#123;&quot;b1&quot;,&quot;b2&quot;&#125;)</span></span><br><span class="line">   <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>测试一下多例的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ------------------------------ 测试scope  ------------------------------</span></span><br><span class="line">&gt;<span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfigWithAliasAndScope.class);</span><br><span class="line">&gt;<span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> (MyBean) context.getBean(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">&gt;<span class="type">MyBean</span> <span class="variable">myBean2</span> <span class="operator">=</span> (MyBean) context.getBean(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line">&gt;System.out.println(myBean);</span><br><span class="line">&gt;System.out.println(myBean2);</span><br></pre></td></tr></table></figure><p><strong>其他情况</strong></p><p>除了多例的情况下，Spring还为我们定义了其他情况：</p><table><thead><tr><th>Scope</th><th>Descriptionn</th></tr></thead><tbody><tr><td>singleton</td><td>默认单例的bean定义信息，对于每个IOC容器来说都是单例对象</td></tr><tr><td>prototype</td><td>bean对象的定义为任意数量的对象实例</td></tr><tr><td>request</td><td>bean对象的定义为一次HTTP请求的生命周期，也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。仅仅在web-aware的上下文中有效</td></tr><tr><td>session</td><td>bean对象的定义为一次HTTP会话的生命周期。仅仅在web-aware的上下文中有效</td></tr><tr><td>application</td><td>bean对象的定义范围在ServletContext生命周期内。仅仅在web-aware的上下文中有效</td></tr><tr><td>websocket</td><td>bean对象的定义为WebSocket的生命周期内。仅仅在web-aware的上下文中有效</td></tr></tbody></table><blockquote><p>singleton和prototype 一般都用在普通的Java项目中，而request、session、application、websocket都用于web应用中。</p></blockquote><p><strong>request、session、application、websocket</strong>的作用范围</p><p>你可以体会到 request、session、application、websocket 的作用范围在当你使用web-aware的ApplicationContext应用程序上下文的时候，比如<code>XmlWebApplicationContext</code>的实现类。如果你使用了像是<code>ClassPathXmlApplicationContext</code>的上下文环境时，就会抛出<code>IllegalStateException</code>因为Spring不认识这个作用范围。</p><h3 id="Lazy-注解"><a href="#Lazy-注解" class="headerlink" title="@Lazy 注解"></a>@Lazy 注解</h3><p><code>@Lazy</code> : 表明一个bean 是否延迟加载，可以作用在方法上，表示这个方法被延迟加载；可以作用在@Component (或者由@Component 作为原注解) 注释的类上，表明这个类中所有的bean 都被延迟加载。如果没有@Lazy注释，或者@Lazy 被设置为false，那么该bean 就会急切渴望被加载；除了上面两种作用域，@Lazy 还可以作用在@Autowired和@Inject注释的属性上，在这种情况下，它将为该字段创建一个惰性代理，作为使用ObjectFactory或Provider的默认方法。下面来演示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Lazy</span></span><br><span class="line">&gt;<span class="meta">@Configuration</span></span><br><span class="line">&gt;<span class="meta">@ComponentScan(basePackages = &quot;com.spring.configuration.pojo&quot;)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfigWithLazy</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;myBean Initialized&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MyBean <span class="title function_">IfLazyInit</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;initialized&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li>修改测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigurationApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfigWithLazy.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取启动过程中的bean 定义的名称</span></span><br><span class="line">       <span class="keyword">for</span>(String str : context.getBeanDefinitionNames())&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>输出你会发现没有关于bean的定义信息，但是当把@Lazy 注释拿掉，你会发现输出了关于bean的初始化信息</p><h3 id="DependsOn-注解"><a href="#DependsOn-注解" class="headerlink" title="@DependsOn 注解"></a>@DependsOn 注解</h3><p>指当前bean所依赖的bean。任何指定的bean都能保证在此bean创建之前由IOC容器创建。在bean没有通过属性或构造函数参数显式依赖于另一个bean的情况下很少使用，可能直接使用在任何直接或者间接使用 Component 或者Bean 注解表明的类上。来看一下具体的用法</p><p>新建三个Bean，分别是FirstBean、SecondBean、ThirdBean三个普通的bean，新建<code>AppConfigWithDependsOn</code>并配置它们之间的依赖关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SecondBean secondBean;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ThirdBean thirdBean;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FirstBean</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;FirstBean Initialized via Constuctor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">SecondBean</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;SecondBean Initialized via Constuctor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdBean</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ThirdBean</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;ThirdBean Initialized via Constuctor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="meta">@Configuration</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfigWithDependsOn</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean(&quot;firstBean&quot;)</span></span><br><span class="line">   <span class="meta">@DependsOn(value = &#123;</span></span><br><span class="line"><span class="meta">           &quot;secondBean&quot;,</span></span><br><span class="line"><span class="meta">           &quot;thirdBean&quot;</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="keyword">public</span> FirstBean <span class="title function_">firstBean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FirstBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean(&quot;secondBean&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> SecondBean <span class="title function_">secondBean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecondBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean(&quot;thirdBean&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ThirdBean <span class="title function_">thirdBean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThirdBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>使用测试类进行测试，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ------------------------------ 测试 DependsOn  ------------------------------</span></span><br><span class="line">&gt;<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfigWithDependsOn.class);</span><br><span class="line">&gt;context.getBean(FirstBean.class);</span><br><span class="line">&gt;context.close();</span><br></pre></td></tr></table></figure><p>输出 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;SecondBean Initialized via Constuctor</span><br><span class="line">&gt;ThirdBean Initialized via Constuctor</span><br><span class="line">&gt;FirstBean Initialized via Constuctor</span><br></pre></td></tr></table></figure><p>由于firstBean 的创建过程首先需要依赖<code>secondBean</code> 和 <code>thirdBean</code>的创建，所以secondBean 首先被加载其次是thirdBean 最后是firstBean。</p><p>如果把@DependsOn 注解加在<code>AppConfigWithDependsOn</code> 类上则它们的初始化顺序就会变为 firstBean、secondBean、thirdBean</p><h3 id="Primary-注解"><a href="#Primary-注解" class="headerlink" title="@Primary 注解"></a>@Primary 注解</h3><p>指示当多个候选者有资格自动装配依赖项时，应优先考虑bean。此注解在语义上就等同于在Spring XML中定义的bean 元素的primary属性。注意： 除非使用component-scanning进行组件扫描，否则在类级别上使用@Primary不会有作用。如果@Primary 注解定义在XML中，那么@Primary 的注解元注解就会忽略，相反使用</p><p><strong>@Primary 的两种使用方式</strong></p><ul><li>与@Bean 一起使用，定义在方法上，方法级别的注解</li><li>与@Component 一起使用，定义在类上，类级别的注解</li></ul><p>通过一则示例来演示一下：</p><p>新建一个<code>AppConfigWithPrimary</code>类，在方法级别上定义@Primary注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Configuration</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfigWithPrimary</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MyBean <span class="title function_">myBeanOne</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="keyword">public</span> MyBean <span class="title function_">myBeanTwo</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了两个bean ，其中myBeanTwo 由@Primary 进行标注，表示它首先会进行注册，使用测试类进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ------------------------------ 测试 Primary  ------------------------------</span></span><br><span class="line">&gt;<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfigWithPrimary.class);</span><br><span class="line">&gt;<span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(MyBean.class);</span><br><span class="line">&gt;System.out.println(bean);</span><br></pre></td></tr></table></figure><blockquote><p>你可以尝试放开@Primary ，使用测试类测试的话会发现出现报错信息，因为你尝试获取的是MyBean.class,而我们代码中定义了两个MyBean 的类型，所以需要@Primary 注解表明哪一个bean需要优先被获取。</p></blockquote></blockquote><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>（1）控制反转：<br>IOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想</p><p>控制：IOC意味着将你设计好的对象交给IOC容器控制，而不是传统的在你的对象内部直接控制；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建；</span><br><span class="line"></span><br><span class="line">谁控制谁？当然是IOC容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</span><br></pre></td></tr></table></figure><p>反转：传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反转则是由IOC容器来帮忙创建及注入依赖对象；</span><br><span class="line"></span><br><span class="line">由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IOC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。</span><br><span class="line"></span><br><span class="line">传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；</span><br><span class="line"></span><br><span class="line">有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</span><br><span class="line"></span><br><span class="line">其实 IOC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IOC/DI 思想中，应用程序就变成被动的了，被动的等待 IOC 容器来创建并注入它所需要的资源了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例图：</p><p><img src="/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xCSjg4ODg4ODg=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>​                                                          <img src="/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xCSjg4ODg4ODg=,size_16,color_FFFFFF,t_70-1667553166704-7.png" alt="img"></p><p>（2）使用IOC的目的：降低耦合度<br>用伪代码来比较：用工厂类来做例子（注意：工厂类不是IOC模式）</p><p>原始方式：一个类调用另外一个类的对象使用</p><p><img src="/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xCSjg4ODg4ODg=,size_16,color_FFFFFF,t_70-1667553195953-10.png" alt="img"></p><p>升级后：工厂模式解耦，但是也不是完全解耦 </p><p><img src="/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xCSjg4ODg4ODg=,size_16,color_FFFFFF,t_70-1667553200671-13.png" alt="img"></p><p>（3）IOC解耦过程图解<br>可能一时半会看不懂图，但是通过后面深入理解就会豁然开朗</p><p>IOC的思想就是我们仅仅通过修改XML配置文件的对象路径，就可以轻松把对象创建出来去被别的类进行调用</p><p><img src="/2022/11/04/Springboot%E7%9A%84bean%E6%B3%A8%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xCSjg4ODg4ODg=,size_16,color_FFFFFF,t_70-1667553227583-16.png" alt="img"></p><p>2.IOC的底层原理<br>（1）xml解析、工厂模式、反射</p><p>3.IOC接口</p><p>（1）IOC思想<br>         基于IOC容器完成，IOC容器底层就是对象工厂</p><p>（2）Spring提供IOC容器实现两种方式：（两个接口）</p><p>第一种: BeanFactory ，可以对IOC容器基本实现，是Spring 内部的使用接口，不提供开发人员进行使用</p><p>【加载配置文件的时候不会创建对象，在获取对象（也就是说在使用的时候）才会去创建对象】</p><p>第二种：ApplicationContext，是BeanFactory 接口的子接口，提供更多强大的功能，一般由开发人员使用</p><p>【加载配置文件的时候会把在配置文件中的对象进行创建】</p><p>一般推荐使用第二种，因为Spring框架，要结合web项目进行操作，通俗点来说就是用tomcat服务器进行启动，因此把这些耗时耗内存的都在项目启动的时候进行处理更加合适</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为实践周，这几周天天写代码，没有时间更新博客。学会了很多go相关的东西，下次补充。&lt;/p&gt;
&lt;h3 id=&quot;什么是Bean&quot;&gt;&lt;a href=&quot;#什么是Bean&quot; class=&quot;headerlink&quot; title=&quot;什么是Bean&quot;&gt;&lt;/a&gt;什么是Bean&lt;/h3&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="个人理解" scheme="https://gwtt.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
    <category term="Springboot" scheme="https://gwtt.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>AOP自己实现demo</title>
    <link href="https://gwtt.github.io/2022/10/10/AOP%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0demo/"/>
    <id>https://gwtt.github.io/2022/10/10/AOP%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0demo/</id>
    <published>2022-10-10T15:57:36.000Z</published>
    <updated>2022-10-10T16:19:08.448Z</updated>
    
    <content type="html"><![CDATA[<p>跟着</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;跟着&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="AOP" scheme="https://gwtt.github.io/tags/AOP/"/>
    
    <category term="个人理解" scheme="https://gwtt.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>AOP初级</title>
    <link href="https://gwtt.github.io/2022/10/10/AOP%E5%88%9D%E7%BA%A7/"/>
    <id>https://gwtt.github.io/2022/10/10/AOP%E5%88%9D%E7%BA%A7/</id>
    <published>2022-10-10T02:57:36.000Z</published>
    <updated>2022-10-10T15:00:58.601Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要来谈谈AOP面向切面编程，这东西我已经在项目里运用过好多次，但是从来没有一个系统性的整理，所以，用几篇文章来好好的梳理一下什么是AOP，并且如何在项目里充分运用它。</p><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><blockquote><p>AOP面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>最简单的例子就是，你实现了一个加法函数，但是你不想在改变原函数功能的基础之上，实现乘法。这时候你可以在外部添加一个类，然后通过AOP的技术给这个方法添加功能的操作，这就是AOP。</p></blockquote><h3 id="AOP的特点是什么"><a href="#AOP的特点是什么" class="headerlink" title="AOP的特点是什么"></a>AOP的特点是什么</h3><blockquote><p>AOP代表的是一个横向的关系，将“对象”比作一个空心的圆柱体，其中封装的是对象的属性和行为；则面向方面编程的方法，就是将这个圆柱体以切面形式剖开，选择性的提供业务逻辑。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹，但完成了效果。</p></blockquote><h3 id="实现AOP的技术"><a href="#实现AOP的技术" class="headerlink" title="实现AOP的技术"></a>实现AOP的技术</h3><blockquote><p>主要分为两大类</p><ul><li><strong>采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行</strong></li><li><strong>采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码</strong></li></ul></blockquote><p>然后AOP的底层原理就是使用了动态代理</p><p>主要分为两种情况</p><p>（1）有接口，使用了JDK的动态代理</p><p>（2）没有接口，使用了CGLIB代理</p><h3 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h3><blockquote><p>利用AOP可以对我们边缘业务进行隔离，降低无关业务逻辑耦合性。提高程序的可重用性，同时提高了开发的效率。一般用于<code>日志记录，性能统计，安全控制，权限管理，事务处理，异常处理，资源池管理</code></p></blockquote><h1 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h1><ol><li>通知（Advice）包含了需要用于多个应用对象的横切行为，完全听不懂，没关系，通俗一点说就是定义了“什么时候”和“做什么”。</li><li>连接点（Join Point）是程序执行过程中能够应用通知的所有点。</li><li>切点（Poincut）是定义了在“什么地方”进行切入，哪些连接点会得到通知。显然，切点一定是连接点。</li><li>切面（Aspect）是通知和切点的结合。通知和切点共同定义了切面的全部内容——是什么，何时，何地完成功能。</li><li>引入（Introduction）允许我们向现有的类中添加新方法或者属性。</li><li>织入（Weaving）是把切面应用到目标对象并创建新的代理对象的过程，分为编译期织入、类加载期织入和运行期织入。</li></ol><h1 id="整合使用"><a href="#整合使用" class="headerlink" title="整合使用"></a>整合使用</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>在springboot中使用aop要导aop依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--aop 切面--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里版本依赖于<code>spring-boot-start-parent</code>父pom中的<code>spring-boot-dependencies</code></p><h2 id="编写拦截的bean"><a href="#编写拦截的bean" class="headerlink" title="编写拦截的bean"></a>编写拦截的bean</h2><p>这里我们定义一个<code>controller</code>用于拦截所有请求的记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h2><p>SpringBoot在使用切面的时候采用<code>@Aspect</code>注解对POJO进行标注，该注解表明该类不仅仅是一个POJO，还是一个切面容器</p><h2 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h2><p>切点是通过<code>@Pointcut</code>注解和<code>切点表达式</code>定义的。</p><p>@Pointcut注解可以在一个切面内定义可<code>重用</code>的切点。</p><p>由于Spring切面粒度最小是达到<code>方法级别</code>，而<code>execution表达式</code>可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的部件，并且实际中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。如图是execution表达式的语法：</p><p><a href="https://files.mdnice.com/user/16746/b14924c2-d1ee-4195-8435-14ad7c2b6159.png"><img src="/2022/10/10/AOP%E5%88%9D%E7%BA%A7/b14924c2-d1ee-4195-8435-14ad7c2b6159.png" alt="img"></a></p><p>execution表示在方法执行的时候触发。以“”开头，表明方法返回值类型为任意类型。然后是全限定的类名和方法名，“”可以表示任意类和任意方法。对于方法参数列表，可以使用“..”表示参数为任意类型。如果需要多个表达式，可以使用“&amp;&amp;”、“||”和“!”完成与、或、非的操作。</p><h2 id="定义通知"><a href="#定义通知" class="headerlink" title="定义通知"></a>定义通知</h2><p>通知有五种类型，分别是：</p><ol><li>前置通知（@Before）：在目标方法调用之前调用通知</li><li>后置通知（@After）：在目标方法完成之后调用通知</li><li>环绕通知（@Around）：在被通知的方法调用之前和调用之后执行自定义的方法</li><li>返回通知（@AfterReturning）：在目标方法成功执行之后调用通知</li><li>异常通知（@AfterThrowing）：在目标方法抛出异常之后调用通知</li></ol><p>代码中定义了三种类型的通知，使用@Before注解标识前置通知，打印“beforeAdvice…”，使用@After注解标识后置通知，打印“AfterAdvice…”，使用@Around注解标识环绕通知，在方法执行前和执行之后分别打印“before”和“after”。这样一个切面就定义好了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution (* com.shangguan.aop.controller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;test()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beforeAdvice...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;test()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterAdvice...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;test()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceedingJoinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><a href="https://files.mdnice.com/user/16746/fa1b0129-ca1c-4f1a-9f29-fbed848bad4a.png"><img src="/2022/10/10/AOP%E5%88%9D%E7%BA%A7/fa1b0129-ca1c-4f1a-9f29-fbed848bad4a.png" alt="img"></a></p><h1 id="案例场景"><a href="#案例场景" class="headerlink" title="案例场景"></a>案例场景</h1><p>这里我们通过一个日志记录场景来完整的使用Aop切面业务层只需关心代码逻辑实现而不用关心请求参数和响应参数的日志记录</p><p>那么首先我们需要自定义一个全局日志记录的切面类<code>GlobalLogAspect</code></p><p>然后在该类添加@Aspect注解，然后在定义一个公共的切入点（Pointcut），指向需要处理的包，然后在定义一个前置通知(添加@Before注解)，后置通知(添加@AfterReturning)和环绕通知（添加@Around）方法实现即可</p><h2 id="日志信息类"><a href="#日志信息类" class="headerlink" title="日志信息类"></a>日志信息类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.soboys.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogSubject</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消耗时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String spendTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IP地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求返回的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 城市</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求设备信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String device;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局日志拦截"><a href="#全局日志拦截" class="headerlink" title="全局日志拦截"></a>全局日志拦截</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.soboys.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseAspectSupport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Method <span class="title function_">resolveMethod</span><span class="params">(ProceedingJoinPoint point)</span> &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature)point.getSignature();<span class="comment">//获取方法签名</span></span><br><span class="line">        Class&lt;?&gt; targetClass = point.getTarget().getClass();<span class="comment">//获取切入点的目标类</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> getDeclaredMethod(targetClass, signature.getName(),</span><br><span class="line">                signature.getMethod().getParameterTypes());</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;无法解析目标方法: &quot;</span> + signature.getMethod().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(Class&lt;?&gt; clazz, String name, Class&lt;?&gt;... parameterTypes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.getDeclaredMethod(name, parameterTypes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            Class&lt;?&gt; superClass = clazz.getSuperclass();</span><br><span class="line">            <span class="keyword">if</span> (superClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getDeclaredMethod(superClass, name, parameterTypes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GlobalLogAspect</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.soboys.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.date.DateUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.date.TimeInterval;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> cn.soboys.core.utils.HttpContextUtil;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalLogAspect</span> <span class="keyword">extends</span> <span class="title class_">BaseAspectSupport</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切面Pointcut</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cn.soboys.mallapi.controller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;log()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">LogSubject</span> <span class="variable">logSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogSubject</span>();</span><br><span class="line">        <span class="comment">//记录时间定时器</span></span><br><span class="line">        <span class="type">TimeInterval</span> <span class="variable">timer</span> <span class="operator">=</span> DateUtil.timer(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//执行结果</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        logSubject.setResult(result);</span><br><span class="line">        <span class="comment">//执行消耗时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">endTime</span> <span class="operator">=</span> timer.intervalPretty();</span><br><span class="line">        logSubject.setSpendTime(endTime);</span><br><span class="line">        <span class="comment">//执行参数</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> resolveMethod(joinPoint);</span><br><span class="line">        logSubject.setParameter(getParameter(method, joinPoint.getArgs()));</span><br><span class="line">        </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpContextUtil.getRequest();</span><br><span class="line">        <span class="comment">// 接口请求时间</span></span><br><span class="line">        logSubject.setStartTime(DateUtil.now());</span><br><span class="line">        <span class="comment">//请求链接</span></span><br><span class="line">        logSubject.setUrl(request.getRequestURL().toString());</span><br><span class="line">        <span class="comment">//请求方法GET,POST等</span></span><br><span class="line">        logSubject.setMethod(request.getMethod());</span><br><span class="line">        <span class="comment">//请求设备信息</span></span><br><span class="line">        logSubject.setDevice(HttpContextUtil.getDevice());</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        logSubject.setIp(HttpContextUtil.getIpAddr());</span><br><span class="line">        <span class="comment">//接口描述</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(ApiOperation.class)) &#123;</span><br><span class="line">            <span class="type">ApiOperation</span> <span class="variable">apiOperation</span> <span class="operator">=</span> method.getAnnotation(ApiOperation.class);</span><br><span class="line">            logSubject.setDescription(apiOperation.value());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> JSONUtil.toJsonPrettyStr(logSubject);</span><br><span class="line">        log.info(a);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据方法和传入的参数获取请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">getParameter</span><span class="params">(Method method, Object[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; argList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Parameter[] parameters = method.getParameters();</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将RequestBody注解修饰的参数作为请求参数</span></span><br><span class="line">            <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> parameters[i].getAnnotation(RequestBody.class);</span><br><span class="line">            <span class="comment">//将RequestParam注解修饰的参数作为请求参数</span></span><br><span class="line">            <span class="type">RequestParam</span> <span class="variable">requestParam</span> <span class="operator">=</span> parameters[i].getAnnotation(RequestParam.class);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> parameters[i].getName();</span><br><span class="line">            <span class="keyword">if</span> (requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">                argList.add(args[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestParam != <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(key, args[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(key, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            argList.add(map);</span><br><span class="line">        &#125;        <span class="keyword">if</span> (argList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> argList.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> argList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天主要来谈谈AOP面向切面编程，这东西我已经在项目里运用过好多次，但是从来没有一个系统性的整理，所以，用几篇文章来好好的梳理一下什么是AOP，并且如何在项目里充分运用它。&lt;/p&gt;
&lt;h2 id=&quot;什么是AOP&quot;&gt;&lt;a href=&quot;#什么是AOP&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="AOP" scheme="https://gwtt.github.io/tags/AOP/"/>
    
    <category term="个人理解" scheme="https://gwtt.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟线程</title>
    <link href="https://gwtt.github.io/2022/10/09/Java%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
    <id>https://gwtt.github.io/2022/10/09/Java%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-10-09T06:06:36.000Z</published>
    <updated>2022-10-09T11:19:49.852Z</updated>
    
    <content type="html"><![CDATA[<p>因为在Java19之前，Java只有一种线程，然后为了与19中的虚拟线程区分开来，所以之前的线程统称为平台线程。</p><p>平台线程与操作系统的内核线程是一一对应的。</p><p>然后我们主要来谈论19中新添加（模仿）的线程–虚拟线程</p><h3 id="虚拟线程特征"><a href="#虚拟线程特征" class="headerlink" title="虚拟线程特征"></a>虚拟线程特征</h3><ul><li>是用户模式线程</li><li>由Java运行时调度</li><li>虚拟线程和内核线程是M对N的对应关系，也就是M个虚拟线程会被映射到N个内核线程上 </li></ul><h3 id="虚拟线程可以使用独占线程处理每个请求的并发风格，也就是thread-per-request"><a href="#虚拟线程可以使用独占线程处理每个请求的并发风格，也就是thread-per-request" class="headerlink" title="虚拟线程可以使用独占线程处理每个请求的并发风格，也就是thread-per-request"></a>虚拟线程可以使用独占线程处理每个请求的并发风格，也就是thread-per-request</h3><h3 id="thread-per-request特点"><a href="#thread-per-request特点" class="headerlink" title="thread-per-request特点"></a>thread-per-request特点</h3><ul><li>使用独占的线程来处理该请求</li><li>易于理解和编程实现</li><li>易于调优和性能调优</li></ul><p>但是thread-per-request不能用平台线程来实现，因为平台线程是操作系统中的线程操作的一种封装，而操作系统的线程会占用资源，存在数量上限，对于一个海量级别的服务端来说，不可能一个请求来，然后去生成一个平台线程。</p><p>为了实现thread-per-request，目前有这几种解决思路</p><ul><li>依赖于非阻塞I/O和异步编程（用少量线程处理大量的请求）</li><li>可以提升系统的吞吐量</li><li>开发人员必须熟悉所使用的底层框架</li></ul><h3 id="使用虚拟线程好处"><a href="#使用虚拟线程好处" class="headerlink" title="使用虚拟线程好处"></a>使用虚拟线程好处</h3><ul><li>使用最自然的方式来编写代码</li><li>把请求的处理逻辑全部在一个虚拟线程中完成</li><li>降低了编写高并发服务端应用的难度</li></ul><p>虚拟线程不需要放入线程池</p><h3 id="虚拟线程的调度"><a href="#虚拟线程的调度" class="headerlink" title="虚拟线程的调度"></a>虚拟线程的调度</h3><ul><li>由JDK负责调度</li><li>JDK把虚拟线程分配个平台线程</li><li>平台线程则由操作系统负责调度</li></ul><p>一个虚拟线程所分配的平台线程被称为该虚拟线程的<strong>载体</strong>，然后一个虚拟线程可能被调度到多个载体上，载体的标识对于虚拟线程是不可见的</p><p>JDK调度虚拟线程时，使用的是一个以FIFO模式工作的work-stealing ForkJoinPool，该ForkJoinPool的paralleism决定了调度时可以使用的平台线程的数量</p><h3 id="虚拟线程的执行"><a href="#虚拟线程的执行" class="headerlink" title="虚拟线程的执行"></a>虚拟线程的执行</h3><ul><li><p>把虚拟线程绑定到平台线程</p></li><li><p>从平台线程上接触绑定，当虚拟线程在等待I/O或是执行某些阻塞操作时，<strong>可以从平台线程上解除绑定</strong></p><p><strong>等待阻塞操作完成之后，可以绑定到新的平台线程上继续执行</strong></p></li><li><p>对于应用代码来说是透明的</p></li></ul><p>有些JDK中的阻塞操作并不会解除对平台线程的绑定,因此会阻塞平台线程和底层的操作系统线程，比如</p><p>文件操作、Object.wait()方法调用，这些阻塞操作的实现会在内部对此进行补偿</p><p>临时增加JDK的调度器可以使用的线程数量</p><h3 id="在下面两种情况下，虚拟线程会被Pin在载体上而无法解除绑定"><a href="#在下面两种情况下，虚拟线程会被Pin在载体上而无法解除绑定" class="headerlink" title="在下面两种情况下，虚拟线程会被Pin在载体上而无法解除绑定"></a>在下面两种情况下，虚拟线程会被Pin在载体上而无法解除绑定</h3><ul><li>在执行Synchronized方法或块时</li><li>在执行native方法或外部方法时</li></ul><h3 id="创建虚拟线程"><a href="#创建虚拟线程" class="headerlink" title="创建虚拟线程"></a>创建虚拟线程</h3><blockquote><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.ofVirtual().name(<span class="string">&quot;my virtual&quot;</span>).start(() -&gt; System.out.println(<span class="string">&quot;运行&quot;</span>));</span><br></pre></td></tr></table></figure><p>一个新的虚拟线程被创建并启动，返回的时java.lang.Thread类的对象</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.startVirtualThread(Runnable task)</span><br></pre></td></tr></table></figure><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>使用线程工厂来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">factory</span> <span class="operator">=</span> Thread.ofVirtual().factory();</span><br><span class="line"><span class="type">var</span> <span class="variable">thread</span> <span class="operator">=</span> factory.newThread(()-&gt; System.out.println(<span class="string">&quot;在工厂中创建&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h3><p>使用线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line">Executors.newThreadPerTaskExecutor(ThreadFactory threadFactory);</span><br></pre></td></tr></table></figure><p>用Executors对象所能创建的线程数量理论上没有上限(受限于内存)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为在Java19之前，Java只有一种线程，然后为了与19中的虚拟线程区分开来，所以之前的线程统称为平台线程。&lt;/p&gt;
&lt;p&gt;平台线程与操作系统的内核线程是一一对应的。&lt;/p&gt;
&lt;p&gt;然后我们主要来谈论19中新添加（模仿）的线程–虚拟线程&lt;/p&gt;
&lt;h3 id=&quot;虚拟线程</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="个人理解" scheme="https://gwtt.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
    <category term="Juc" scheme="https://gwtt.github.io/tags/Juc/"/>
    
  </entry>
  
  <entry>
    <title>Sa-token</title>
    <link href="https://gwtt.github.io/2022/10/03/Sa-token%E6%A1%86%E6%9E%B6%E7%90%86%E8%A7%A3/"/>
    <id>https://gwtt.github.io/2022/10/03/Sa-token%E6%A1%86%E6%9E%B6%E7%90%86%E8%A7%A3/</id>
    <published>2022-10-03T06:12:36.000Z</published>
    <updated>2022-10-03T08:30:49.552Z</updated>
    
    <content type="html"><![CDATA[<p>这是本人打算长篇更新的博客内容，关于Sa-token这个国人开发的鉴权框架，这是我第一个尝试看源码的框架，同时也去尝试了解之前不敢涉足的一些关于Springboot底层的一些代码</p><p>本文没有先后顺序，后期会理顺整理一下</p><h2 id="Sa-token-dao-redis"><a href="#Sa-token-dao-redis" class="headerlink" title="Sa-token-dao-redis"></a>Sa-token-dao-redis</h2><blockquote><p>我第一次看模块就点开了这个模块，主要是最近想回顾redis，然后觉得redis应该不太复杂</p><p>我很惊讶，因为这个模块只有一个代码组件，下面就是源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaTokenDaoRedis</span> <span class="keyword">implements</span> <span class="title class_">SaTokenDao</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * String专用 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> StringRedisTemplate stringRedisTemplate;    </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Object专用 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; objectRedisTemplate;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 标记：是否已初始化成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> isInit;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">      <span class="comment">// 不重复初始化 </span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.isInit) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;     </span><br><span class="line">      <span class="comment">// 指定相应的序列化方案 </span></span><br><span class="line">      <span class="type">StringRedisSerializer</span> <span class="variable">keySerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">      <span class="type">JdkSerializationRedisSerializer</span> <span class="variable">valueSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>();</span><br><span class="line">      <span class="comment">// 构建StringRedisTemplate</span></span><br><span class="line">      <span class="type">StringRedisTemplate</span> <span class="variable">stringTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">      stringTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">      stringTemplate.afterPropertiesSet();</span><br><span class="line">      <span class="comment">// 构建RedisTemplate</span></span><br><span class="line">      RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(connectionFactory);</span><br><span class="line">      template.setKeySerializer(keySerializer);</span><br><span class="line">      template.setHashKeySerializer(keySerializer);</span><br><span class="line">      template.setValueSerializer(valueSerializer);</span><br><span class="line">      template.setHashValueSerializer(valueSerializer);</span><br><span class="line">      template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始初始化相关组件 </span></span><br><span class="line">      <span class="built_in">this</span>.stringRedisTemplate = stringTemplate;</span><br><span class="line">      <span class="built_in">this</span>.objectRedisTemplate = template;</span><br><span class="line">      <span class="built_in">this</span>.isInit = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取Value，如无返空 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 写入Value，并设定存活时间 (单位: 秒)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(timeout == <span class="number">0</span> || timeout &lt;= SaTokenDao.NOT_VALUE_EXPIRE)  &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否为永不过期 </span></span><br><span class="line">      <span class="keyword">if</span>(timeout == SaTokenDao.NEVER_EXPIRE) &#123;</span><br><span class="line">         stringRedisTemplate.opsForValue().set(key, value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         stringRedisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改指定key-value键值对 (过期时间不变) </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> getTimeout(key);</span><br><span class="line">      <span class="comment">// -2 = 无此键 </span></span><br><span class="line">      <span class="keyword">if</span>(expire == SaTokenDao.NOT_VALUE_EXPIRE) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.set(key, value, expire);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除Value </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String key)</span> &#123;</span><br><span class="line">      stringRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取Value的剩余存活时间 (单位: 秒) </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeout</span><span class="params">(String key)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> stringRedisTemplate.getExpire(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改Value的剩余存活时间 (单位: 秒) </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateTimeout</span><span class="params">(String key, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否想要设置为永久</span></span><br><span class="line">      <span class="keyword">if</span>(timeout == SaTokenDao.NEVER_EXPIRE) &#123;</span><br><span class="line">         <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> getTimeout(key);</span><br><span class="line">         <span class="keyword">if</span>(expire == SaTokenDao.NEVER_EXPIRE) &#123;</span><br><span class="line">            <span class="comment">// 如果其已经被设置为永久，则不作任何处理 </span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果尚未被设置为永久，那么再次set一次</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, <span class="built_in">this</span>.get(key), timeout);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      stringRedisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取Object，如无返空 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(String key)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> objectRedisTemplate.opsForValue().get(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 写入Object，并设定存活时间 (单位: 秒) </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObject</span><span class="params">(String key, Object object, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(timeout == <span class="number">0</span> || timeout &lt;= SaTokenDao.NOT_VALUE_EXPIRE)  &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否为永不过期 </span></span><br><span class="line">      <span class="keyword">if</span>(timeout == SaTokenDao.NEVER_EXPIRE) &#123;</span><br><span class="line">         objectRedisTemplate.opsForValue().set(key, object);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         objectRedisTemplate.opsForValue().set(key, object, timeout, TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新Object (过期时间不变) </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateObject</span><span class="params">(String key, Object object)</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> getObjectTimeout(key);</span><br><span class="line">      <span class="comment">// -2 = 无此键 </span></span><br><span class="line">      <span class="keyword">if</span>(expire == SaTokenDao.NOT_VALUE_EXPIRE) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.setObject(key, object, expire);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除Object </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteObject</span><span class="params">(String key)</span> &#123;</span><br><span class="line">      objectRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取Object的剩余存活时间 (单位: 秒)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getObjectTimeout</span><span class="params">(String key)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> objectRedisTemplate.getExpire(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改Object的剩余存活时间 (单位: 秒)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateObjectTimeout</span><span class="params">(String key, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否想要设置为永久</span></span><br><span class="line">      <span class="keyword">if</span>(timeout == SaTokenDao.NEVER_EXPIRE) &#123;</span><br><span class="line">         <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> getObjectTimeout(key);</span><br><span class="line">         <span class="keyword">if</span>(expire == SaTokenDao.NEVER_EXPIRE) &#123;</span><br><span class="line">            <span class="comment">// 如果其已经被设置为永久，则不作任何处理 </span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果尚未被设置为永久，那么再次set一次</span></span><br><span class="line">            <span class="built_in">this</span>.setObject(key, <span class="built_in">this</span>.getObject(key), timeout);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      objectRedisTemplate.expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 搜索数据 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchData</span><span class="params">(String prefix, String keyword, <span class="type">int</span> start, <span class="type">int</span> size, <span class="type">boolean</span> sortType)</span> &#123;</span><br><span class="line">      Set&lt;String&gt; keys = stringRedisTemplate.keys(prefix + <span class="string">&quot;*&quot;</span> + keyword + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(keys);</span><br><span class="line">      <span class="keyword">return</span> SaFoxUtil.searchList(list, start, size, sortType);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看感觉很简单，就是用SpringDataRedis来进行对Sa-token的id一些存取操作</p><p>个人觉得难点在于初始化那块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String专用 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object专用 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; objectRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记：是否已初始化成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> isInit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line"><span class="comment">// 不重复初始化 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.isInit) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定相应的序列化方案 </span></span><br><span class="line"><span class="type">StringRedisSerializer</span> <span class="variable">keySerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"><span class="type">JdkSerializationRedisSerializer</span> <span class="variable">valueSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>();</span><br><span class="line"><span class="comment">// 构建StringRedisTemplate</span></span><br><span class="line"><span class="type">StringRedisTemplate</span> <span class="variable">stringTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">stringTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">stringTemplate.afterPropertiesSet();</span><br><span class="line"><span class="comment">// 构建RedisTemplate</span></span><br><span class="line">RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">template.setConnectionFactory(connectionFactory);</span><br><span class="line">template.setKeySerializer(keySerializer);</span><br><span class="line">template.setHashKeySerializer(keySerializer);</span><br><span class="line">template.setValueSerializer(valueSerializer);</span><br><span class="line">template.setHashValueSerializer(valueSerializer);</span><br><span class="line">template.afterPropertiesSet();</span><br><span class="line"><span class="comment">// 开始初始化相关组件 </span></span><br><span class="line"><span class="built_in">this</span>.stringRedisTemplate = stringTemplate;</span><br><span class="line"><span class="built_in">this</span>.objectRedisTemplate = template;</span><br><span class="line"><span class="built_in">this</span>.isInit = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个init方法至关重要，初始化RedisTemplate，同时方法是@Autowired注解修饰，这意味着方法会自动调用，参数会自动注入</p><p>那么问题来了，既然这个参数会自动注入，然后参数类型是RedisConnectionFactory，所以我们就要找了。</p><p>最终找到了唯一调用这个方法的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaAloneRedisInject</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentAware</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置信息的前缀 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ALONE_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;sa-token.alone-redis&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sa-Token 持久层接口 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">public</span> SaTokenDao saTokenDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始注入 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnvironment</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果为空或者默认实现，则不进行任何操作 </span></span><br><span class="line"><span class="keyword">if</span>(saTokenDao == <span class="literal">null</span> || saTokenDao <span class="keyword">instanceof</span> SaTokenDaoDefaultImpl) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果配置文件不包含相关配置，则不进行任何操作 </span></span><br><span class="line"><span class="keyword">if</span>(environment.getProperty(ALONE_PREFIX + <span class="string">&quot;.host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------- 开始注入 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取cfg对象 </span></span><br><span class="line"><span class="type">RedisProperties</span> <span class="variable">cfg</span> <span class="operator">=</span> Binder.get(environment).bind(ALONE_PREFIX, RedisProperties.class).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Redis配置 </span></span><br><span class="line"><span class="type">RedisStandaloneConfiguration</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisStandaloneConfiguration</span>();</span><br><span class="line">redisConfig.setHostName(cfg.getHost());</span><br><span class="line">redisConfig.setPort(cfg.getPort());</span><br><span class="line">redisConfig.setDatabase(cfg.getDatabase());</span><br><span class="line">redisConfig.setPassword(RedisPassword.of(cfg.getPassword())); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 连接池配置 </span></span><br><span class="line"><span class="type">GenericObjectPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>();</span><br><span class="line"><span class="comment">// pool配置 </span></span><br><span class="line"><span class="type">Lettuce</span> <span class="variable">lettuce</span> <span class="operator">=</span> cfg.getLettuce();</span><br><span class="line"><span class="keyword">if</span>(lettuce.getPool() != <span class="literal">null</span>) &#123;</span><br><span class="line">RedisProperties.<span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> cfg.getLettuce().getPool();</span><br><span class="line"><span class="comment">// 连接池最大连接数</span></span><br><span class="line">poolConfig.setMaxTotal(pool.getMaxActive());</span><br><span class="line"><span class="comment">// 连接池中的最大空闲连接 </span></span><br><span class="line">poolConfig.setMaxIdle(pool.getMaxIdle());   </span><br><span class="line"><span class="comment">// 连接池中的最小空闲连接</span></span><br><span class="line">poolConfig.setMinIdle(pool.getMinIdle());</span><br><span class="line"><span class="comment">// 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">poolConfig.setMaxWaitMillis(pool.getMaxWait().toMillis());</span><br><span class="line">&#125;</span><br><span class="line">LettucePoolingClientConfiguration.<span class="type">LettucePoolingClientConfigurationBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> LettucePoolingClientConfiguration.builder();</span><br><span class="line"><span class="comment">// timeout </span></span><br><span class="line"><span class="keyword">if</span>(cfg.getTimeout() != <span class="literal">null</span>) &#123;</span><br><span class="line">builder.commandTimeout(cfg.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shutdownTimeout </span></span><br><span class="line"><span class="keyword">if</span>(lettuce.getShutdownTimeout() != <span class="literal">null</span>) &#123;</span><br><span class="line">builder.shutdownTimeout(lettuce.getShutdownTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Factory对象 </span></span><br><span class="line"><span class="type">LettuceClientConfiguration</span> <span class="variable">clientConfig</span> <span class="operator">=</span> builder.poolConfig(poolConfig).build();</span><br><span class="line"><span class="type">LettuceConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LettuceConnectionFactory</span>(redisConfig, clientConfig);</span><br><span class="line">factory.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 开始初始化 SaTokenDao </span></span><br><span class="line"><span class="comment">// 如果是SaTokenDaoRedis</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">&quot;cn.dev33.satoken.dao.SaTokenDaoRedis&quot;</span>);</span><br><span class="line"><span class="type">SaTokenDaoRedis</span> <span class="variable">dao</span> <span class="operator">=</span> (SaTokenDaoRedis)saTokenDao;</span><br><span class="line">dao.isInit = <span class="literal">false</span>;</span><br><span class="line">dao.init(factory);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是SaTokenDaoRedisJackson</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">&quot;cn.dev33.satoken.dao.SaTokenDaoRedisJackson&quot;</span>);</span><br><span class="line"><span class="type">SaTokenDaoRedisJackson</span> <span class="variable">dao</span> <span class="operator">=</span> (SaTokenDaoRedisJackson)saTokenDao;</span><br><span class="line">dao.isInit = <span class="literal">false</span>;</span><br><span class="line">dao.init(factory);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 骗过编辑器，增加配置文件代码提示 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 配置对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = ALONE_PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> RedisProperties <span class="title function_">getSaAloneRedisConfig</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisProperties</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先很明显这个类由@Configuration修饰，注入到IOC容器中，以便Springboot默认执行setEnvironment（）方法</p><p>然后，下面这段话,将配置文件中的属性对应成对象，并实例化获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binder.get(environment).bind(ALONE_PREFIX, RedisProperties.class).get();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RedisStandaloneConfiguration</span> <span class="variable">redisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisStandaloneConfiguration</span>();</span><br><span class="line">redisConfig.setHostName(cfg.getHost());</span><br><span class="line">redisConfig.setPort(cfg.getPort());</span><br><span class="line">redisConfig.setDatabase(cfg.getDatabase());</span><br><span class="line">redisConfig.setPassword(RedisPassword.of(cfg.getPassword())); </span><br><span class="line"><span class="comment">//这边就是配置redis</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接下来就是连接池配置</span></span><br><span class="line"><span class="type">GenericObjectPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>();</span><br><span class="line"><span class="comment">// pool配置 </span></span><br><span class="line"><span class="type">Lettuce</span> <span class="variable">lettuce</span> <span class="operator">=</span> cfg.getLettuce();</span><br><span class="line"><span class="keyword">if</span>(lettuce.getPool() != <span class="literal">null</span>) &#123;</span><br><span class="line">RedisProperties.<span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> cfg.getLettuce().getPool();</span><br><span class="line"><span class="comment">// 连接池最大连接数</span></span><br><span class="line">poolConfig.setMaxTotal(pool.getMaxActive());</span><br><span class="line"><span class="comment">// 连接池中的最大空闲连接 </span></span><br><span class="line">poolConfig.setMaxIdle(pool.getMaxIdle());   </span><br><span class="line"><span class="comment">// 连接池中的最小空闲连接</span></span><br><span class="line">poolConfig.setMinIdle(pool.getMinIdle());</span><br><span class="line"><span class="comment">// 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">poolConfig.setMaxWaitMillis(pool.getMaxWait().toMillis());</span><br><span class="line">&#125;</span><br><span class="line">LettucePoolingClientConfiguration.<span class="type">LettucePoolingClientConfigurationBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> LettucePoolingClientConfiguration.builder();</span><br><span class="line"><span class="comment">// timeout </span></span><br><span class="line"><span class="keyword">if</span>(cfg.getTimeout() != <span class="literal">null</span>) &#123;</span><br><span class="line">builder.commandTimeout(cfg.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shutdownTimeout </span></span><br><span class="line"><span class="keyword">if</span>(lettuce.getShutdownTimeout() != <span class="literal">null</span>) &#123;</span><br><span class="line">builder.shutdownTimeout(lettuce.getShutdownTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Factory对象 </span></span><br><span class="line"><span class="type">LettuceClientConfiguration</span> <span class="variable">clientConfig</span> <span class="operator">=</span> builder.poolConfig(poolConfig).build();</span><br><span class="line"><span class="type">LettuceConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LettuceConnectionFactory</span>(redisConfig, clientConfig);</span><br><span class="line">factory.afterPropertiesSet();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化SaTokenDao </span></span><br><span class="line"><span class="comment">// 如果是SaTokenDaoRedis</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">&quot;cn.dev33.satoken.dao.SaTokenDaoRedis&quot;</span>);</span><br><span class="line"><span class="type">SaTokenDaoRedis</span> <span class="variable">dao</span> <span class="operator">=</span> (SaTokenDaoRedis)saTokenDao;</span><br><span class="line">dao.isInit = <span class="literal">false</span>;</span><br><span class="line">dao.init(factory);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是SaTokenDaoRedisJackson</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">&quot;cn.dev33.satoken.dao.SaTokenDaoRedisJackson&quot;</span>);</span><br><span class="line"><span class="type">SaTokenDaoRedisJackson</span> <span class="variable">dao</span> <span class="operator">=</span> (SaTokenDaoRedisJackson)saTokenDao;</span><br><span class="line">dao.isInit = <span class="literal">false</span>;</span><br><span class="line">dao.init(factory);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尝试去找到对应包下的类，根据找到的情况初始化dao</span></span><br></pre></td></tr></table></figure><p>对于之前那个init上面用@Autowired的问题，还是有许多疑问，比如在SaTokenDaoRedis先注入进IOC，然后再SaAloneRedisInject里面调用setEnvironment（）方法进行注入，这个时候会调用init（）方法，然后调用默认的JedisConnectionFactory容器对象。</p><p>最好的解释是，setEnvironment（）先运行，然后调用SaTokenDaoRedis的init（）方法对内部进行初始化，如果没有的话，才执行默认的连接工厂。</p><p>为此我特地去查了下Springboot中的依赖注入顺序，发现setEnvironment确实先运行</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是本人打算长篇更新的博客内容，关于Sa-token这个国人开发的鉴权框架，这是我第一个尝试看源码的框架，同时也去尝试了解之前不敢涉足的一些关于Springboot底层的一些代码&lt;/p&gt;
&lt;p&gt;本文没有先后顺序，后期会理顺整理一下&lt;/p&gt;
&lt;h2 id=&quot;Sa-token-</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="个人理解" scheme="https://gwtt.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    
    <category term="框架" scheme="https://gwtt.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java函数接口</title>
    <link href="https://gwtt.github.io/2022/10/02/Java%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"/>
    <id>https://gwtt.github.io/2022/10/02/Java%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-10-02T02:10:36.000Z</published>
    <updated>2022-10-10T11:46:14.384Z</updated>
    
    <content type="html"><![CDATA[<p>本人在阅读Sa-token框架的时候，在研究全局策略的时候，发现了用到了大量的函数式接口，于是写下这篇文章巩固一下自己的知识点。</p><p>总所周知啊，Java在1.8的时候推出了函数接口，分别为Function（函数式接口），Supplier（供给式接口），Consumer（消费式接口），Predicate（断言式接口），这四个后面延申出BiFunction等等相应的函数接口。下面具体介绍。</p><h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><blockquote><p>下面是Function的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line"> R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">     Objects.requireNonNull(before);</span><br><span class="line">     <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line"> &#125;</span><br><span class="line">                         </span><br><span class="line"> <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">     Objects.requireNonNull(after);</span><br><span class="line">     <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> t -&gt; t;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     Function&lt;String, Integer&gt; lengthFunction = str -&gt; str.length();</span><br><span class="line">     Function&lt;Integer, Integer&gt; doubleFunction = length -&gt; length * <span class="number">2</span>;</span><br><span class="line">     <span class="type">Integer</span> <span class="variable">doubleLength</span> <span class="operator">=</span> doubleFunction.compose(lengthFunction).apply(<span class="string">&quot;www.wdbyte.com&quot;</span>);</span><br><span class="line">     System.out.println(doubleLength);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//另一种写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     Function&lt;String, Integer&gt; lengthFunction = str -&gt; str.length();</span><br><span class="line">     Function&lt;Integer, Integer&gt; doubleFunction = length -&gt; length * <span class="number">2</span>;</span><br><span class="line">     <span class="type">Integer</span> <span class="variable">doubleLength</span> <span class="operator">=</span> lengthFunction.andThen(doubleFunction).apply(<span class="string">&quot;www.wdbyte.com&quot;</span>);</span><br><span class="line">     System.out.println(doubleLength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 28</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很显然，一般形式为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;T,R&gt; varname = (T) -&gt;&#123;</span><br><span class="line"> 操作...</span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">apply来调用方法</span></span><br><span class="line"><span class="comment">compose和andThen用来连接其余Function方法</span></span><br><span class="line"><span class="comment">identity用来返回一个lambda方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>然后BiFunction相对于Function而言，接受的参数从一个变成两个</strong></p><p>不过特殊的是,BiFunction的andThen方法可以接受Function参数，所以可以进一步抽象成更加通用的方法</p><p>比如工厂模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 get set toString</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBiFunctionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(dogFactory(<span class="string">&quot;牧羊犬&quot;</span>, <span class="number">1</span>, Dog::<span class="keyword">new</span>));</span><br><span class="line">        System.out.println(dogFactory(<span class="string">&quot;哈士奇&quot;</span>, <span class="number">2</span>, Dog::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R <span class="keyword">extends</span> <span class="title class_">Dog</span>&gt; Dog <span class="title function_">dogFactory</span><span class="params">(String name, Integer age, BiFunction&lt;String, Integer, R&gt; biFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h3><blockquote><p>下面是Supplier的源码，看起来非常的简单，就一个返回T</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于不需要提供参数，所以可以很方便的用于对象创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Supplier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;Integer&gt; supplier = () -&gt; <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">       </span><br><span class="line">        Supplier&lt;LocalDateTime&gt; supplier2 = LocalDateTime::now;</span><br><span class="line">        System.out.println(supplier2.get());</span><br><span class="line">        System.out.println(supplier2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，为了方便 <code>Supplier</code> 的使用，提供了指定类型的 <code>Supplier</code>，有 <code>BooleanSupplier</code>, <code>DoubleSupplier</code>, <code>IntSupplier</code>, <code>LongSupplier</code>,用这些来规定返回值类型。</p></blockquote><h3 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h3><blockquote><p>Consumer主要用来消费参数，但是不返回任何值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; lengthConsumer = s -&gt; System.out.println(s.length());</span><br><span class="line">        lengthConsumer.accept(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Consumer&lt;String&gt; printConsumer = System.out::println;</span><br><span class="line">        printConsumer.accept(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8ConsumerForEach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; printConsumer = System.out::println;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;c#&quot;</span>, <span class="string">&quot;python&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        forEach(list, printConsumer);</span><br><span class="line">        forEach(list, s -&gt; System.out.println(s.length()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">            consumer.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>函数接口</th><th>描述</th></tr></thead><tbody><tr><td>BiConsumer</td><td>传入两个任意类型参数，无返回值</td></tr><tr><td>DoubleConsumer</td><td>传入一个 double 参数，无返回值</td></tr><tr><td>IntConsumer</td><td>传入一个 int 参数，无返回值</td></tr><tr><td>LongConsumer</td><td>传入一个 long 参数，无返回值</td></tr><tr><td>ObjDoubleConsumer</td><td>传入一个任意类型参数，一个 double 参数，无返回值</td></tr><tr><td>ObjIntConsumer</td><td>传入一个任意类型参数，一个 int 参数，无返回值</td></tr><tr><td>ObjLongConsumer</td><td>传入一个任意类型参数，一个 long 参数，无返回值</td></tr></tbody></table></blockquote><h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><blockquote><p>这个是断言式接口，什么是断言，其实就是个判断语句，它接受一个T泛型参数，返回值为布尔类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;<span class="comment">//使用 and() 方法，可以让前后两个 Predicate 判断条件一起生效。</span></span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;<span class="comment">//predicate.negate() 方法会返回一个与指定判断相反的 Predicate。</span></span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;<span class="comment">//使用 and() 方法，可以让前后两个 Predicate 判断条件都生效。</span></span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Predicate</code> 的 <code>or()</code> ，<code>and()</code>，<code>negate()</code> 方法可以随意组合 <code>Predicate</code>，组合后的判断逻辑是从左到右，从前到后，顺次判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8PredicateChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numberList = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Predicate&lt;Integer&gt; lessThan5 = number -&gt; number &lt;= <span class="number">5</span>;</span><br><span class="line">        Predicate&lt;Integer&gt; greaterThan9 = number -&gt; number &gt;= <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小于等于 5</span></span><br><span class="line">        System.out.println(filter(numberList, lessThan5));</span><br><span class="line">        <span class="comment">// 大于 5</span></span><br><span class="line">        System.out.println(filter(numberList, lessThan5.negate()));</span><br><span class="line">        <span class="comment">// 小于等于 5 或者大于等于 9</span></span><br><span class="line">        System.out.println(filter(numberList, lessThan5.or(greaterThan9)));</span><br><span class="line">        <span class="comment">// ! (小于等于 5 AND 大于等于 9)</span></span><br><span class="line">        System.out.println(filter(numberList, lessThan5.and(greaterThan9).negate()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; predicate)</span> &#123;</span><br><span class="line">        List&lt;T&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(t)) &#123;</span><br><span class="line">                resultList.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="UnaryOperator-接口"><a href="#UnaryOperator-接口" class="headerlink" title="UnaryOperator 接口"></a>UnaryOperator 接口</h3><blockquote><p>其实是Function接口的子类，唯一特点就是默认返回值是T，只接受一个参数T</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8UnaryOperatorParams</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;node&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;rust&quot;</span>);</span><br><span class="line">        <span class="comment">// 转大写</span></span><br><span class="line">        UnaryOperator&lt;String&gt; upperFun = s -&gt; s.toUpperCase();</span><br><span class="line">        <span class="comment">// 截取 3 位</span></span><br><span class="line">        UnaryOperator&lt;String&gt; subFun = s -&gt; s.substring(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        List&lt;String&gt; resultList = map(list, upperFun, subFun);</span><br><span class="line">        System.out.println(resultList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">map</span><span class="params">(List&lt;T&gt; list, UnaryOperator&lt;T&gt;... unaryOperator)</span> &#123;</span><br><span class="line">        List&lt;T&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">            <span class="keyword">for</span> (UnaryOperator&lt;T&gt; operator : unaryOperator) &#123;</span><br><span class="line">                t = operator.apply(t);</span><br><span class="line">            &#125;</span><br><span class="line">            resultList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ps:</p><p>这边有个知识点,在java中,…表示可变长度参数列表，表示接受的参数为0到多个Object类型的对象，或者是一个Object[]</p><p>可变长度参数列表必须作为最后一位参数！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本人在阅读Sa-token框架的时候，在研究全局策略的时候，发现了用到了大量的函数式接口，于是写下这篇文章巩固一下自己的知识点。&lt;/p&gt;
&lt;p&gt;总所周知啊，Java在1.8的时候推出了函数接口，分别为Function（函数式接口），Supplier（供给式接口），Consu</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="函数接口" scheme="https://gwtt.github.io/tags/%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Redis客户端</title>
    <link href="https://gwtt.github.io/2022/09/24/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://gwtt.github.io/2022/09/24/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2022-09-24T13:23:36.000Z</published>
    <updated>2022-09-27T10:22:54.078Z</updated>
    
    <content type="html"><![CDATA[<p>下面介绍一下在Java程序中如何使用Redis客户端</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><blockquote><p>Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//输出结果: OK</span></span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果: world</span></span><br><span class="line">jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果:1</span></span><br><span class="line">jedis.incr(<span class="string">&quot;counter&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;jedis.hset(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;f1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">jedis.hset(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;f2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果 : &#123;f1=v1, f2=v2&#125;</span></span><br><span class="line">jedis.hgetAll(<span class="string">&quot;myhash&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;jedis.rpush(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">jedis.rpush(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">jedis.rpush(<span class="string">&quot;mylist&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果 : [1, 2, 3]</span></span><br><span class="line">jedis.lrange(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;jedis.sadd(<span class="string">&quot; myset&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot; myset&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot; myset&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果 : [b, a]</span></span><br><span class="line">jedis.smembers(<span class="string">&quot;myset&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;jedis.zadd(<span class="string">&quot;myzset&quot;</span>, <span class="number">99</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;myzset&quot;</span>, <span class="number">66</span>, <span class="string">&quot;peter&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;myzset&quot;</span>, <span class="number">33</span>, <span class="string">&quot;james&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果 : [[[&quot;james&quot;],33.0], [[&quot;peter&quot;],66.0], [[&quot;tom&quot;],99.0]]</span></span><br><span class="line">jedis.zrangeWithScores(<span class="string">&quot;myzset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3><h4 id="jedis直连"><a href="#jedis直连" class="headerlink" title="jedis直连"></a>jedis直连</h4><p>每次操作创建一个jedis对象，执行完毕后关闭连接，对应的就是一次Tcp连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个jedis对象，这个对象负责和指定Redis节点进行通信</span></span><br><span class="line"> <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;119.23.226.29&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//带密码需要执行认证方法</span></span><br><span class="line">    <span class="comment">//jedis.auth(&quot;123456&quot;);</span></span><br><span class="line">    jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="jedis连接池"><a href="#jedis连接池" class="headerlink" title="jedis连接池"></a>jedis连接池</h4><p>预先生成一批jedis连接对象放入连接池中，当需要对redis进行操作时从连接池中借用jedis对象，操作完成后归还。这样jedis对象可以重复使用，避免了频繁创建socket连接，节省了连接开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="lettuce"><a href="#lettuce" class="headerlink" title="lettuce"></a>lettuce</h2><blockquote><p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection。它利用优秀 netty NIO 框架来高效地管理多个连接。</p><p>RedisURI是redis连接的一些标准信息，比如需要提供数据库名称，密码，url，超时时间等。有三种方式可以创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RedisURI.create(<span class="string">&quot;redis://localhost/&quot;</span>);</span><br><span class="line">RedisURI.Builder.redis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).auth(<span class="string">&quot;password&quot;</span>).database(<span class="number">1</span>).build();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RedisURI</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">事务命令</span><br><span class="line">multi：用于标记事务块的开始,Redis会将后续的命令逐个放入队列中，然后使用exec原子化地执行这个命令队列</span><br><span class="line">exec：执行命令队列</span><br><span class="line">discard：清除命令队列</span><br><span class="line">watch：监视key</span><br><span class="line">unwatch：清除监视key</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RedisURI</span> <span class="variable">redisUri</span> <span class="operator">=</span> RedisURI.builder()<span class="comment">// &lt;1&gt; 创建单机连接的连接信息</span></span><br><span class="line">        .withHost(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line">        .withPort(<span class="number">6379</span>)</span><br><span class="line">        .withTimeout(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS))</span><br><span class="line">        .build();</span><br><span class="line"><span class="type">RedisClient</span> <span class="variable">redisClient</span> <span class="operator">=</span> RedisClient.create(redisUri);<span class="comment">// &lt;2&gt; 创建客户端</span></span><br><span class="line">GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; genericObjectPool = ConnectionPoolSupport.createGenericObjectPool(() -&gt; redisClient.connect(), <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>&lt;&gt;());</span><br><span class="line">StatefulRedisConnection&lt;String, String&gt; connection = genericObjectPool.borrowObject();</span><br><span class="line"><span class="comment">//StatefulRedisConnection&lt;String, String&gt; connection = redisClient.connect();// &lt;3&gt; 创建线程安全的连接</span></span><br><span class="line">RedisCommands&lt;String, String&gt; redisCommands = connection.sync();<span class="comment">// &lt;4&gt; 创建同步命令</span></span><br><span class="line"><span class="comment">//redisCommands.multi();</span></span><br><span class="line"><span class="comment">//redisCommands.set(&quot;key&quot;, &quot;value&quot;);</span></span><br><span class="line"><span class="comment">//redisCommands.set(&quot;key2&quot;, &quot;value2&quot;);</span></span><br><span class="line"><span class="comment">//redisCommands.exec();</span></span><br><span class="line"><span class="type">SetArgs</span> <span class="variable">setArgs</span> <span class="operator">=</span> SetArgs.Builder.nx().ex(<span class="number">5</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> redisCommands.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;chen&quot;</span>, setArgs);</span><br><span class="line">System.out.println(result);</span><br><span class="line">result = redisCommands.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">// ... 其他操作</span></span><br><span class="line">connection.close();<span class="comment">// &lt;5&gt; 关闭连接</span></span><br><span class="line">redisClient.shutdown();<span class="comment">// &lt;6&gt; 关闭客户端</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><blockquote><p>Redisson - 是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象，Redisson、Jedis、Lettuce 是三个不同的操作 Redis 的客户端，Jedis、Lettuce 的 API 更侧重对 Reids 数据库的 CRUD（增删改查），而 Redisson API 侧重于分布式开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">redissonClient.getBucket(<span class="string">&quot;name&quot;</span>).set(<span class="string">&quot;chen&quot;</span>);</span><br><span class="line">System.out.println(redissonClient.getBucket(<span class="string">&quot;name&quot;</span>).get());</span><br></pre></td></tr></table></figure><p><strong>之后有机会好好的补充一下</strong></p></blockquote><h1 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h1><blockquote><h3 id="Redis中为什么引入Lua脚本？"><a href="#Redis中为什么引入Lua脚本？" class="headerlink" title="Redis中为什么引入Lua脚本？"></a>Redis中为什么引入Lua脚本？</h3><p>Redis是高性能的key-value<strong>内存数据库</strong>，它帮助我们解决了大部分业务问题；提供丰富的指令集合，据官网上统计有200多个命令。这些命令显然已经满足了我们的常规的业务场景需求。但是在某些特殊的场景下，业务需要<strong>原子性</strong>操作，redis原有的命令是无法完成，所以需要额外开发实现原子操作。</p><p>因为这样的问题，Redis为开发者提供了<code>lua</code>脚本的支持，用户可以向服务器发送lua脚本来执行<strong>自定义动作</strong>，以此获取脚本的响应数据。Redis本身又是<strong>单线程执行</strong>lua脚本，保证了lua脚本在处理逻辑过程中<strong>不会被任意其它请求打断</strong>。</p><h3 id="什么是Lua"><a href="#什么是Lua" class="headerlink" title="什么是Lua"></a>什么是Lua</h3><p>Lua是一种轻量<strong>小巧</strong>的<strong>脚本语言</strong>，用标准C语言编写并以源代码形式开放。</p><p>其设计目的就是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。因为广泛的应用于：游戏开发、独立应用脚本、Web 应用脚本、扩展和数据库插件等。</p><p>比如：Lua脚本用在很多游戏上，主要是Lua脚本可以嵌入到其他程序中运行，游戏升级的时候，可以直接升级脚本，而不用重新安装游戏。</p><h3 id="使用Lua脚本的好处："><a href="#使用Lua脚本的好处：" class="headerlink" title="使用Lua脚本的好处："></a>使用Lua脚本的好处：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">① 支持原子性操作 - Redis会将整个脚本作为一个整体执行，中间不会被其他请求插入。因此在脚本运行过程中无需担心会出现竞态条件，无需使用事务</span><br><span class="line"></span><br><span class="line">② 降低网络开销 - 将多个请求通过脚本的形式一次发送到服务器，减少了网络的时延</span><br><span class="line"></span><br><span class="line">③ 脚本复用    - 客户端发送的脚本可支持永久存在redis中，这样其他客户端可以复用这一脚本，而不需要使用代码完成相同的逻辑。</span><br></pre></td></tr></table></figure></blockquote><h2 id="Redis中Lua的常用命令"><a href="#Redis中Lua的常用命令" class="headerlink" title="Redis中Lua的常用命令"></a>Redis中Lua的常用命令</h2><blockquote><p>命令不多，就下面这几个：<br>- EVAL<br>- EVALSHA<br>- SCRIPT LOAD - SCRIPT EXISTS<br>- SCRIPT FLUSH<br>- SCRIPT KILL</p><h3 id="EVAL命令"><a href="#EVAL命令" class="headerlink" title="EVAL命令"></a>EVAL命令</h3><p>命令格式：<code>EVAL script numkeys key [key …] arg [arg …]</code><br>- <code>script</code>参数是一段 Lua5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数<br>- <code>numkeys</code>指定后续参数有几个key，即：key [key …]中key的个数。如没有key，则为0<br>- <code>key [key …]</code> 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)。在Lua脚本中通过KEYS[1], KEYS[2]获取。<br>- <code>arg [arg …]</code> 附加参数。在Lua脚本中通过ARGV[1],ARGV[2]获取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 例1：numkeys=1，keys数组只有1个元素key1，arg数组无元素</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;return KEYS[1]&quot; 1 key1</span><br><span class="line">&quot;key1&quot;</span><br><span class="line"></span><br><span class="line">// 例2：numkeys=0，keys数组无元素，arg数组元素中有1个元素value1</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;return ARGV[1]&quot; 0 value1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">// 例3：numkeys=2，keys数组有两个元素key1和key2，arg数组元素中有两个元素first和second </span><br><span class="line">//      其实&#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;表示的是Lua语法中“使用默认索引”的table表，</span><br><span class="line">//      相当于java中的map中存放四条数据。Key分别为：1、2、3、4，而对应的value才是：KEYS[1]、KEYS[2]、ARGV[1]、ARGV[2]</span><br><span class="line">//      举此例子仅为说明eval命令中参数的如何使用。项目中编写Lua脚本最好遵从key、arg的规范。</span><br><span class="line">127.0.0.1:6379&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second </span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 例4：使用了redis为lua内置的redis.call函数</span><br><span class="line">//      脚本内容为：先执行SET命令，在执行EXPIRE命令</span><br><span class="line">//      numkeys=1，keys数组有一个元素userAge（代表redis的key）</span><br><span class="line">//      arg数组元素中有两个元素：10（代表userAge对应的value）和60（代表redis的存活时间）</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;redis.call(&#x27;SET&#x27;, KEYS[1], ARGV[1]);redis.call(&#x27;EXPIRE&#x27;, KEYS[1], ARGV[2]); return 1;&quot; 1 userAge 10 60</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get userAge</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl userAge</span><br><span class="line">(integer) 44</span><br></pre></td></tr></table></figure><p>通过上面的例4，我们可以发现，脚本中使用redis.call()去调用redis的命令。<br>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是： <code>redis.call() 和 redis.pcall()</code><br>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，差别如下：</p><p><strong>错误处理</strong><br>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush foo a</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; eval &quot;return redis.call(&#x27;get&#x27;, &#x27;foo&#x27;)&quot; 0</span><br><span class="line">(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVAL &quot;return redis.pcall(&#x27;get&#x27;, &#x27;foo&#x27;)&quot; 0</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-LOAD命令-和-EVALSHA命令"><a href="#SCRIPT-LOAD命令-和-EVALSHA命令" class="headerlink" title="SCRIPT LOAD命令 和 EVALSHA命令"></a>SCRIPT LOAD命令 和 EVALSHA命令</h3><p>SCRIPT LOAD命令格式：<code>SCRIPT LOAD script</code><br>EVALSHA命令格式：<code>EVALSHA sha1 numkeys key [key …] arg [arg …]</code></p><p>这两个命令放在一起讲的原因是：<code>EVALSHA</code> 命令中的sha1参数，就是<code>SCRIPT LOAD</code> 命令执行的结果。</p><p><code>SCRIPT LOAD</code> 将脚本 script 添加到Redis服务器的脚本缓存中，并不立即执行这个脚本，而是会立即对输入的脚本进行求值。并返回给定脚本的 SHA1 校验和。如果给定的脚本已经在缓存里面了，那么不执行任何操作。</p><p>在脚本被加入到缓存之后，在任何客户端通过<code>EVALSHA</code>命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行<code>SCRIPT FLUSH</code>为止。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># SCRIPT LOAD加载脚本，并得到sha1值</span></span></span><br><span class="line">127.0.0.1:6379&gt; SCRIPT LOAD &quot;redis.call(&#x27;SET&#x27;, KEYS[1], ARGV[1]);redis.call(&#x27;EXPIRE&#x27;, KEYS[1], ARGV[2]); return 1;&quot;</span><br><span class="line">&quot;6aeea4b3e96171ef835a78178fceadf1a5dbe345&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># EVALSHA使用sha1值，并拼装和EVAL类似的numkeys和key数组、arg数组，调用脚本。</span></span></span><br><span class="line">127.0.0.1:6379&gt; EVALSHA 6aeea4b3e96171ef835a78178fceadf1a5dbe345 1 userAge 10 60</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get userAge</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl userAge</span><br><span class="line">(integer) 43</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-EXISTS-命令"><a href="#SCRIPT-EXISTS-命令" class="headerlink" title="SCRIPT EXISTS 命令"></a>SCRIPT EXISTS 命令</h3><p>命令格式：<code>SCRIPT EXISTS sha1 [sha1 …]</code><br>作用：给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe345</span><br><span class="line">1) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe346</span><br><span class="line">1) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe345 6aeea4b3e96171ef835a78178fceadf1a5dbe366</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 0</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-FLUSH-命令"><a href="#SCRIPT-FLUSH-命令" class="headerlink" title="SCRIPT FLUSH 命令"></a>SCRIPT FLUSH 命令</h3><p>命令格式：<code>SCRIPT FLUSH</code><br>作用：清除Redis服务端所有 Lua 脚本缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe345</span><br><span class="line">1) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT FLUSH</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SCRIPT EXISTS 6aeea4b3e96171ef835a78178fceadf1a5dbe345</span><br><span class="line">1) (integer) 0</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-KILL-命令"><a href="#SCRIPT-KILL-命令" class="headerlink" title="SCRIPT KILL 命令"></a>SCRIPT KILL 命令</h3><p>命令格式：<code>SCRIPT FLUSH</code><br>作用：杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。 这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p><p>假如当前正在运行的脚本已经执行过写操作，那么即使执行<code>SCRIPT KILL</code>，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用<code>SHUTDOWN NOSAVE</code>命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p></blockquote><h2 id="Redis执行Lua脚本文件"><a href="#Redis执行Lua脚本文件" class="headerlink" title="Redis执行Lua脚本文件"></a>Redis执行Lua脚本文件</h2><blockquote><p>在第二章中介绍的命令，是在redis客户端中使用命令进行操作。该章节介绍的是直接执行 Lua 的脚本文件。</p><h3 id="编写Lua脚本文件"><a href="#编写Lua脚本文件" class="headerlink" title="编写Lua脚本文件"></a>编写Lua脚本文件</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> val = redis.call(<span class="string">&quot;GET&quot;</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val == ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="执行Lua脚本文件"><a href="#执行Lua脚本文件" class="headerlink" title="执行Lua脚本文件"></a>执行Lua脚本文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行命令： redis-cli -a 密码 --eval Lua脚本路径 key [key …] ,  arg [arg …] </span><br><span class="line">如：redis-cli -a 123456 --eval ./Redis_CompareAndSet.lua userName , zhangsan lisi </span><br></pre></td></tr></table></figure><p><strong>此处敲黑板，注意啦！！！</strong><br>“–eval”而不是命令模式中的”eval”，一定要有前端的两个-<br>脚本路径后紧跟key [key …]，相比命令行模式，少了numkeys这个key数量值<br>key [key …] 和 arg [arg …] 之间的“ , ”，英文逗号前后必须有空格，否则死活都报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Redis客户端执行</span></span></span><br><span class="line">127.0.0.1:6379&gt; set userName zhangsan </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get userName</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># linux服务器执行</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 第一次执行：compareAndSet成功，返回1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 第二次执行：compareAndSet失败，返回0</span></span></span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_CompareAndSet.lua userName , zhangsan lisi</span><br><span class="line">(integer) 1</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_CompareAndSet.lua userName , zhangsan lisi</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></blockquote><h2 id="使用Lua控制IP访问频率"><a href="#使用Lua控制IP访问频率" class="headerlink" title="使用Lua控制IP访问频率"></a>使用Lua控制IP访问频率</h2><blockquote><p>需求：实现一个访问频率控制，某个IP在短时间内频繁访问页面，需要记录并检测出来，就可以通过Lua脚本高效的实现。<br>小声说明：本实例针对固定窗口的访问频率，而动态的非滑动窗口。即：如果规定一分钟内访问10次，记为超限。在本实例中前一分钟的最后一秒访问9次，下一分钟的第1秒又访问9次，不计为超限。<br>脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> visitNum = redis.call(<span class="string">&#x27;incr&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> visitNum == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> visitNum &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>演示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># LimitIP:127.0.0.1为key， 10 3表示：同一IP在10秒内最多访问三次</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 前三次返回1，代表未被限制；第四、五次返回0，代表127.0.0.1这个ip已被拦截</span></span></span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 1</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 1</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 1</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 0</span><br><span class="line">[root@vm01 learn_lua]# redis-cli -a 123456 --eval Redis_LimitIpVisit.lua LimitIP:127.0.0.1 , 10 3</span><br><span class="line"> (integer) 0</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面介绍一下在Java程序中如何使用Redis客户端&lt;/p&gt;
&lt;h2 id=&quot;Jedis&quot;&gt;&lt;a href=&quot;#Jedis&quot; class=&quot;headerlink&quot; title=&quot;Jedis&quot;&gt;&lt;/a&gt;Jedis&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Maven依赖&lt;/p&gt;</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://gwtt.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql行锁</title>
    <link href="https://gwtt.github.io/2022/09/22/Mysql%E8%A1%8C%E9%94%81/"/>
    <id>https://gwtt.github.io/2022/09/22/Mysql%E8%A1%8C%E9%94%81/</id>
    <published>2022-09-22T08:38:22.000Z</published>
    <updated>2022-09-22T15:26:58.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录锁-Record-Locks"><a href="#记录锁-Record-Locks" class="headerlink" title="记录锁(Record Locks)"></a><strong>记录锁(Record Locks)</strong></h2><blockquote><p>记录锁是 <strong>封锁记录，记录锁也叫行锁</strong>，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id`<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行。</p></blockquote><h2 id="间隙锁-Gap-Locks-（重点）"><a href="#间隙锁-Gap-Locks-（重点）" class="headerlink" title="间隙锁(Gap Locks)（重点）"></a><strong>间隙锁(Gap Locks)（重点）</strong></h2><p><strong>间隙锁是封锁索引记录中的间隔</strong>，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。</p><p><strong>产生间隙锁的条件（RR事务隔离级别下；）：</strong></p><ol><li>使用普通索引锁定；</li><li>使用多列唯一索引；</li><li>使用唯一索引锁定多行记录。</li></ol><p>以上情况，都会产生间隙锁：</p><blockquote><p>对于使用唯一索引来搜索并给某一行记录加锁的语句，不会产生间隙锁。（这不包括搜索条件仅包括多列唯一索引的一些列的情况；在这种情况下，会产生间隙锁。）例如，如果id列具有唯一索引，则下面的语句仅对具有id值100的行使用记录锁，并不会产生间隙锁：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>这条语句，就只会产生记录锁，不会产生间隙锁。</p><h2 id="唯一索引的间隙锁"><a href="#唯一索引的间隙锁" class="headerlink" title="唯一索引的间隙锁"></a><strong>唯一索引的间隙锁</strong></h2><p><strong>测试环境：</strong></p><p>环境：MySQL，InnoDB，默认的隔离级别（RR）</p><p>数据表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小罗&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小黄&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` <span class="keyword">VALUES</span> (<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在进行测试之前，我们先来看看test表中存在的隐藏间隙：</p><ol><li>(-infinity, 1]</li><li>(1, 5]</li><li>(5, 7]</li><li>(7, 11]</li><li>(11, +infinity]</li></ol><p><strong>只使用记录锁，不会产生间隙锁</strong></p><p>我们现在进行以下几个事务的测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小张&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>上诉的案例，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以以上的例子，只会对 id = 5 的数据加上记录锁，而不会产生间隙锁。</p><p><strong>产生间隙锁</strong></p><p>然后回滚事务测试，我们继续在 id 唯一索引列上做以下的测试：</p><p><img src="/2022/09/22/Mysql%E8%A1%8C%E9%94%81/image-20220922223922184.png" alt="image-20220922223922184"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id 在 5 - 7 范围的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">7</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;小张1&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 阻塞</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">&#x27;大东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务7插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="string">&#x27;李西&#x27;</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 事务8插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">12</span>, <span class="string">&#x27;张三&#x27;</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>从上面我们可以看到[5,7]这一个区间，都不可插入数据，其它区间，都可以正常插入数据。所以我们可以得出结论：<strong>当我们给 [5,7]这个区间加锁的时候，会锁住 [5,7]这一个区间。</strong></p><p>我们再来测试如果我们锁住不存在的数据时，会怎样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 3 这一条不存在的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;小张1&#x27;</span>); # 阻塞</span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小白&#x27;</span>); # 阻塞</span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;大罗&#x27;</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>我们可以看出，指定查询某一条记录时，如果这条记录不存在，会产生间隙锁。</p><p><strong>结论</strong></p><ol><li>对于指定查询某一条记录的加锁语句，<strong>如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁</strong>，如：WHERE <code>id</code> = 5 FOR UPDATE;</li><li>对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE <code>id</code> BETWEEN 5 AND 7 FOR UPDATE;</li></ol><h2 id="普通索引的间隙锁"><a href="#普通索引的间隙锁" class="headerlink" title="普通索引的间隙锁"></a><strong>普通索引的间隙锁</strong></h2><p><strong>数据准备</strong></p><p>创建 test1 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 注意：number 不是唯一值</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test1` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `number` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数字&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `number` (`number`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>在这张表上，我们有 id number 这两个字段，id 是我们的主键，我们在 number 上，建立了一个普通索引，为了方便我们后面的测试。现在我们要先加一些数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>在进行测试之前，我们先来看看test1表中 number 索引存在的隐藏间隙：</p><ol><li>(-infinity, 1]</li><li>(1, 3]</li><li>(3, 8]</li><li>(8, 12]</li><li>(12, +infinity]</li></ol><p><strong>案例说明</strong></p><p>我们执行以下的事务（事务1最后提交），分别执行下面的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 number = 3 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test1` <span class="keyword">WHERE</span> `number` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"><span class="comment">/* 事务2插入一条 number = 0 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">0</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 事务3插入一条 number = 1 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">1</span>); # 被阻塞</span><br><span class="line"><span class="comment">/* 事务4插入一条 number = 2 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">2</span>); # 被阻塞</span><br><span class="line"><span class="comment">/* 事务5插入一条 number = 4 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">4</span>); # 被阻塞</span><br><span class="line"><span class="comment">/* 事务6插入一条 number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">8</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 事务7插入一条 number = 9 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">9</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 事务8插入一条 number = 10 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`number`) <span class="keyword">VALUES</span> (<span class="number">10</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 提交事务1 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>我们会发现有些语句可以正常执行，有些语句被阻塞了。我们再来看看我们表中的数据：</p><p><img src="/2022/09/22/Mysql%E8%A1%8C%E9%94%81/v2-bd416a32e5f1740be516a61665ba285b_720w.jpg" alt="img">执行之后的数据</p><p>这里可以看到，number (1 - 8) 的间隙中，插入语句都被阻塞了，而不在这个范围内的语句，正常执行，这就是因为有间隙锁的原因。我们再进行以下的测试，方便我们更好的理解间隙锁的区域（我们要将数据还原成原来的那样）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 number = 3 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test1` <span class="keyword">WHERE</span> `number` <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"><span class="comment">/* 事务1插入一条 id = 2， number = 1 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>); # 阻塞</span><br><span class="line"><span class="comment">/* 事务2插入一条 id = 3， number = 2 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>); # 阻塞</span><br><span class="line"><span class="comment">/* 事务3插入一条 id = 6， number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">8</span>); # 阻塞</span><br><span class="line"><span class="comment">/* 事务4插入一条 id = 8， number = 8 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="number">8</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 事务5插入一条 id = 9， number = 9 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="number">9</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 事务6插入一条 id = 10， number = 12 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `number`) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">12</span>); # 正常执行</span><br><span class="line"><span class="comment">/* 事务7修改 id = 11， number = 12 的数据 */</span></span><br><span class="line"><span class="keyword">UPDATE</span> `test1` <span class="keyword">SET</span> `number` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">11</span> <span class="keyword">AND</span> `number` <span class="operator">=</span> <span class="number">12</span>; # 阻塞</span><br><span class="line"><span class="comment">/* 提交事务1 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="/2022/09/22/Mysql%E8%A1%8C%E9%94%81/v2-60d83dfa236fb4a25ab4c3a5df45b0d0_720w.jpg" alt="img">执行后的数据</p><p>这里有一个奇怪的现象：</p><ul><li>事务3添加 id = 6，number = 8 的数据，给阻塞了；</li><li>事务4添加 id = 8，number = 8 的数据，正常执行了。</li><li>事务7将 id = 11，number = 12 的数据修改为 id = 11， number = 5的操作，给阻塞了；</li></ul><p>这是为什么呢？我们来看看下边的图，大家就明白了。</p><p><img src="/2022/09/22/Mysql%E8%A1%8C%E9%94%81/v2-e5fe73d5f7fda8c298ce60fd35915885_720w.jpg" alt="img">隐藏的间隙锁图</p><p>从图中可以看出，当 number 相同时，会根据主键 id 来排序，所以：</p><ol><li>事务3添加的 id = 6，number = 8，根据id排序,这条数据是在 （3, 8） 的区间里边，所以会被阻塞；</li><li>事务4添加的 id = 8，number = 8，根据id排序,这条数据则是在（8, 12）区间里边，所以不会被阻塞；</li><li>事务7的修改语句相当于在 （3, 8） 的区间里边插入一条数据，所以也被阻塞了。</li></ol><p><strong>结论</strong></p><ol><li>在普通索引列上，<strong>不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；</strong></li><li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。</li></ol><h2 id="临键锁-Next-key-Locks"><a href="#临键锁-Next-key-Locks" class="headerlink" title="临键锁(Next-key Locks)"></a><strong>临键锁(Next-key Locks)</strong></h2><p><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。</p><p><strong>注：</strong>临键锁的主要目的，也是为了避免<strong>幻读</strong>(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。</p><p><strong>只使用记录锁，不会产生间隙锁</strong></p><p>我们现在进行以下几个事务的测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开启事务1 */</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">/* 查询 id = 5 的数据并加记录锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">/* 延迟30秒执行，防止锁释放 */</span></span><br><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"># 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务2插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小张&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事务3插入一条 name = &#x27;小张&#x27; 的数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">&#x27;小东&#x27;</span>); # 正常执行</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交事务1，释放事务1的锁 */</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>上诉的案例，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以以上的例子，只会对 id = 5 的数据加上记录锁，而不会产生间隙锁。</p><ol><li>记录锁、间隙锁、临键锁，都属于排它锁；</li><li>记录锁就是锁住一行记录；</li><li>间隙锁只有在事务隔离级别 RR 中才会产生；</li><li>唯一索引只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁；</li><li>普通索引不管是锁住单条，还是多条记录，都会产生间隙锁；</li><li>间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其它事务在这个区域内插入、修改、删除数据，这是为了防止出现 幻读 现象；</li><li>普通索引的间隙，优先以普通索引排序，然后再根据主键索引排序（多普通索引情况还未研究）；</li><li>事务级别是RC（读已提交）级别的话，间隙锁将会失效。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记录锁-Record-Locks&quot;&gt;&lt;a href=&quot;#记录锁-Record-Locks&quot; class=&quot;headerlink&quot; title=&quot;记录锁(Record Locks)&quot;&gt;&lt;/a&gt;&lt;strong&gt;记录锁(Record Locks)&lt;/strong&gt;&lt;/h</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>4/22美团后端实习面经一面</title>
    <link href="https://gwtt.github.io/2022/09/19/4%E6%9C%8822%E6%97%A5%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E4%B8%80%E9%9D%A2/"/>
    <id>https://gwtt.github.io/2022/09/19/4%E6%9C%8822%E6%97%A5%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E4%B8%80%E9%9D%A2/</id>
    <published>2022-09-19T15:15:22.000Z</published>
    <updated>2022-09-21T15:25:33.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h3><blockquote><p>略</p></blockquote><h3 id="2-介绍项目（基本面试官好像都喜欢挖项目）"><a href="#2-介绍项目（基本面试官好像都喜欢挖项目）" class="headerlink" title="2.介绍项目（基本面试官好像都喜欢挖项目）"></a>2.介绍项目（基本面试官好像都喜欢挖项目）</h3><blockquote><p>略，后面补充</p></blockquote><h3 id="3-项目里提到的Mysql，开始展开提问"><a href="#3-项目里提到的Mysql，开始展开提问" class="headerlink" title="3.项目里提到的Mysql，开始展开提问"></a>3.项目里提到的Mysql，开始展开提问</h3><blockquote><p>略</p></blockquote><h3 id="4-mysql的索引引擎，有什么，之间区别"><a href="#4-mysql的索引引擎，有什么，之间区别" class="headerlink" title="4.mysql的索引引擎，有什么，之间区别"></a>4.mysql的索引引擎，有什么，之间区别</h3><blockquote><p>有InnoDB,MyISAM,Memory</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB:"></a>InnoDB:</h2><ul><li>主键自增</li><li>支持外键</li><li>DML操作支持事务</li><li>支持行级锁</li></ul><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM:"></a>MyISAM:</h2><ul><li>支持表锁，不支持行锁</li><li>不支持外键</li><li>不支持事务</li><li>占用空间小，访问速度快</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory:"></a>Memory:</h2><ul><li>内存存放</li><li>支持哈希索引</li></ul></blockquote><h3 id="5-InnoDB采用什么结构存储？为什么？"><a href="#5-InnoDB采用什么结构存储？为什么？" class="headerlink" title="5.InnoDB采用什么结构存储？为什么？"></a>5.InnoDB采用什么结构存储？为什么？</h3><blockquote><p>B+树</p><ol><li>节点排序（用来加快查询速度）    </li><li>一个节点多个元素存取（B树高度不会很高）</li><li>叶子节点有指针（可以方便支持全表扫描，范围查找）</li><li>叶子节点冗余（提升范围查找的效率）</li></ol></blockquote><h3 id="6-B-树存储怎么能确定高度？"><a href="#6-B-树存储怎么能确定高度？" class="headerlink" title="6.B+树存储怎么能确定高度？"></a>6.B+树存储怎么能确定高度？</h3><blockquote><p>InnoDB最小存储单位是页，叶子节点和非叶子节点最小单位都是页，页大小Mysql 默认设定16384字节，约为16KB。我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节<br> 我们一个页中能存放多少这样的索引元素，其实就代表有多少指针，即16384/14=1170;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右</span><br></pre></td></tr></table></figure><p>高度为2的B+树能存放1170×16=18720<br>高度为3的B+树能存放1170×1170×16 = 21902400</p></blockquote><h3 id="7-最左匹配（给举个例子，说出能否用索引）"><a href="#7-最左匹配（给举个例子，说出能否用索引）" class="headerlink" title="7.最左匹配（给举个例子，说出能否用索引）"></a>7.最左匹配（给举个例子，说出能否用索引）</h3><blockquote><p>略</p></blockquote><h3 id="8-mysql中行锁具体怎么锁（当时理解错了，答得MVCC，面试官也是耐心听完了，然后问我，那行锁呢？就很尴尬）"><a href="#8-mysql中行锁具体怎么锁（当时理解错了，答得MVCC，面试官也是耐心听完了，然后问我，那行锁呢？就很尴尬）" class="headerlink" title="8.mysql中行锁具体怎么锁（当时理解错了，答得MVCC，面试官也是耐心听完了，然后问我，那行锁呢？就很尴尬）"></a>8.mysql中行锁具体怎么锁（当时理解错了，答得MVCC，面试官也是耐心听完了，然后问我，那行锁呢？就很尴尬）</h3><blockquote><p>用记录锁、间隙锁、临键锁（都是排他锁）</p><p><strong>(1)记录锁(Record):</strong> 通过主键或唯一索引加锁，锁定某行记录，锁定的是已存在的记录</p><p><strong>(2)间隙锁(Gap):</strong> 锁定的是索引记录中的间隔，锁定的是未存在记录的区间。</p><p><strong>(3)临键锁(Next-key):</strong> 既包含已存在的记录，又包含未存在记录的区间（记录锁+间隙锁）</p><p><strong>锁的触发条件</strong></p><p>1.记录锁(Record)触发条件: 查询的条件中只包含表中存在的记录</p><p>2.间隙锁(Gap)触发条件: 查询的条件中不包含表中任何记录</p><p>3.临键锁(Next-key)触发条件: 查询的条件中既包含表中存在的记录，也包含表中不存在的记录</p></blockquote><h3 id="9-redis在应用时怎么保证数据一致性的（问的是项目里用的时候）"><a href="#9-redis在应用时怎么保证数据一致性的（问的是项目里用的时候）" class="headerlink" title="9.redis在应用时怎么保证数据一致性的（问的是项目里用的时候）"></a>9.redis在应用时怎么保证数据一致性的（问的是项目里用的时候）</h3><blockquote><h4 id="采用延时双删策略"><a href="#采用延时双删策略" class="headerlink" title="采用延时双删策略"></a>采用延时双删策略</h4><p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存</p><h3 id="先更新数据库，再删除缓存（推荐）"><a href="#先更新数据库，再删除缓存（推荐）" class="headerlink" title="先更新数据库，再删除缓存（推荐）"></a>先更新数据库，再删除缓存（推荐）</h3></blockquote><h3 id="10-有没有想过用本地缓存，不用redis（当时不了解memcache，随便说了个更新频繁）"><a href="#10-有没有想过用本地缓存，不用redis（当时不了解memcache，随便说了个更新频繁）" class="headerlink" title="10.有没有想过用本地缓存，不用redis（当时不了解memcache，随便说了个更新频繁）"></a>10.有没有想过用本地缓存，不用redis（当时不了解memcache，随便说了个更新频繁）</h3><blockquote><ol><li>使用ConcurrentHashMap实现本地缓存<br>缓存的本质就是存储在内存中的KV数据结构，对应的就是jdk中线程安全的ConcurrentHashMap，但是要实现缓存，还需要考虑淘汰、最大限制、缓存过期时间淘汰等等功能；</li></ol><p>优点是实现简单，不需要引入第三方包，比较适合一些简单的业务场景。缺点是如果需要更多的特性，需要定制化开发，成本会比较高，并且稳定性和可靠性也难以保障。对于比较复杂的场景，建议使用比较稳定的开源工具。</p><ol start="2"><li>基于Guava Cache实现本地缓存<br>Guava是Google团队开源的一款 Java 核心增强库，包含集合、并发原语、缓存、IO、反射等工具箱，性能和稳定性上都有保障，应用十分广泛。Guava Cache支持很多特性：</li></ol><p>支持最大容量限制<br>支持两种过期删除策略（插入时间和访问时间）<br>支持简单的统计功能<br>基于LRU算法实现</p></blockquote><h3 id="11-接10问，redis一般存哪种数据结构（存的list，所以本地缓存用不了）"><a href="#11-接10问，redis一般存哪种数据结构（存的list，所以本地缓存用不了）" class="headerlink" title="11.接10问，redis一般存哪种数据结构（存的list，所以本地缓存用不了）"></a>11.接10问，redis一般存哪种数据结构（存的list，所以本地缓存用不了）</h3><blockquote><p>存String</p></blockquote><h3 id="12-想没想过redis宕机怎么办？"><a href="#12-想没想过redis宕机怎么办？" class="headerlink" title="12.想没想过redis宕机怎么办？"></a>12.想没想过redis宕机怎么办？</h3><blockquote><p>如果是一台机器，利用AOF和RDB机制进行redis数据恢复</p><p>从机宕机:</p><ul><li>只要把从的redis重新启动，再和主的进行连接就可以</li><li>如果从redis上面做数据的持久化，可以直接连接到主的上面，只要实现增量备份。</li></ul><p>主机宕机:</p><ul><li>先把从的redis升级为主的redis. 执行slave of one命令<br>原来的主的可以重新启动，作为从的redis, 连接到主的redis上面做主从复制。<br>可以使用Redis 提供哨兵 机制来简化上面的操作。</li></ul></blockquote><h3 id="13-了不了解垃圾回收器，说一下CMS的过程？"><a href="#13-了不了解垃圾回收器，说一下CMS的过程？" class="headerlink" title="13.了不了解垃圾回收器，说一下CMS的过程？"></a>13.了不了解垃圾回收器，说一下CMS的过程？</h3><blockquote><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul></blockquote><h3 id="14-FullGC发生的条件？（面试官说应该有三种，只说上两种）"><a href="#14-FullGC发生的条件？（面试官说应该有三种，只说上两种）" class="headerlink" title="14.FullGC发生的条件？（面试官说应该有三种，只说上两种）"></a>14.FullGC发生的条件？（面试官说应该有三种，只说上两种）</h3><blockquote><ol><li>年老代（Tenured）被写满；</li><li>持久代（Perm）被写满；</li><li>System.gc()被显示调用；</li><li>上一次GC之后Heap的各域分配策略动态变化；</li></ol></blockquote><h3 id="15-了解线程池吗？主要参数？"><a href="#15-了解线程池吗？主要参数？" class="headerlink" title="15.了解线程池吗？主要参数？"></a>15.了解线程池吗？主要参数？</h3><blockquote><p>了解</p><p>corePoolSize核心线程数</p><p>maximumPoolSize最大线程数</p><p>keepAliveTime线程空闲时间</p><p>unit时间单位</p><p>workQueue阻塞队列</p><p>threadFactory线程工厂</p><p>handler任务拒绝处理器</p></blockquote><h3 id="16-线程池的执行过程？"><a href="#16-线程池的执行过程？" class="headerlink" title="16.线程池的执行过程？"></a>16.线程池的执行过程？</h3><blockquote><p>当我们利用线程池执行任务时:</p><p>1.如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</p><p>⒉.如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</p><p>3.如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</p><p>4.如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。</p><p>5.当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</p></blockquote><h3 id="17-可重入锁是怎么实现的？"><a href="#17-可重入锁是怎么实现的？" class="headerlink" title="17.可重入锁是怎么实现的？"></a>17.可重入锁是怎么实现的？</h3><blockquote><p>利用AQS实现(AbstractQueueSynchronize)抽象队列同步器</p></blockquote><h3 id="18-由于17问说不知道，提醒出了18问AQS知道吗？（答完之后，面试官说这就是可重入锁实现）"><a href="#18-由于17问说不知道，提醒出了18问AQS知道吗？（答完之后，面试官说这就是可重入锁实现）" class="headerlink" title="18.由于17问说不知道，提醒出了18问AQS知道吗？（答完之后，面试官说这就是可重入锁实现）"></a>18.由于17问说不知道，提醒出了18问AQS知道吗？（答完之后，面试官说这就是可重入锁实现）</h3><blockquote><p>AQS 中有两个重要的东西，一个以Node为节点实现的链表的队列(CHL队列)，还有一个STATE标志，并且通过CAS来改变它的值。</p><p>CLH队列：</p><p>链表结构，在头尾结点中，需要特别指出的是头结点是一个空对象结点，无任何意义，即傀儡结点；</p><p>每一个Node结点都维护了一个指向前驱的指针和指向后驱的指针，结点与结点之间相互关联构成链表；</p><p>入队在尾，出队在头，出队后需要激活该出队结点的后继结点，若后继结点为空或后继结点waitStatus&gt;0，则从队尾向前遍历取waitStatus&lt;0的触发阻塞唤醒；</p><p>队列中节点状态值（waitStatus，只能为以下值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量：表示节点的线程是已被取消的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"><span class="comment">//常量：表示当前节点的后继节点的线程需要被唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//常量：表示线程正在等待某个条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//常量：表示下一个共享模式的节点应该无条件的传播下去</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br></pre></td></tr></table></figure></blockquote><h3 id="19-CAS是什么"><a href="#19-CAS是什么" class="headerlink" title="19.CAS是什么"></a>19.CAS是什么</h3><blockquote><p>CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。</p><p>CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p><p>ps:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题:</span><br><span class="line">①.CAS容易造成ABA问题。一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。</span><br><span class="line">②.CAS造成CPU利用率增加。之前说过了CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。</span><br></pre></td></tr></table></figure></blockquote><h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><h3 id="20-打算实习时间"><a href="#20-打算实习时间" class="headerlink" title="20.打算实习时间"></a>20.打算实习时间</h3><blockquote><p>大约寒假就可以开始</p></blockquote><p>转载<a href="https://blog.nowcoder.net/n/18665b426d354fba9064db4f2af43863">美团Java后端实习面经（一二面），已接offer~_牛客博客 (nowcoder.net)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-自我介绍&quot;&gt;&lt;a href=&quot;#1-自我介绍&quot; class=&quot;headerlink&quot; title=&quot;1.自我介绍&quot;&gt;&lt;/a&gt;1.自我介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-介绍项目（基本面试官好</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程和操作系统的线程有啥区别</title>
    <link href="https://gwtt.github.io/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/"/>
    <id>https://gwtt.github.io/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/</id>
    <published>2022-09-17T09:38:23.000Z</published>
    <updated>2022-09-19T15:04:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用户空间和内核空间"><a href="#1-用户空间和内核空间" class="headerlink" title="1. 用户空间和内核空间"></a><strong>1. 用户空间和内核空间</strong></h2><blockquote><p>至于什么是系统空间和用户空间也非常好理解：在操作系统中，内存通常会被分成用户空间（User space）与内核空间（Kernel space）这两个部分。当进程/线程运行在用户空间时就处于用户态，运行在内核空间时就处于内核态：</p><ul><li>运行在内核态的程序可以访问用户空间和内核空间，或者说它可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等</li><li>而应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问用户空间</li></ul><p><strong>那为什么要区分用户态和内核态呢</strong>？</p><p>其实早期操作系统是不区分用户态和内核态的，也就是说应用程序可以访问任意内存空间，如果程序不稳定常常会让系统崩溃，比如清除了操作系统的内存数据。为此大佬们设计出了一套规则：对于那些比较危险的操作需要切到内核态才能运行，比如 CPU、内存、设备等资源管理器程序就应该在内核态运行，否则安全性没有保证。</p><p>举个例子，对于文件系统和数据来说，文件系统数据和管理就必须放在内核态，但是用户的数据和管理可以放在用户态。</p><p><strong>用户态的程序不能随意操作内核地址空间，这样有效地防止了操作系统程序受到应用程序的侵害</strong>。</p><p>那如果处于用户态的程序想要访问内核空间的话怎么办呢？就需要进行系统调用从用户态切换到内核态。</p></blockquote><h2 id="2-操作系统线程"><a href="#2-操作系统线程" class="headerlink" title="2. 操作系统线程"></a><strong>2. 操作系统线程</strong></h2><h3 id="①-在用户空间中实现线程"><a href="#①-在用户空间中实现线程" class="headerlink" title="① 在用户空间中实现线程"></a><strong>① 在用户空间中实现线程</strong></h3><p>在<strong>早期</strong>的操作系统中，所有的线程都是在用户空间下实现的，操作系统只能看到线程所属的进程，而不能看到线程。</p><p><img src="/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/1620.png" alt="img"></p><p>从我们开发者的角度来理解用户级线程就是说：在这种模型下，我们需要自己定义线程的数据结构、创建、销毁、调度和维护等，这些线程运行在操作系统的某个进程内，然后操作系统直接对进程进行调度。</p><p>这种方式的好处一目了然，首先第一点，就是即使操作系统原生不支持线程，我们也可以通过库函数来支持线程；第二点，线程的调度只发生在用户态，避免了操作系统从内核态到用户态的转换开销。</p><p>当然缺点也很明显：由于操作系统看不见线程，不知道线程的存在，而 CPU 的时间片切换是以进程为维度的，所以如果进程中某个线程进行了耗时比较长的操作，那么由于用户空间中没有时钟中断机制，就会导致此进程中的其它线程因为得不到 CPU 资源而长时间的持续等待；另外，如果某个线程进行系统调用时比如缺页中断而导致了线程阻塞，此时操作系统也会阻塞住整个进程，即使这个进程中其它线程还在工作。</p><h3 id="②-在内核空间中实现线程"><a href="#②-在内核空间中实现线程" class="headerlink" title="② 在内核空间中实现线程"></a><strong>② 在内核空间中实现线程</strong></h3><blockquote><p>所谓内核级线程就是运行在内核空间的线程， 直接由内核负责，只能由内核来完成线程的调度。</p><p>几乎所有的<strong>现代</strong>操作系统，包括 Windows、Linux、Mac OS X 和 Solaris 等，都支持内核线程。</p><p>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，<strong>支持多线程的内核就叫做多线程内核</strong>（Multi-Threads Kernel）。</p><p>从我们开发者的角度来理解内核级线程就是说：我们可以直接使用操作系统中已经内置好的线程，线程的创建、销毁、调度和维护等，都是直接由操作系统的内核来实现，我们只需要使用系统调用就好了，不需要像用户级线程那样自己设计线程调度等。</p></blockquote><p><img src="/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/1620-1663408134188-3.png" alt="img"></p><p>上图画的是 1：1 的线程模型，所谓线程模型，也就是用户线程和内核线程之间的关联方式，线程模型当然不止 1：1 这一种，下面我们来详细解释以下这三种多线程模型：</p><p>1）<strong>多对一线程模型</strong>：</p><p><img src="/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/1620-1663408160035-6.png" alt="img"></p><ul><li>在多对一模型中，多个用户级线程映射到某一个内核线程上</li><li>线程管理由用户空间中的线程库处理，这非常有效</li><li>但是，如果进行了阻塞系统调用，那么即使其他用户线程能够继续，整个进程也会阻塞</li><li>由于单个内核线程只能在单个 CPU 上运行，因此多对一模型不允许在多个 CPU 之间拆分单个进程</li></ul><p>从并发性角度来总结下，虽然多对一模型允许开发人员创建任意多的用户线程，但是由于内核只能一次调度一个线程，所以并未增加并发性。现在已经几乎没有操作系统来使用这个模型了，因为它无法利用多个处理核。</p><p>2）<strong>一对一线程模型</strong>：</p><p><img src="/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/1620-1663408160035-7.png" alt="img"></p><ul><li>一对一模型克服了多对一模型的问题</li><li>一对一模型创建一个单独的内核线程来处理每个用户线程</li><li>但是，管理一对一模型的开销更大，涉及更多开销和减慢系统速度</li><li>此模型的大多数实现都限制了可以创建的线程数</li></ul><p>从并发性角度来总结下，虽然一对一模型提供了更大的并发性，但是开发人员应注意不要在应用程序内创建太多线程（有时系统可能会限制创建线程的数量），因为管理一对一模型的开销更大。<strong>Windows (从 Win95 开始) 和 Linux 都实现了线程的一对一模型</strong>。</p><p>3）<strong>多对多线程模型</strong>：</p><p>![img](Java 线程和操作系统的线程有啥区别/1620-1663408160035-8.png)</p><ul><li>多对多模型将任意数量的用户线程复用到相同或更少数量的内核线程上，结合了一对一和多对一模型的最佳特性</li><li>用户对创建的线程数没有限制</li><li>阻止内核系统调用不会阻止整个进程</li><li>进程可以分布在多个处理器上</li><li>可以为各个进程分配可变数量的内核线程，具体取决于存在的 CPU 数量和其他因素</li></ul><h2 id="3-Java-线程"><a href="#3-Java-线程" class="headerlink" title="3. Java 线程"></a><strong>3. Java 线程</strong></h2><blockquote><p>在进入 Java 线程主题之前，有必要讲解一下<strong>线程库</strong> Thread library 的概念。</p><p>在上面的模型介绍中，我们提到了通过线程库来创建、管理线程，那么什么是线程库呢？</p><p><strong>线程库就是为开发人员提供创建和管理线程的一套 API</strong>。</p><p>当然，线程库不仅可以在用户空间中实现，还可以在内核空间中实现。前者涉及仅在用户空间内实现的 API 函数，没有内核支持。后者涉及系统调用，也就是说调用库中的一个 API 函数将会导致对内核的系统调用，并且需要具有线程库支持的内核。</p><p>下面简单介绍下三个主要的线程库：</p><p>1）POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展</p><p>2）Win32 线程：用于 Window 操作系统的内核级线程库</p><p>3）Java 线程：<strong>Java 线程 API 通常采用宿主系统的线程库来实现</strong>，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。</p><p>下面我们来详细讲解 Java 线程：</p><p>事实上，<strong>在 JDK 1.2 之前</strong>，Java 线程是基于称为 “绿色线程”（Green Threads）的用户级线程实现的，也就是说程序员大佬们为 JVM 开发了自己的一套线程库或者说线程管理机制。</p><p>而<strong>在 JDK 1.2 及以后</strong>，JVM 选择了更加稳定且方便使用的操作系统原生的内核级线程，通过系统调用，将线程的调度交给了操作系统内核。而对于不同的操作系统来说，它们本身的设计思路基本上是完全不一样的，因此它们各自对于线程的设计也存在种种差异，所以 JVM 中明确声明了：<strong>虚拟机中的线程状态，不反应任何操作系统中的线程状态</strong>。</p><p>也就是说，在 JDK 1.2 及之后的版本中，Java 的线程很大程度上依赖于操作系统采用什么样的线程模型，这点在不同的平台上没有办法达成一致，JVM 规范中也并未限定 Java 线程需要使用哪种线程模型来实现，可能是一对一，也可能是多对多或多对一。</p><p>总结来说，回答下文题，<strong>现今 Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，比如在 Windows 中 Java 就是基于 Wind32 线程库来管理线程，且 Windows 采用的是一对一的线程模型</strong>。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-java线程是操作系统的线程吗，调度也是依据操作系统调度吗"><a href="#1-java线程是操作系统的线程吗，调度也是依据操作系统调度吗" class="headerlink" title="1.java线程是操作系统的线程吗，调度也是依据操作系统调度吗"></a>1.java线程是操作系统的线程吗，调度也是依据操作系统调度吗</h3><blockquote><p>现今 Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现</p></blockquote><p>[转载]Java 线程和操作系统的线程有啥区别？ - 腾讯云开发者社区-腾讯云 (tencent.com)](<a href="https://cloud.tencent.com/developer/article/1818151">https://cloud.tencent.com/developer/article/1818151</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-用户空间和内核空间&quot;&gt;&lt;a href=&quot;#1-用户空间和内核空间&quot; class=&quot;headerlink&quot; title=&quot;1. 用户空间和内核空间&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 用户空间和内核空间&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;至于</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈CMS和G1收集器</title>
    <link href="https://gwtt.github.io/2022/09/16/%E6%B5%85%E8%B0%88CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://gwtt.github.io/2022/09/16/%E6%B5%85%E8%B0%88CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-09-16T12:38:23.000Z</published>
    <updated>2022-09-17T09:29:09.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><h3 id="1-什么是CMS收集器"><a href="#1-什么是CMS收集器" class="headerlink" title="1.什么是CMS收集器"></a>1.什么是CMS收集器</h3><blockquote><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>从名字（包含 “Mark Sweep”）上就可以看出，CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤,包括:</p><ul><li>初始标记(CMS initial mark)</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)</li><li>并发清除(CMS concurrent sweep)</li></ul><p>其中，初始标记、重新标记这两个步骤需要“Stop the World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>CMS是一款优秀的收集器，它的主要优点在名字上就已经体现出来了: 并发收集、低停顿，Sum公司文档也会称为Concurrent Low Pause Collector(并发低停顿收集器)</p></blockquote><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.<strong>优点</strong></h3><blockquote><ul><li>并发收集</li><li>低停顿</li></ul></blockquote><h3 id="3-CMS收集器缺点"><a href="#3-CMS收集器缺点" class="headerlink" title="3.CMS收集器缺点"></a>3.CMS收集器<strong>缺点</strong></h3><blockquote><ul><li>CMS收集器对CPU资源非常敏感。</li></ul><blockquote><p>在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p></blockquote><ul><li>CMS收集器无法处理浮动垃圾（Floating Garbage)。</li></ul><blockquote><p>可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行者，伴随程序运行自然有不断的垃圾不断的产生，这些垃圾只能留在下一次GC才能清理掉。</p></blockquote><ul><li>CMS收集器是基于标记-清除算法，该算法的缺点都有。</li></ul><blockquote><p>收集结束时会有大量空间碎片。</p><p>标记和清除两个过程的效率都不高。</p></blockquote></blockquote><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><h3 id="1-什么是G1收集器"><a href="#1-什么是G1收集器" class="headerlink" title="1.什么是G1收集器"></a>1.什么是G1收集器</h3><blockquote><p>G1(Garbage-First)收集器是当今收集器技术发展的最前沿成果之一，早在JDK1.7刚刚确立项目目标，Sum公司给出的JDK1.7 RoadMap里面，它就被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。从JDK 6u14中开始就有Early Access版本的G1收集器共开发人员实验和试用，由此开始G1收集器的“Experimental”状态持续了数年时间，直至JDK7u4，Sum公司才认为它达到足够成熟的商用程度，移除了“Experimental“的标识。</p><p><strong>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</strong></p></blockquote><h3 id="2-优点-1"><a href="#2-优点-1" class="headerlink" title="2.优点"></a>2.优点</h3><blockquote><ul><li>并发与并行</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</span><br></pre></td></tr></table></figure><ul><li>分代收集</li><li>空间整合</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与CMS的标记-清除算法不同，G1从整体来看是基于标记-整理算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</span><br></pre></td></tr></table></figure><ul><li>可预测的停顿</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。</span><br></pre></td></tr></table></figure><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p><p><img src="/2022/09/16/%E6%B5%85%E8%B0%88CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/16ded186e15f5871tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="G1堆的Region布局.png"></p><p>G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。Region的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的Region，这一点可以参看如下<a href="https://link.juejin.cn/?target=http://hg.openjdk.java.net/jdk/jdk/file/fa2f93f99dbc/src/hotspot/share/gc/g1/heapRegionBounds.hpp">源码</a>。其实这个数字既可以手动调整，G1也会根据堆大小自动进行调整。</p><p><strong>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</p><p>对于打算从CMS或者ParallelOld收集器迁移过来的应用，按照官方的建议，如果发现符合如下特征，可以考虑更换成G1收集器以追求更佳性能：</p><ul><li>实时数据占用了超过半数的堆空间；</li><li>对象分配率或“晋升”的速度变化明显；</li><li>期望消除耗时较长的GC或停顿（超过0.5——1秒）。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Applications running today with either the CMS or the ParallelOld garbage collector would benefit switching to G1 if the application has one or more of the following traits.</span><br><span class="line"></span><br><span class="line">More than 50% of the Java heap is occupied with live data.</span><br><span class="line">The rate of object allocation rate or promotion varies significantly.</span><br><span class="line">Undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-运行过程"><a href="#3-运行过程" class="headerlink" title="3.运行过程"></a>3.运行过程</h3><blockquote><p><strong>G1收集的运作过程大致如下：</strong></p><ul><li><strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，<strong>这阶段需要<code>停顿线程</code>，但耗时很短</strong>。</li><li><strong>并发标记（Concurrent Marking）</strong>：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，<strong>这阶段耗时较长</strong>，但可与用户程序并发执行。</li><li><strong>最终标记（Final Marking）</strong>：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，<strong>这阶段需要<code>停顿线程</code>，但是可并行执行</strong>。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong>：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ul><p>全局变量和栈中引用的对象是可以列入根集合的，这样在寻找垃圾时，就可以从根集合出发扫描堆空间。在G1中，引入了一种新的能加入根集合的类型，就是<code>记忆集</code>（Remembered Set）。Remembered Sets（也叫RSets）用来跟踪对象引用。G1的很多开源都是源自Remembered Set，例如，它通常约占Heap大小的20%或更高。并且，我们进行对象复制的时候，因为需要扫描和更改Card Table的信息，这个速度影响了复制的速度，进而影响暂停时间。</p><p><img src="/2022/09/16/%E6%B5%85%E8%B0%88CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/16ded186e1757662tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="image.png"></p></blockquote><h2 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h2><blockquote><h3 id="卡表（Card-Table）"><a href="#卡表（Card-Table）" class="headerlink" title="卡表（Card Table）"></a>卡表（Card Table）</h3><p>有个场景，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为GC Roots。那不是得又做全堆扫描？成本太高了吧。</p><p>HotSpot给出的解决方案是一项叫做<code>卡表</code>（Card Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。</p><p>在进行Minor GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。</p><p>想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。</p><p><strong>卡表能用于减少老年代的全堆空间扫描，这能很大的提升GC效率</strong>。</p></blockquote><h2 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h2><blockquote><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的数据结构。</p><p>如果我们不考虑效率和成本问题，我们可以用一个数组存储所有有指针指向新生代的老年代对象。但是如果这样的话我们维护成本就很好，打个比方，假如所有的老年代对象都有指针指向了新生代，那么我们需要维护整个老年代大小的记忆集，毫无疑问这种方法是不可取的。因此我们引入了卡表的数据结构</p></blockquote><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><blockquote><p>我们每次对引用进行改变时，我们在程序中并没有手动去维护卡表的信息，那么卡表信息的维护到底是如何进行的呢，这就依赖于我们的写屏障功能。</p><p>写屏障可以理解为对于我们引用类型字段复制的AOP操作。在赋前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的部分的写屏障叫作写后屏障（PostWrite Barrier）。</p></blockquote><h2 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h2><blockquote><p>由于CPU集成的多级缓存中是以缓存行来读取数据的，通过MESI协议保证多个CPU之间的缓存一致性。<br>伪共享问题是卡表元素更改时处于同一缓存行导致的，诱发的因素是不同卡页内的对象发生了跨代引用，从而使CPU并行执行变为串行执行，降低了并发性能。</p><p>举例： 若a、b位于同一缓存行，当CPU1修改a后，若CPU2想修改b，必须先提交CPU1的缓存，然后CPU2再去主存中读取数据。</p><p>伪共享问题解决方案：JAVA中的解决方案有填充法 和 Contended 注解。</p><p>填充法：就是 扩大对象的大小，这样，就可以一个缓冲行中，<strong>只存在一个对象</strong>！这样，就不会导致结果是串行执行了！(JDK8之前)<br>Contended 注解法：Java1.8 中提供了Contended注解，使用这个注解，VM必须设置 -XX:-RestrictContended。<br>ConcurrentHashMap的内部类CounterCell有用到这个注解</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CMS收集器&quot;&gt;&lt;a href=&quot;#CMS收集器&quot; class=&quot;headerlink&quot; title=&quot;CMS收集器&quot;&gt;&lt;/a&gt;CMS收集器&lt;/h2&gt;&lt;h3 id=&quot;1-什么是CMS收集器&quot;&gt;&lt;a href=&quot;#1-什么是CMS收集器&quot; class=&quot;header</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>9/16华为技术面</title>
    <link href="https://gwtt.github.io/2022/09/16/9%E6%9C%8816%E6%97%A5%E5%8D%8E%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%9D%A2/"/>
    <id>https://gwtt.github.io/2022/09/16/9%E6%9C%8816%E6%97%A5%E5%8D%8E%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%9D%A2/</id>
    <published>2022-09-16T02:45:22.000Z</published>
    <updated>2022-09-19T15:01:10.424Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java的跨平台的机制是什么？"><a href="#1-Java的跨平台的机制是什么？" class="headerlink" title="1. Java的跨平台的机制是什么？"></a>1. Java的跨平台的机制是什么？</h3><blockquote><p><em>java语言编写的程序,一次编译后,可以在多个系统平台上运行</em></p><p>Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序</p></blockquote><h3 id="2-JVM-内存是怎么管理的？"><a href="#2-JVM-内存是怎么管理的？" class="headerlink" title="2. JVM  内存是怎么管理的？"></a>2. JVM  内存是怎么管理的？</h3><blockquote><p>堆，方法区，程序计数器，虚拟机栈，本地方法栈</p></blockquote><h3 id="3-GC-一般在什么时候触发？"><a href="#3-GC-一般在什么时候触发？" class="headerlink" title="3.GC  一般在什么时候触发？"></a>3.GC  一般在什么时候触发？</h3><blockquote><ul><li>Young GC 一般是在新生代的 Eden 区满了之后触发的</li><li>Full GC<ol><li>年老代（Tenured）被写满；</li><li>持久代（Perm）被写满；</li><li>System.gc()被显示调用；</li><li>上一次GC之后Heap的各域分配策略动态变化；</li></ol></li></ul></blockquote><h3 id="4-调用GC（System-gc-）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？"><a href="#4-调用GC（System-gc-）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？" class="headerlink" title="4. 调用GC（System.gc()）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？"></a>4. 调用GC（System.gc()）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？</h3><p> 如果不是，是什么机制来保障的（finalize）</p><blockquote><p>不会立马触发。甚至可能不会垃圾回收。</p><p>造成系统卡顿</p><p>用justRanFinalization来保障System.gc()执不执行</p></blockquote><h3 id="5-Java-有了-GC-之后还会有内存泄漏问题吗？"><a href="#5-Java-有了-GC-之后还会有内存泄漏问题吗？" class="headerlink" title="5. Java  有了  GC  之后还会有内存泄漏问题吗？"></a>5. Java  有了  GC  之后还会有内存泄漏问题吗？</h3><blockquote><ol><li><p>静态集合类泄漏<br>静态集合类像HashMap，Vector等的使用最容易出现内存泄漏，静态变量的声明周期与应用程序一直，所有的对象Object也不能内释放，因为被其他对象引用着。</p></li><li><p>单例造成的泄漏</p><p>单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</p></li><li><p>各种连接<br>数据库连接，网络连接，IO连接等没有显式调用close()关闭，会导致内存泄漏。</p></li><li><p>监听器的使用<br>在释放对象的同时，没有删除相应监听器，也会造成内存泄漏。</p></li></ol></blockquote><h3 id="6-哪些可以作为-GC-Roots-？"><a href="#6-哪些可以作为-GC-Roots-？" class="headerlink" title="6. 哪些可以作为  GC Roots  ？"></a>6. 哪些可以作为  GC Roots  ？</h3><blockquote><ol><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol></blockquote><h3 id="7-String-类型不可修改，为什么呢？字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？非要改String类型的值，能改的到吗？new一个String对象，是放在哪里的？StringBuilder和StringBuffer有什么区别？"><a href="#7-String-类型不可修改，为什么呢？字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？非要改String类型的值，能改的到吗？new一个String对象，是放在哪里的？StringBuilder和StringBuffer有什么区别？" class="headerlink" title="7. String  类型不可修改，为什么呢？字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？非要改String类型的值，能改的到吗？new一个String对象，是放在哪里的？StringBuilder和StringBuffer有什么区别？"></a>7. String  类型不可修改，为什么呢？字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？非要改String类型的值，能改的到吗？new一个String对象，是放在哪里的？StringBuilder和StringBuffer有什么区别？</h3><blockquote><p>String不可变是因为字符数组被final和private修饰。并且String没有提供可以修改字符数组的API</p><p>new一个对象时指向堆里面的，字符串常量时指向方法区里的字符串常量池</p><p>反射可以修改（不是声明底层字段会失败）</p><p>放在堆里（Heap）</p><p>一个线程不安全一个线程安全</p></blockquote><h3 id="8-反射机制有了解吗？反射创建对象和new创建对象有什么区别？反射和new的性能哪个更高一点？"><a href="#8-反射机制有了解吗？反射创建对象和new创建对象有什么区别？反射和new的性能哪个更高一点？" class="headerlink" title="8.  反射机制有了解吗？反射创建对象和new创建对象有什么区别？反射和new的性能哪个更高一点？"></a>8.  反射机制有了解吗？反射创建对象和new创建对象有什么区别？反射和new的性能哪个更高一点？</h3><blockquote><p>有</p><p>new属于静态编译<br>反射属于动态编译，意思就说只有到运行时才会去获得该对象的实例,Spring就是使用的反射</p><p>new性能更高</p></blockquote><h3 id="9-多线程了解吗？通过什么类来实现？"><a href="#9-多线程了解吗？通过什么类来实现？" class="headerlink" title="9. 多线程了解吗？通过什么类来实现？"></a>9. 多线程了解吗？通过什么类来实现？</h3><blockquote><p>了解</p><p>主要通过Thread类</p></blockquote><h3 id="10-设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）"><a href="#10-设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）" class="headerlink" title="10. 设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）"></a>10. 设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便<a href>管理类</a>、分工开发）</h3><blockquote><p>​    了解</p><ul><li>方便重用，方便移植</li><li>方便阅读，方便他人了解</li><li>代码可靠性更高，降低错误发生</li><li>节省写项目的时间</li></ul></blockquote><h3 id="11-Redis-和大型数据库有什么区别？为什么要用这个数据库（Redis）"><a href="#11-Redis-和大型数据库有什么区别？为什么要用这个数据库（Redis）" class="headerlink" title="11.Redis  和大型数据库有什么区别？为什么要用这个数据库（Redis）"></a>11.Redis  和大型数据库有什么区别？为什么要用这个<a href>数据</a>库（Redis）</h3><blockquote><ul><li>Redis是非关系型数据库，Mysql是关系型数据库</li><li>Mysql持久化到硬盘中，读取较慢，Redis数据存储到内存中，读取速度快</li></ul><p>为什么要用:</p><p>反复连接数据库需要花费很多时间，从而导致<strong>运行效率过慢</strong>，反复连接也会导致<strong>数据库负载变高</strong>。由于Redis是基于内存操作，所以<code>CPU不是性能瓶颈</code>，机器的<code>内存和宽带才是Redis的瓶颈</code>，所以用Redis可以减少访问数据库的次数，提高运行效率。</p></blockquote><h3 id="12-编码的时候，会做网络字节序转换，大小端转换，为什么要做这个转换呢？-（不会）"><a href="#12-编码的时候，会做网络字节序转换，大小端转换，为什么要做这个转换呢？-（不会）" class="headerlink" title="12. 编码的时候，会做网络字节序转换，大小端转换，为什么要做这个转换呢？   （不会）"></a>12. 编码的时候，会做网络字节序转换，大小端转换，为什么要做这个转换呢？   （不会）</h3><blockquote><p> 因为不同的计算机都有自己的主机字节序，为了保证数据传输的统一性，就是让数据在所有计算机上都以一种通用形式呈现，所以会作网络字节序转换。</p><p>TCP/IP协议规定使用“大端”字节序作为网络字节序。</p></blockquote><h3 id="13-ICMP-协议，有了解吗？"><a href="#13-ICMP-协议，有了解吗？" class="headerlink" title="13.  ICMP  协议，有了解吗？"></a>13.  ICMP  协议，有了解吗？</h3><blockquote><p>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><p>它的功能是报告无法传送的数据包的错误，并帮助对这些错误进行疑难解答。</p><p>典型应用:PING,traceroute（检查路由（路径）并测量跨Internet协议（IP）网络的传输延迟数据包的工具）</p></blockquote><h3 id="14-HTTP-和-HTTPS-的区别是什么？"><a href="#14-HTTP-和-HTTPS-的区别是什么？" class="headerlink" title="14. HTTP  和  HTTPS  的区别是什么？"></a>14. HTTP  和  HTTPS  的区别是什么？</h3><blockquote><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></blockquote><h3 id="15-数字证书使用了什么机制？数字证书为什么被创建？"><a href="#15-数字证书使用了什么机制？数字证书为什么被创建？" class="headerlink" title="15. 数字证书使用了什么机制？数字证书为什么被创建？"></a>15. 数字证书使用了什么机制？数字证书为什么被创建？</h3><blockquote><p>数字证书采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。用于加密和验证签名。当发送一份保密文件时，发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密，这样信息就可以安全无误地到达目的地了。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。</p><p>为了防止信息泄露，所以必须保证网络安全的四大要素:</p><ul><li>信息传输的保密性</li><li>数据交换的完整性</li><li>发送信息的不可否认性</li><li>交易者身份的确定性</li></ul><p>所以创建数字证书</p></blockquote><p>摘自华为面经-Java-西安_笔经面经_牛客网(<a href="https://www.nowcoder.com/discuss/1053917">https://www.nowcoder.com/discuss/1053917</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Java的跨平台的机制是什么？&quot;&gt;&lt;a href=&quot;#1-Java的跨平台的机制是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Java的跨平台的机制是什么？&quot;&gt;&lt;/a&gt;1. Java的跨平台的机制是什么？&lt;/h3&gt;&lt;blockquote</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Lambda表达式</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-09-14T11:14:23.000Z</published>
    <updated>2022-09-14T11:24:58.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Lambda表达式？"><a href="#什么是Lambda表达式？" class="headerlink" title="什么是Lambda表达式？"></a>什么是Lambda表达式？</h4><blockquote><p>可以将Lambda表达式理解为一个匿名函数； Lambda表达式允许将一个函数作为另外一个函数的参数； 我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码作为实参）,也可以理解为函数式编程，将一个函数作为参数进行传递。</p></blockquote><h4 id="2-为什么要引入Lambda表达式？"><a href="#2-为什么要引入Lambda表达式？" class="headerlink" title="2. 为什么要引入Lambda表达式？"></a>2. 为什么要引入Lambda表达式？</h4><blockquote><p>当java程序员看到其他语言的程序员（如JS，Python）在使用闭包或者Lambda表达式的时候，于是开始吐槽世界上使用最广的语言居然不支持函数式编程。千呼万唤，Java8推出了Lambda表达式。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.isea.java;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">       thread.start();</span><br><span class="line">       thread.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使这段代码变得更加简洁，可以使用匿名内部类重构一下（注意代码中的注释）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.isea.java;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="comment">//这里的new Runnable()，这里new 了接口，在这个new的接口里面，我们写了这个接口的实现类。</span></span><br><span class="line">        <span class="comment">//这里可以看出，我们把一个重写的run()方法传入了一个构造函数中。</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Lambda表达式的分类"><a href="#3-Lambda表达式的分类" class="headerlink" title="3. Lambda表达式的分类"></a>3. Lambda表达式的分类</h4><h5 id="1-无参无返回值"><a href="#1-无参无返回值" class="headerlink" title="1. 无参无返回值"></a>1. 无参无返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="2-有参无返回值"><a href="#2-有参无返回值" class="headerlink" title="2. 有参无返回值"></a>2. 有参无返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;AAAAA&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;BBBBB&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;CCCCC&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;DDDDD&quot;</span>);</span><br><span class="line"><span class="comment">//形参的类型是确定的，可省略；只有一个形参，()可以省略；</span></span><br><span class="line">        list.forEach(t -&gt; System.out.print(t + <span class="string">&quot;\t&quot;</span>));</span><br><span class="line"><span class="comment">//或者更简洁的方法引用：list.forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//打印结果：AAAAABBBBBCCCCCDDDDD</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span></span><br></pre></td></tr></table></figure></blockquote><p>forEach() 功能等同与增强型for循环 这个方法来自于Iterable接口，Collection接口继承了这个接口，List又继承了Collection接口，而ArrayList是List的实现类；forEach函数，指明该函数需要传入一个函数，而且是有参数没有返回值的函数，而Consumer接口中正好有且仅有一个这样的有参无返回值的抽象方法。接下来，我们会了解到这是使用Lambda的必要条件。</p><h5 id="3-无参有返回值"><a href="#3-无参有返回值" class="headerlink" title="3. 无参有返回值"></a>3. 无参有返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.generate(() -&gt;random.nextInt(<span class="number">100</span>));</span><br><span class="line">        stream.forEach(t -&gt; System.out.println(t));</span><br><span class="line">    &#125;<span class="comment">//只有一个return，可以省略return；该方法将会不断的打印100以内的正整数。</span></span><br><span class="line">&#125;<span class="comment">//Stream.generate()方法创建无限流，该方法要求传入一个无参有返回值的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> <span class="comment">//来自源码</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="4-有参有返回值"><a href="#4-有参有返回值" class="headerlink" title="4. 有参有返回值"></a>4. 有参有返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.Collator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collator</span> <span class="variable">collator</span> <span class="operator">=</span> Collator.getInstance();</span><br><span class="line">        TreeSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((s1,s2) -&gt; collator.compare(s1.getName(),s2.getName()));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">10</span>,<span class="string">&quot;张飞&quot;</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;周瑜&quot;</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>));</span><br><span class="line">        set.forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这里的Collator是一个抽象类，但是提供了获取该类实例的方法getInstance()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        Home | This.ID = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-函数式接口"><a href="#4-函数式接口" class="headerlink" title="4. 函数式接口"></a>4. 函数式接口</h4><blockquote><p>即SAM（Single Abstract Method ）接口，有且只有一个抽象方法的接口（可以有默认方法或者是静态方法和从Object继承来的方法，但是抽象方法有且只能有一个）。 JDK1.8之后，添加@FunctionalInterface表示这个接口是是一个函数式接口，因为有了@functionalInterface标记，也称这样的接口为Mark（标记）类型的接口。举例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">java.lang.Runnable&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">java.lang.Comparator&lt;T&gt;&#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面的例子，比方说这个Runnable接口是支持Lambda表达式，那么如果有一个方法（比如Thread类的构造函数）需要传入一个Runnable接口的实现类的话，那么就可以直接把Lambda表达式写进去。</p><p>换个角度说TreeSet，它有一个构造函数中是要求传入一个接口类型，如果这个接口类型恰好是函数式接口，那么直接传进去一个Lambda表达式即可。</p><p><strong>函数式接口作用</strong></p><blockquote><p>函数式接口能够接受匿名内部类的实例化对象，换句话说，我们可以使用匿名内部类来实例化函数式接口的对象，而Lambda表达式能够代替内部类实现代码的进一步简化，因此，Lambda表达式和函数式接口紧密的联系到了一起，接下来的这句话非常的重要：</p><p>每一个Lambda表达式能隐式的给函数式接口赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>)).start();</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>编译器会认为Thread()中传入的是一个Runnable的对象，而我们利用IDEA的智能感知，鼠标指向“-&gt;”或“（）”的时候，会发现这是一个Runnable类型，实际上编译器会自动将Lambda表达式赋值给函数式接口，在本例中就是Runnable接口。本例中Lambda表达式将打印方法传递给了Runnable接口中的run（）方法，从而形成真正的方法体。</p><p>而且，参数与返回值是一一对应的，即如果函数式接口中的抽象方法是有返回值，有参数的，那么要求Lambda表达式也是有返回值，有参数的（余下类推）</p></blockquote><blockquote><p><strong>四大函数式接口：</strong></p><p>有时候后，如果我们调用某一个方法，发现这个方法中需要传入的参数要求是一个函数式的接口，那么我们可以直接传入Lambda表达式。这些接口位于java.util.function包下，需要注意一下，java.util包和java.util.function包这两个包没有什么关系，切不可以为function包是java.util包下面的包。</p><ol><li>消费型接口：Consumer&lt; T&gt; void accept(T t)有参数，无返回值的抽象方法；</li><li>供给型接口：Supplier &lt; T&gt; T get() 无参有返回值的抽象方法；</li><li>断定型接口： Predicate&lt; T&gt; boolean test(T t):有参，但是返回值类型是固定的boolean</li><li>函数型接口： Function&lt; T，R&gt; R apply(T t)有参有返回值的抽象方法；</li></ol></blockquote><h4 id="5-新日期时间API-补充"><a href="#5-新日期时间API-补充" class="headerlink" title="5. 新日期时间API(补充)"></a>5. 新日期时间API(补充)</h4><blockquote><h4 id="1-LocalDate-只有年月日"><a href="#1-LocalDate-只有年月日" class="headerlink" title="1. LocalDate(只有年月日)"></a>1. LocalDate(只有年月日)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDate_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(date.getYear()+<span class="string">&quot; &quot;</span>+date.getMonthValue()+<span class="string">&quot; &quot;</span>+date.getDayOfMonth());</span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-LocalTime-只有时分秒"><a href="#2-LocalTime-只有时分秒" class="headerlink" title="2 . LocalTime(只有时分秒)"></a>2 . LocalTime(只有时分秒)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(time.getHour()+<span class="string">&quot; &quot;</span>+time.getMinute()+<span class="string">&quot; &quot;</span>+time.getSecond());</span><br><span class="line">        System.out.println(time.toString());</span><br><span class="line">        System.out.println(time.toSecondOfDay());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-LocalDateTime-年月日和时分秒"><a href="#3-LocalDateTime-年月日和时分秒" class="headerlink" title="3. LocalDateTime(年月日和时分秒)"></a>3. LocalDateTime(年月日和时分秒)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDateTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(dateTime.getYear()+<span class="string">&quot; &quot;</span>+dateTime.getMonthValue()+<span class="string">&quot; &quot;</span>+dateTime.getDayOfMonth()+</span><br><span class="line">                            dateTime.getHour()+<span class="string">&quot; &quot;</span>+dateTime.getMinute()+<span class="string">&quot; &quot;</span>+dateTime.getSecond());</span><br><span class="line">        System.out.println(dateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-DateTimeFormatter"><a href="#4-DateTimeFormatter" class="headerlink" title="4. DateTimeFormatter"></a>4. DateTimeFormatter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTimeFormatter_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd:HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2017-12-15:19:15:01&quot;</span>,formatter);</span><br><span class="line">        System.out.println(dateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-ZonedDateTime-有时区"><a href="#5-ZonedDateTime-有时区" class="headerlink" title="5. ZonedDateTime(有时区)"></a>5. ZonedDateTime(有时区)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZonedDateTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;MM/dd/yyyy:HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> zonedDateTime.format(formatter);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是Lambda表达式？&quot;&gt;&lt;a href=&quot;#什么是Lambda表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是Lambda表达式？&quot;&gt;&lt;/a&gt;什么是Lambda表达式？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;可以将Lambda表达式理</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Stream流</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Stream%E6%B5%81/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Stream%E6%B5%81/</id>
    <published>2022-09-14T08:52:23.000Z</published>
    <updated>2022-09-14T09:59:40.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Stream流"><a href="#什么是Stream流" class="headerlink" title="什么是Stream流"></a>什么是Stream流</h2><blockquote><p><code>Stream</code>被翻译为流，它的工作过程像将一瓶水导入有很多过滤阀的管道一样，水每经过一个过滤阀，便被操作一次，比如过滤，转换等，最后管道的另外一头有一个容器负责接收剩下的水。</p><p><code>Stream</code>作为Java 8的一大亮点，它专门针对集合的各种操作提供各种非常便利，简单，高效的API,<code>Stream API</code>主要是通过<code>Lambda</code>表达式完成，极大的提高了程序的效率和可读性，同时<code>Stram API</code>中自带的并行流使得并发处理集合的门槛再次降低，使用<code>Stream API</code>编程无需多写一行多线程的大门就可以非常方便的写出高性能的并发程序。使用<code>Stream API</code>能够使你的代码更加优雅。</p><p>流的另一特点是可无限性，使用<code>Stream</code>，你的数据源可以是无限大的。</p></blockquote><h2 id="如何使用流"><a href="#如何使用流" class="headerlink" title="如何使用流"></a>如何使用流</h2><blockquote><ul><li>获取流</li><li>对流操作</li><li>结束对流操作</li></ul></blockquote><h3 id="获取流"><a href="#获取流" class="headerlink" title="-  获取流"></a>-  获取流</h3><blockquote><p>获取流的方式有多种，对于常见的容器(<code>Collection</code>)可以直接<code>.stream()</code>获取 例如：</p><ul><li><code>Collection.stream()</code></li><li><code>Collection.parallelStream()</code></li><li><code>Arrays.stream(T array) or Stream.of()</code></li></ul><p>对于<code>IO</code>，我们也可以通过<code>lines()</code>方法获取流：</p><ul><li><code>java.nio.file.Files.walk()</code></li><li><code>java.io.BufferedReader.lines()</code></li></ul><p>最后，我们还可以从无限大的数据源中产生流：</p><ul><li><code>Random.ints()</code></li></ul><p>值得注意的是，<code>JDK</code>中针对基本数据类型的昂贵的装箱和拆箱操作，提供了基本数据类型的流：</p><ul><li><p><code>IntStream</code></p></li><li><p><code>LongStream</code></p></li><li><p><code>DoubleStream</code></p><p>这三种基本数据类型和普通流差不多，不过他们流里面的数据都是指定的基本数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intstream.of(new int[]&#123;1,2,3&#125;);</span><br><span class="line">Intstream.range(1,3);</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这边有个parallelStream和stream的区别</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为parallelstream是并行流,所以执行效率比较高</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并行流并不会按照原本的顺序轨迹执行, 而是 随机执行</span></span><br><span class="line">可以从以下三点入手考虑是否使用parallelstream</span><br><span class="line">是否需要并行？  </span><br><span class="line">任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class="line">结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure><blockquote><p>获取流的方式有多种，对于常见的容器(<code>Collection</code>)可以直接<code>.stream()</code>获取 例如：</p><ul><li><code>Collection.stream()</code></li><li><code>Collection.parallelStream()</code></li><li><code>Arrays.stream(T array) or Stream.of()</code></li></ul><p>对于<code>IO</code>，我们也可以通过<code>lines()</code>方法获取流：</p><ul><li><code>java.nio.file.Files.walk()</code></li><li><code>java.io.BufferedReader.lines()</code></li></ul><p>最后，我们还可以从无限大的数据源中产生流：</p><ul><li><code>Random.ints()</code></li></ul><p>值得注意的是，<code>JDK</code>中针对基本数据类型的昂贵的装箱和拆箱操作，提供了基本数据类型的流：</p><ul><li><p><code>IntStream</code></p></li><li><p><code>LongStream</code></p></li><li><p><code>DoubleStream</code></p><p>这三种基本数据类型和普通流差不多，不过他们流里面的数据都是指定的基本数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intstream.of(new int[]&#123;1,2,3&#125;);</span><br><span class="line">Intstream.rang(1,3);</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这边有个parallelStream和stream的区别</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为parallelstream是并行流,所以执行效率比较高</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并行流并不会按照原本的顺序轨迹执行, 而是 随机执行</span></span><br><span class="line">可以从以下三点入手考虑是否使用parallelstream</span><br><span class="line">是否需要并行？  </span><br><span class="line">任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class="line">结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure><h3 id="对流操作"><a href="#对流操作" class="headerlink" title="- 对流操作"></a>- 对流操作</h3><blockquote><p>对于中间操作，所有的<code>API</code>的返回值基本都是<code>Stream&lt;T&gt;</code>,因此以后看见一个陌生的<code>API</code>也能通过返回值判断它的所属类型。</p><h6 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a><strong>map/flatMap</strong></h6><p><code>map</code>顾名思义，就是映射，<code>map</code>操作能够将流中的每一个元素映射为另外的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p>可以看到<code>map</code>接受的是一个<code>Function</code>,也就是接收参数，并返回一个值。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提取 List&lt;Student&gt;  所有student 的名字 </span></span><br><span class="line">List&lt;String&gt; studentNames = students.stream().map(Student::getName)</span><br><span class="line">                                             .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上面的代码等同于以前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; studentNames=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line">    studentNames.add(student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>再比如：将List中所有字母转换为大写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words=Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt; upperWords=words.stream().map(String::toUpperCase)</span><br><span class="line">                                      .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><p><code>flatMap</code>顾名思义就是扁平化映射，它具体的操作是将多个<code>stream</code>连接成一个<code>stream</code>，这个操作是针对类似多维数组的，比如容器里面包含容器等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ints=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">                                          Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)));</span><br><span class="line">List&lt;Integer&gt; flatInts=ints.stream().flatMap(Collection::stream).</span><br><span class="line">                                       collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>可以看到，相当于降维。</p><hr><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filter`顾名思义，就是过滤，通过测试的元素会被留下来并生成一个新的`Stream</span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure><p>同理，我们可以<code>filter</code>接收的参数是<code>Predicate</code>，也就是推断型函数式接口，接收参数，并返回<code>boolean</code>值。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有大于18岁的学生</span></span><br><span class="line">List&lt;Student&gt; studentNames = students.stream().filter(s-&gt;s.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">                                              .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a><strong>distinct</strong></h6><p><code>distinct</code>是去重操作,它没有参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><hr><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a><strong>sorted</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sorted`排序操作，默认是从小到大排列，sorted方法包含一个重载，使用sorted方法，如果没有传递参数，那么流中的元素就需要实现Comparable&lt;T&gt;方法，也可以在使sorted方法的时候传入一个`Comparator&lt;T&gt;</span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>值得一说的是这个<code>Comparator</code>在<code>Java 8</code>之后被打上了<code>@FunctionalInterface</code>,其他方法都提供了<code>default</code>实现，因此我们可以在<code>sort</code>中使用<code>Lambda</code>表达式</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以年龄排序</span></span><br><span class="line">students.stream().sorted((s,o)-&gt;Integer.compare(s.getAge(),o.getAge()))</span><br><span class="line">                                  .forEach(System.out::println);;</span><br></pre></td></tr></table></figure><p>然而还有更方便的，<code>Comparator</code>默认也提供了实现好的方法引用，使得我们更加方便的使用：</p><p>例如上面的代码可以改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以年龄排序 </span></span><br><span class="line">students.stream().sorted(Comparator.comparingInt(Student::getAge))</span><br><span class="line">                            .forEach(System.out::println);;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以姓名排序</span></span><br><span class="line">students.stream().sorted(Comparator.comparing(Student::getName)).</span><br><span class="line">                          forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>是不是更加简洁。</p><hr><h6 id="peek"><a href="#peek" class="headerlink" title="peek"></a><strong>peek</strong></h6><p><code>peek</code>有遍历的意思，和<code>forEach</code>一样，但是它是一个中间操作。</p><p><code>peek</code>接受一个消费型的函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去重以后打印出来，然后再归并为List</span></span><br><span class="line">List&lt;Student&gt; sortedStudents= students.stream().distinct().peek(System.out::println).</span><br><span class="line">                                                collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h6 id="limit"><a href="#limit" class="headerlink" title="limit"></a><strong>limit</strong></h6><p><code>limit</code>裁剪操作，和<code>String::subString(0,x)</code>有点先沟通，<code>limit</code>接受一个<code>long</code>类型参数，通过<code>limit</code>之后的元素只会剩下<code>min(n,size)</code>个元素，<code>n</code>表示参数，<code>size</code>表示流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只留下前6个元素并打印</span></span><br><span class="line">students.stream().limit(<span class="number">6</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h6 id="skip"><a href="#skip" class="headerlink" title="skip"></a><strong>skip</strong></h6><p><code>skip</code>表示跳过多少个元素，和<code>limit</code>比较像，不过<code>limit</code>是保留前面的元素，<code>skip</code>是保留后面的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳过前3个元素并打印 </span></span><br><span class="line">students.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></blockquote><h3 id="终结操作"><a href="#终结操作" class="headerlink" title="- 终结操作"></a>- 终结操作</h3><blockquote><p>一个流处理中，有且只能有一个终结操作，通过终结操作之后，流才真正被处理，终结操作一般都返回其他的类型而不再是一个流,一般来说，终结操作都是将其转换为一个容器。</p><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><strong>forEach</strong></h6><p><code>forEach</code>是终结操作的遍历，操作和<code>peek</code>一样，但是<code>forEach</code>之后就不会再返回流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历打印</span></span><br><span class="line">students.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的代码和一下代码效果相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line">    System.out.println(sudents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a><strong>toArray</strong></h6><p><code>toArray</code>和<code>List##toArray()</code>用法差不多，包含一个重载。</p><p>默认的<code>toArray()</code>返回一个<code>Object[]</code>，</p><p>也可以传入一个<code>IntFunction&lt;A[]&gt; generator</code>指定数据类型</p><p>一般建议第二种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student[] studentArray = students.stream().skip(<span class="number">3</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><hr><h6 id="max-min"><a href="#max-min" class="headerlink" title="max/min"></a><strong>max/min</strong></h6><p><code>max/min</code>即使找出最大或者最小的元素。<code>max/min</code>必须传入一个<code>Comparator</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure><hr><h6 id="count"><a href="#count" class="headerlink" title="count"></a><strong>count</strong></h6><p><code>count</code>返回流中的元素数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span>  <span class="variable">count</span> <span class="operator">=</span> students.stream().skip(<span class="number">3</span>).count();</span><br></pre></td></tr></table></figure><hr><h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><strong>reduce</strong></h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce为归纳操作，主要是将流中各个元素结合起来，它需要提供一个起始值，然后按一定规则进行运算，比如相加等，它接收一个二元操作 <span class="code">`BinaryOperator`</span>函数式接口。从某种意义上来说，<span class="code">`sum,min,max,average`</span>都是特殊的reduce</span><br></pre></td></tr></table></figure><p><code>reduce</code>包含三个重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"></span><br><span class="line"> &lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity,</span></span><br><span class="line"><span class="params">                 BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">        </span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> integers.stream().reduce(<span class="number">0</span>,(x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure><p>以上代码等同于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> integers.stream().reduce(Integer::sum).get();</span><br></pre></td></tr></table></figure><p><code>reduce</code>两个参数和一个参数的区别在于有没有提供一个起始值，</p><p>如果提供了起始值，则可以返回一个确定的值，如果没有提供起始值，则返回<code>Opeational</code>防止流中没有足够的元素。</p><hr><h6 id="anyMatch-allMatch-noneMatch"><a href="#anyMatch-allMatch-noneMatch" class="headerlink" title="anyMatch\ allMatch\ noneMatch"></a><strong>anyMatch\ allMatch\ noneMatch</strong></h6><p>测试是否有任意元素\所有元素\没有元素匹配表达式</p><p>他们都接收一个推断类型的函数式接口：<code>Predicate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">noneMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> integers.stream().anyMatch(x-&gt;x&gt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h6 id="findFirst、-findAny"><a href="#findFirst、-findAny" class="headerlink" title="findFirst、 findAny"></a><strong>findFirst、 findAny</strong></h6><p>获取元素，这两个<code>API</code>都不接受任何参数，<code>findFirt</code>返回流中第一个元素，<code>findAny</code>返回流中任意一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">findFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">findAny</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>也有有人会问<code>findAny()</code>这么奇怪的操作谁会用？这个<code>API</code>主要是为了在并行条件下想要获取任意元素，以最大性能获取任意元素</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> integers.stream().findAny().get();</span><br></pre></td></tr></table></figure><hr><h6 id="collect"><a href="#collect" class="headerlink" title="collect"></a><strong>collect</strong></h6><p><code>collect</code>收集操作，这个<code>API</code>放在后面将是因为它太重要了，基本上所有的流操作最后都会使用它。</p><p>我们先看<code>collect</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>collect</code>包含两个重载：</p><p>一个参数和三个参数，</p><p>三个参数我们很少使用，因为<code>JDK</code>提供了足够我们使用的<code>Collector</code>供我们直接使用,我们可以简单了解下这三个参数什么意思：</p><ul><li><code>Supplier</code>:用于产生最后存放元素的容器的生产者</li><li><code>accumulator</code>:将元素添加到容器中的方法</li><li><code>combiner</code>：将分段元素全部添加到容器中的方法</li></ul><p>前两个元素我们都很好理解，第三个元素是干嘛的呢？因为流提供了并行操作，因此有可能一个流被多个线程分别添加，然后再将各个子列表依次添加到最终的容器中。</p><p>↓ - - - - - - - - -</p><p>↓ — — —</p><p>↓ ———</p><p>如上图，分而治之。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = stream.collect(ArrayList::<span class="keyword">new</span>, List::add, List::addAll);</span><br></pre></td></tr></table></figure><hr><p>接下来看只有一个参数的<code>collect</code></p><p>一般来说，只有一个参数的<code>collect</code>，我们都直接传入<code>Collectors</code>中的方法引用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; = integers.stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><code>Collectors</code>中包含很多常用的转换器。<code>toList()</code>,<code>toSet()</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collectors`中还包括一个`groupBy()`，他和`Sql`中的`groupBy`一样都是分组，返回一个`Map</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按学生年龄分组</span></span><br><span class="line">Map&lt;Integer,List&lt;Student&gt;&gt; map= students.stream().</span><br><span class="line">                                collect(Collectors.groupingBy(Student::getAge));</span><br></pre></td></tr></table></figure><p><code>groupingBy</code>可以接受3个参数，分别是</p><ol><li>第一个参数：分组按照什么分类</li><li>第二个参数：分组最后用什么容器保存返回（当只有两个参数是，此参数默认为<code>HashMap</code>）</li><li>第三个参数：按照第一个参数分类后，对应的分类的结果如何收集</li></ol><p>有时候单参数的<code>groupingBy</code>不满足我们需求的时候，我们可以使用多个参数的<code>groupingBy</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生以年龄分组，每组中只存学生的名字而不是对象</span></span><br><span class="line">Map&lt;Integer,List&lt;String&gt;&gt; map =  students.stream().</span><br><span class="line">  collect(Collectors.groupingBy(Student::getAge,Collectors.mapping(Student::getName,Collectors.toList())));</span><br></pre></td></tr></table></figure><p><code>toList</code>默认生成的是<code>ArrayList</code>,<code>toSet</code>默认生成的是<code>HashSet</code>，如果想要指定其他容器，可以如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> students.stream().collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">Collectors`还包含一个`toMap`，利用这个`API`我们可以将`List`转换为`Map</span><br><span class="line">  Map&lt;Integer,Student&gt; map=students.stream().</span><br><span class="line">                           collect(Collectors.toMap(Student::getAge,s-&gt;s));</span><br></pre></td></tr></table></figure><p>值得注意的一点是，<code>IntStream</code>，<code>LongStream</code>,<code>DoubleStream</code>是没有<code>collect()</code>方法的，因为对于基本数据类型，要进行装箱，拆箱操作，SDK并没有将它放入流中，对于基本数据类型流，我们只能将其<code>toArray()</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Stream流&quot;&gt;&lt;a href=&quot;#什么是Stream流&quot; class=&quot;headerlink&quot; title=&quot;什么是Stream流&quot;&gt;&lt;/a&gt;什么是Stream流&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt;被翻译为流，</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数据库大数据量问题</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%8F%92%E5%85%A5/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%8F%92%E5%85%A5/</id>
    <published>2022-09-14T03:27:23.000Z</published>
    <updated>2022-09-14T07:53:01.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大批量插入数据优化"><a href="#大批量插入数据优化" class="headerlink" title="大批量插入数据优化"></a>大批量插入数据优化</h2><blockquote><h3 id="1-一条SQL语句插入多条数据"><a href="#1-一条SQL语句插入多条数据" class="headerlink" title="1.一条SQL语句插入多条数据"></a>1.一条SQL语句插入多条数据</h3><p>常用的插入语句如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>修改后的插入操作能够提高程序的插入效率。这里第二种SQL执行效率高的主要原因是合并后日志量（MySQL的binlog和innodb的事务让日志）减少了， <strong>降低日志刷盘的数据量和频率，从而提高效率</strong>。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传输的IO 。</p><p>可以显著提高效率</p><h3 id="2-在事务中进行插入处理。"><a href="#2-在事务中进行插入处理。" class="headerlink" title="2.在事务中进行插入处理。"></a>2.在事务中进行插入处理。</h3><p>把插入修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>使用事务可以提高数据的插入效率，这是因为进行一个INSERT操作时，<strong>MySQL内部会建立一个事务</strong>，在事务内才进行真正插入处理操作。通过使用事务可以减少创建事务的消耗， <code>所有插入都在执行后才进行提交操作</code> 。</p><h3 id="3-数据有序插入。"><a href="#3-数据有序插入。" class="headerlink" title="3.数据有序插入。"></a>3.数据有序插入。</h3><p>数据有序的插入是指插入记录在主键上是有序排列，例如datetime是记录的主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;userid_2&#x27;</span>, <span class="string">&#x27;content_2&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;userid_2&#x27;</span>, <span class="string">&#x27;content_2&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>由于数据库插入时，需要维护索引数据</strong>，<code>无序的记录会增大维护索引的成本</code>。 我们可以参照InnoDB使用的B+tree索引，如果每次插入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，需要B+tree进行分裂合并等处理，会消耗比较多计算资源，并且插入记录的索引定位效率会下降，数据量较大时会有频繁的磁盘操作。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大批量插入数据优化&quot;&gt;&lt;a href=&quot;#大批量插入数据优化&quot; class=&quot;headerlink&quot; title=&quot;大批量插入数据优化&quot;&gt;&lt;/a&gt;大批量插入数据优化&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;1-一条SQL语句插入多条数据&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引相关</title>
    <link href="https://gwtt.github.io/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://gwtt.github.io/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/</id>
    <published>2022-09-14T02:32:47.141Z</published>
    <updated>2022-09-14T03:12:10.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么用-B-树做索引而不用哈希表做索引"><a href="#为什么用-B-树做索引而不用哈希表做索引" class="headerlink" title="为什么用 B+ 树做索引而不用哈希表做索引?"></a>为什么用 B+ 树做索引而不用哈希表做索引?</h3><blockquote><p>1、哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。</p><p>2、如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。</p><p>3、索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的<strong>链表</strong>，这样的话，查找的时间就会大大增加。</p></blockquote><h3 id="主键索引和非主键索引有什么区别？"><a href="#主键索引和非主键索引有什么区别？" class="headerlink" title="主键索引和非主键索引有什么区别？"></a>主键索引和非主键索引有什么区别？</h3><blockquote><p>例如对于下面这个表(其实就是上面的表中增加了一个k字段),且ID是主键。</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640.png" alt="图片"></p><p>主键索引和非主键索引的示意图如下：</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631230630081.png" alt="图片"></p><p>其中R代表一整行的值。</p><p>从图中不难看出，主键索引和非主键索引的区别是：非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>，其中非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p><p>根据这两种结构我们来进行下查询，看看他们在查询上有什么区别。</p><p>1、如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p><p>2、如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为回表。</p></blockquote><h3 id="为什么建议使用主键自增的索引？"><a href="#为什么建议使用主键自增的索引？" class="headerlink" title="为什么建议使用主键自增的索引？"></a>为什么建议使用主键自增的索引？</h3><blockquote><p>对于这颗主键索引的树</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631245106466.png" alt="图片"></p><p>如果我们插入 ID = 650 的一行数据，那么直接在最右边插入就可以了</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631245106467.png" alt="图片"></p><p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行<strong>页分裂</strong>操作，这样会更加糟糕。</p><p>但是，如果我们的主键是自增的，每次插入的 ID 都会比前面的大，那么我们每次只需要在后面插入就行， 不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么用-B-树做索引而不用哈希表做索引&quot;&gt;&lt;a href=&quot;#为什么用-B-树做索引而不用哈希表做索引&quot; class=&quot;headerlink&quot; title=&quot;为什么用 B+ 树做索引而不用哈希表做索引?&quot;&gt;&lt;/a&gt;为什么用 B+ 树做索引而不用哈希表做索引?&lt;/</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="MySQL" scheme="https://gwtt.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MySQL慢查询</title>
    <link href="https://gwtt.github.io/2022/09/11/%E6%B5%85%E8%B0%88Mysql%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <id>https://gwtt.github.io/2022/09/11/%E6%B5%85%E8%B0%88Mysql%E6%85%A2%E6%9F%A5%E8%AF%A2/</id>
    <published>2022-09-11T11:44:18.000Z</published>
    <updated>2022-09-11T15:42:07.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="慢查询是什么"><a href="#慢查询是什么" class="headerlink" title="慢查询是什么"></a>慢查询是什么</h3><blockquote><p>MySQL的慢查询，全名是<strong>慢查询日志</strong>，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。</p><p>具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。</p><p>long_query_time的默认值为10，意思是记录运行10秒以上的语句。</p><p>默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>慢查询日志支持将日志记录写入文件和数据库表。</p></blockquote><h3 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h3><blockquote><p><strong>mysql并不启动慢查询日志</strong>，需要我们手动开启</p><ul><li>1、输入命令开启慢查询（临时），在MySQL服务重启后会自动关闭；</li><li>2、配置my.cnf（windows是my.ini）系统文件开启，修改配置文件是持久化开启慢查询的方式</li></ul></blockquote><blockquote><h3 id="命令开启"><a href="#命令开启" class="headerlink" title="命令开启"></a>命令开启</h3><p>查询慢查询是否开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>开启慢查询命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>; </span><br></pre></td></tr></table></figure><p>指定记录慢查询日志SQL执行时间得阈值（long_query_time 单位：秒，默认10秒）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><p>查询 “慢查询日志文件存放位置”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log_file%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="配置文件开启"><a href="#配置文件开启" class="headerlink" title="配置文件开启"></a>配置文件开启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启慢查询功能</span></span><br><span class="line">slow_query_log=ON</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定记录慢查询日志SQL执行时间得阈值</span></span><br><span class="line">long_query_time=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选填，默认数据文件路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slow_query_log_file=/var/lib/mysql/localhost-slow.log</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="慢查询经验"><a href="#慢查询经验" class="headerlink" title="慢查询经验"></a>慢查询经验</h2><h3 id="LIMIT分页"><a href="#LIMIT分页" class="headerlink" title="LIMIT分页"></a>LIMIT分页</h3><blockquote><h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><p>  在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</p><p>  一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 1000000,10这样的查询，这是mysql需要查询1000000条然后只返回最后10条，前面的1000000条记录都将被舍弃，这样的代价很高，会造成慢查询。</p><p>  优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p>对于下面的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行耗时：1.379s</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info LIMIT <span class="number">1000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p> 该语句存在的最大问题在于limit M,N中偏移量M太大，导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。</p><p>  那么如果我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的10条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次查询都先从整个表中先找到满足条件的前M条记录，舍弃掉，再从M+1开始再找到10条满足条件的记录了。</p><h3 id="思路一：构造覆盖索引"><a href="#思路一：构造覆盖索引" class="headerlink" title="思路一：构造覆盖索引"></a>思路一：构造覆盖索引</h3><p>  通过修改SQL，使用上覆盖索引，比如我需要只查询表中的app_name、createTime等少量字段，那么我秩序在app_name、createTime字段设置联合索引，即可实现覆盖索引，无需全表扫描。适用于查询列较少的场景，查询列数过多的不推荐。</p><p>耗时：<code>0.390s</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> app_name,createTime <span class="keyword">from</span> vio_basic_domain_info LIMIT <span class="number">1000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="思路二：优化offset"><a href="#思路二：优化offset" class="headerlink" title="思路二：优化offset"></a>思路二：优化offset</h3><p>  无法用上覆盖索引，那么重点是想办法快速过滤掉前100w条数据。我们可以利用自增主键有序的条件，先查询出第1000001条数据的id值，再往后查10行；适用于主键id自增的场景。<br>耗时：<code>0.471s</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">where</span> </span><br><span class="line">  id <span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> id <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> id limit <span class="number">1000000</span>,<span class="number">1</span>) limit <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法三：“延迟关联”"><a href="#方法三：“延迟关联”" class="headerlink" title="方法三：“延迟关联”"></a>方法三：“延迟关联”</h3><p>耗时：<code>0.439s</code><br>延迟关联适用于数量级较大的表，SQL如下；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">1000000</span>,<span class="number">10</span>) <span class="keyword">as</span> myNew <span class="keyword">using</span>(id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们利用到了<code>覆盖索引+延迟关联查询</code>，相当于先只查询id列，利用覆盖索引快速查到该页的10条数据id，然后再把返回的10条id拿到表中通过主键索引二次查询。（表数据增速快的情况对该方法影响较小。）</p></blockquote><h3 id="索引没起作用"><a href="#索引没起作用" class="headerlink" title="索引没起作用"></a>索引没起作用</h3><blockquote><h3 id="1-模糊查询尽量避免用通配符’-’开头，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#1-模糊查询尽量避免用通配符’-’开头，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="1.模糊查询尽量避免用通配符’%’开头，会导致数据库引擎放弃索引进行全表扫描。如下："></a>1.模糊查询尽量避免用通配符’%’开头，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%MIKE%&#x27;</span> #不推荐</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;MIKE%&#x27;</span> #推荐</span><br></pre></td></tr></table></figure><p>如果需求是要在前面使用模糊查询，</p><p>使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置。<br>使用FullText全文索引，用match against 检索<br>数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级<br>当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like ‘%xx%’。<br>  但不得不说，MySQL模糊匹配大字段是硬伤，毕竟保证事务的ACID特性耗费了太多性能，因此，如果实际场景中有类似业务需求，建议果断更换大数据存储引擎如<strong>ElasticSearch</strong>、<strong>Hbase</strong>等。</p><h3 id="2-尽量避免使用-not-in，会导致引擎走全表扫描。建议用-not-exists-代替，如下："><a href="#2-尽量避免使用-not-in，会导致引擎走全表扫描。建议用-not-exists-代替，如下：" class="headerlink" title="2.尽量避免使用 not in，会导致引擎走全表扫描。建议用 not exists 代替，如下："></a>2.尽量避免使用 not in，会导致引擎走全表扫描。建议用 not exists 代替，如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> name <span class="keyword">not</span> <span class="keyword">IN</span> (<span class="string">&#x27;提莫&#x27;</span>,<span class="string">&#x27;队长&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">as</span> t1 <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">as</span> t2 <span class="keyword">where</span> name <span class="keyword">IN</span> (<span class="string">&#x27;提莫&#x27;</span>,<span class="string">&#x27;队长&#x27;</span>) <span class="keyword">and</span> t1.id <span class="operator">=</span> t2.id);</span><br></pre></td></tr></table></figure><h3 id="3-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#3-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="3.尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下："></a>3.尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优化方式：可以用<span class="keyword">union</span>代替<span class="keyword">or</span>。如下：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="4-尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#4-尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下："></a>4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">优化方式：可以给字段添加默认值<span class="number">0</span>，对<span class="number">0</span>值进行判断。如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> score <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="5-尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下："><a href="#5-尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下：" class="headerlink" title="5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下："></a>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全表扫描</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> score<span class="operator">/</span><span class="number">10</span> <span class="operator">=</span> <span class="number">9</span></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> score <span class="operator">=</span> <span class="number">10</span><span class="operator">*</span><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="6-当数据量大时，避免使用where-1-1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下："><a href="#6-当数据量大时，避免使用where-1-1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：" class="headerlink" title="6.当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下："></a>6.当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username, age, sex <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">优化方式：用代码拼装<span class="keyword">sql</span>时进行判断，没 <span class="keyword">where</span> 条件就去掉 <span class="keyword">where</span>，有<span class="keyword">where</span>条件就加 <span class="keyword">and</span>。</span><br></pre></td></tr></table></figure><h3 id="7-查询条件不要用-lt-gt-或者"><a href="#7-查询条件不要用-lt-gt-或者" class="headerlink" title="7.查询条件不要用 &lt;&gt; 或者 !="></a>7.查询条件不要用 &lt;&gt; 或者 !=</h3><p>使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</p><h3 id="8-where条件仅包含复合索引非前导列"><a href="#8-where条件仅包含复合索引非前导列" class="headerlink" title="8.where条件仅包含复合索引非前导列"></a>8.where条件仅包含复合索引非前导列</h3><p>如：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> key_part2<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part3<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> key_part1 <span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part2<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part3<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="9-隐式类型转换造成不使用索引"><a href="#9-隐式类型转换造成不使用索引" class="headerlink" title="9.隐式类型转换造成不使用索引"></a>9.隐式类型转换造成不使用索引</h3><p>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> col_varchar<span class="operator">=</span><span class="number">123</span>; </span><br></pre></td></tr></table></figure></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>你对MySQL的慢查询优化有了解吗 </p><blockquote><p><strong>标准回答</strong></p><p>​    慢查询优化的前提是定位到响应慢的SQL，这可以通过启用慢查询日志来实现。默认情况下，MySQL并不启用慢查询日志，我们需要手动开启这个参数。通过日志定位到慢查询的SQL之后，我们可以使用EXPLAIN语句来分析这个SQL，进而发现问题所在。导致慢查询的原因有很多，下面列举几种常见的原因，以及对应的解决方案：</p><ol><li><p>向数据库请求了多余的数据：</p><p>很多时候，我们的SQL返回的结果会超出我们的需要，例如实际上它返回了更多的行，而我们只要其中的一部分。又或者我们要求返回所有的列，实际上却只有其中少数的列。对于这类问题，我们可以通过LIMIT控制返回的行数，尽量不用<code>SELECT *</code>避免查询到过多的列。</p></li><li><p>SQL复杂导致无法利用缓存：</p><p>处于业务的需要，我们经常会写出比较复杂的SQL，这自然包括复杂的关联查询。由于复杂SQL返回的结果涉及多张表、多个条件、甚至各种函数，这样的SQL每次返回的结果势必不同，所以很难利用到数据库的缓存。如果我们将复杂SQL进行拆分，变成若干简单的SQL，那么其中有些SQL由于条件不变，就可以利用到数据库的缓存了，从而让查询效率得以提升。</p></li><li><p>没有选择正确的索引：</p><p>我们都知道，创建索引是提高查询效率的一个常用手段，事实上我们也经常会这样做。但是，很多时候我们创建了索引，通过EXPLAIN查看会发现并没有走这个索引，最终导致SQL执行变慢。所以，不是把索引创建出来就算完成任务，还要分析索引的选择性，根据业务条件不断的优化索引，从而增加索引的命中率。</p><p><strong>加分回答</strong></p><p>​    除上述优化的方向之外，SQL中还有很多地方都有优化的空间，例如COUNT()、关联查询、子查询、GROUP BY、LIMIT、UNION等。总体来说，不同的情况要区别对待，但所有优化的背后是基于慢查询日志的定位。另外，为了能够发现问题的本质，还需要对MySQL执行查询的过程有所了解：</p><ol><li>客户端发送一条查询SQL给服务器。 </li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。 </li><li>服务器进行SQL解析和预处理，再由优化器生成对应的执行计划。 </li><li>服务器根据优化器生成的执行计划，调用存储引擎的API来执行查询。 </li><li>将结果返回给客户端。 </li></ol><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p>​    B+树索引是基于B+树构建出来的有序结构，只有利用上它的有序性才能提高查询的效率。若不满足有序性这个前提，则在这个索引中的查询是离散的，其效率反而更低。查询优化器对索引的选择性，被称为最左前缀原则。</p><p>​    假设有如下一张表：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (</span><br><span class="line">  a <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  b <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  c <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  KEY idx_union(a,b,c)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB;</span><br></pre></td></tr></table></figure><p>​    假设idx_union的叶子节点数据如下：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>), (<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>), (<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>), (<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>), (<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>), (<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>​    该索引的选择性示例如下：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 匹配左前缀</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 匹配列前缀</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;x%&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;%x&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b <span class="keyword">like</span> <span class="string">&#x27;x%&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 全值匹配</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> c<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="comment">-- 匹配范围值</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 全值匹配 + 范围匹配</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> c <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;慢查询是什么&quot;&gt;&lt;a href=&quot;#慢查询是什么&quot; class=&quot;headerlink&quot; title=&quot;慢查询是什么&quot;&gt;&lt;/a&gt;慢查询是什么&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL的慢查询，全名是&lt;strong&gt;慢查询日志&lt;/strong&gt;，是MySQ</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL面试</title>
    <link href="https://gwtt.github.io/2022/09/05/SQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95/"/>
    <id>https://gwtt.github.io/2022/09/05/SQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95/</id>
    <published>2022-09-05T10:43:55.628Z</published>
    <updated>2022-09-05T10:49:52.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL的执行顺序"><a href="#1-SQL的执行顺序" class="headerlink" title="1.SQL的执行顺序"></a>1.SQL的执行顺序</h2><blockquote><p> from&gt;join&gt;where&gt;group by&gt;聚合函数&gt;having&gt;select&gt;order by&gt;limit </p><h3 id="1、最先执行from-table；"><a href="#1、最先执行from-table；" class="headerlink" title="1、最先执行from table；"></a>1、最先执行from table；</h3><p> 需要先确定从哪个表中取<a href>数据</a>，所以最先执行from table。 </p><h3 id="2、join连接"><a href="#2、join连接" class="headerlink" title="2、join连接"></a>2、join连接</h3><p> 用于把来自两个或多个表的行结合起来，简单补充一下连接的类型 </p><ul><li> 自然连接（natural join） </li><li> 内连接（inner join）：内连接查询能将左表和右表中能关联起来的<a href>数据</a>连接后返回，返回的结果就是两个表中所有相匹配的<a href>数据</a>。 </li><li> 外连接（outer join）：外连接分为左外连接（LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行）、右外连接（RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行）、还有一个FULL JOIN(全连接)，不过MYSQL不支持全连接 </li><li> 交叉连接（cross join）即笛卡尔连接 </li></ul><h3 id="3、where语句；"><a href="#3、where语句；" class="headerlink" title="3、where语句；"></a>3、where语句；</h3><p> where语句是对条件加以限定 </p><h3 id="4、分组语句【group-by……-having】；"><a href="#4、分组语句【group-by……-having】；" class="headerlink" title="4、分组语句【group by…… having】；"></a>4、分组语句【group by…… having】；</h3><p> group by是分组语句 </p><p> having是和group by配合使用的，用来作条件限定 </p><h3 id="5、聚合函数；"><a href="#5、聚合函数；" class="headerlink" title="5、聚合函数；"></a>5、聚合函数；</h3><p> 常用的聚合函数有max，min， count，sum，聚合函数的执行在group by之后，having之前 </p><p> 举例：count函数查询分组后，每一组分别有多少条<a href>数据</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="title function_">count</span><span class="params">(*)</span> from user group by gender</span><br></pre></td></tr></table></figure><p> 值得注意的是：<strong>聚合函数的执行在group by之后，having之前</strong> </p><h3 id="6、select语句；"><a href="#6、select语句；" class="headerlink" title="6、select语句；"></a>6、select语句；</h3><p> 对分组聚合完的表挑选出需要查询的<a href>数据</a> </p><h3 id="7、Distinct"><a href="#7、Distinct" class="headerlink" title="7、Distinct"></a>7、Distinct</h3><p> distinct对<a href>数据</a>进行去重 </p><p> 如果sql语句存在聚合函数，例如count、max等，会<strong>先执行聚合函数再去重</strong> </p><h3 id="8、order-by排序语句。"><a href="#8、order-by排序语句。" class="headerlink" title="8、order by排序语句。"></a>8、order by<a href>排序</a>语句。</h3><p> order by<a href>排序</a>语句 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id  升序排序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> 降序排序</span><br></pre></td></tr></table></figure><h3 id="9、limit"><a href="#9、limit" class="headerlink" title="9、limit"></a>9、limit</h3><p> limit用于指定返回的<a href>数据</a>条数 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">2</span></span><br><span class="line">从<span class="keyword">user</span>表中查询前两条数据</span><br><span class="line">该<span class="keyword">sql</span>等同于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">0</span>,<span class="number">2</span></span><br><span class="line">表示从第<span class="number">0</span>条开始取两条数据</span><br></pre></td></tr></table></figure><p> limit常配合order by使用 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">3</span></span><br><span class="line">根据id排序，选出id排序前三的数据</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <strong>from&gt;join&gt;where&gt;group by&gt;聚合函数&gt;having&gt;select&gt;order by&gt;limit</strong> </p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">distinct</span> user.name </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">join</span> vip <span class="keyword">on</span> user.id<span class="operator">=</span>vip.id </span><br><span class="line"><span class="keyword">where</span> user.id<span class="operator">&gt;</span><span class="number">10</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user.mobile </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> user.id</span><br><span class="line">limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol><li> from user </li><li> join vip on user.id=vip.id ，join是表示要关联的表，on是连接的条件 </li><li> where user.id&gt;10  </li><li> group by user.mobile 根据user.mobile分组 </li><li> 然后先执行count(*)在执行having，查询分组之后数量大于2的分组<a href>数据</a> </li><li> select 对分组聚合完的表挑选出需要查询的<a href>数据</a> </li><li> distinct查询出来的<a href>数据</a>去重 </li><li> order by user.id 对去重后的<a href>数据</a><a href>排序</a> </li><li> limit 3对<a href>排序</a>后的<a href>数据</a>选出前面3条</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-SQL的执行顺序&quot;&gt;&lt;a href=&quot;#1-SQL的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;1.SQL的执行顺序&quot;&gt;&lt;/a&gt;1.SQL的执行顺序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; from&amp;gt;join&amp;gt;where&amp;gt</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux防火墙</title>
    <link href="https://gwtt.github.io/2022/09/05/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E5%90%AF/"/>
    <id>https://gwtt.github.io/2022/09/05/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E5%90%AF/</id>
    <published>2022-09-05T10:32:23.000Z</published>
    <updated>2022-09-05T10:35:55.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-防火墙开启指定端口"><a href="#Linux-防火墙开启指定端口" class="headerlink" title="Linux 防火墙开启指定端口"></a>Linux 防火墙开启指定端口</h3><p>通常情况下，CentOS 系统部署完成后，关闭并禁用防火墙。但有些特殊情况需要保持防火墙的启用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启用防火墙</span></span><br><span class="line">systemctl enable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看已经开放的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启指定端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=[端口号]/[协议] --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line">--zone=&lt;zone&gt; # 指定 zone</span><br><span class="line">--add-port=&lt;portid&gt;]/&lt;protocol&gt; # 端口id / 协议</span><br><span class="line">--permanent # 永久开启，不添加则重启失效</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭指定端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public –remove-port=[端口号]/[协议] --permanent</span><br><span class="line">firewall-cmd --zone=public –remove-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新加载防火墙</span></span><br><span class="line">systemctl reload firewalld</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux-防火墙开启指定端口&quot;&gt;&lt;a href=&quot;#Linux-防火墙开启指定端口&quot; class=&quot;headerlink&quot; title=&quot;Linux 防火墙开启指定端口&quot;&gt;&lt;/a&gt;Linux 防火墙开启指定端口&lt;/h3&gt;&lt;p&gt;通常情况下，CentOS 系统部署完</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="运维" scheme="https://gwtt.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Mysql代码例子</title>
    <link href="https://gwtt.github.io/2022/09/05/Mysql%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90/"/>
    <id>https://gwtt.github.io/2022/09/05/Mysql%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90/</id>
    <published>2022-09-05T10:21:18.000Z</published>
    <updated>2022-09-05T10:29:11.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立一个用户允许远程连接，并赋予对应库的权限"><a href="#建立一个用户允许远程连接，并赋予对应库的权限" class="headerlink" title="建立一个用户允许远程连接，并赋予对应库的权限"></a>建立一个用户允许远程连接，并赋予对应库的权限</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p;#用密码登录mysql数据库</span><br><span class="line">use mysql;#使用对应的数据库</span><br><span class="line">select host,user,password from user;#查看数据库所有用户和密码</span><br><span class="line"></span><br><span class="line">修改host：update user set host = &#x27;%&#x27; where user = &#x27;用户名&#x27;;</span><br><span class="line">刷新数据：flush privileges;</span><br><span class="line">#或者</span><br><span class="line">添加用户：grant all privileges on *.* to 用户名@&#x27;%&#x27; identified by &quot;用户密码&quot;;</span><br><span class="line">刷新数据：flush privileges;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建立一个用户允许远程连接，并赋予对应库的权限&quot;&gt;&lt;a href=&quot;#建立一个用户允许远程连接，并赋予对应库的权限&quot; class=&quot;headerlink&quot; title=&quot;建立一个用户允许远程连接，并赋予对应库的权限&quot;&gt;&lt;/a&gt;建立一个用户允许远程连接，并赋予对应库的</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
</feed>
