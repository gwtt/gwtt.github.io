<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>滚~韬的博客</title>
  
  <subtitle>滚~</subtitle>
  <link href="https://gwtt.github.io/atom.xml" rel="self"/>
  
  <link href="https://gwtt.github.io/"/>
  <updated>2022-09-05T10:49:52.459Z</updated>
  <id>https://gwtt.github.io/</id>
  
  <author>
    <name>滚~韬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL面试</title>
    <link href="https://gwtt.github.io/2022/09/05/SQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95/"/>
    <id>https://gwtt.github.io/2022/09/05/SQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95/</id>
    <published>2022-09-05T10:43:55.628Z</published>
    <updated>2022-09-05T10:49:52.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL的执行顺序"><a href="#1-SQL的执行顺序" class="headerlink" title="1.SQL的执行顺序"></a>1.SQL的执行顺序</h2><blockquote><p> from&gt;join&gt;where&gt;group by&gt;聚合函数&gt;having&gt;select&gt;order by&gt;limit </p><h3 id="1、最先执行from-table；"><a href="#1、最先执行from-table；" class="headerlink" title="1、最先执行from table；"></a>1、最先执行from table；</h3><p> 需要先确定从哪个表中取<a href>数据</a>，所以最先执行from table。 </p><h3 id="2、join连接"><a href="#2、join连接" class="headerlink" title="2、join连接"></a>2、join连接</h3><p> 用于把来自两个或多个表的行结合起来，简单补充一下连接的类型 </p><ul><li> 自然连接（natural join） </li><li> 内连接（inner join）：内连接查询能将左表和右表中能关联起来的<a href>数据</a>连接后返回，返回的结果就是两个表中所有相匹配的<a href>数据</a>。 </li><li> 外连接（outer join）：外连接分为左外连接（LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行）、右外连接（RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行）、还有一个FULL JOIN(全连接)，不过MYSQL不支持全连接 </li><li> 交叉连接（cross join）即笛卡尔连接 </li></ul><h3 id="3、where语句；"><a href="#3、where语句；" class="headerlink" title="3、where语句；"></a>3、where语句；</h3><p> where语句是对条件加以限定 </p><h3 id="4、分组语句【group-by……-having】；"><a href="#4、分组语句【group-by……-having】；" class="headerlink" title="4、分组语句【group by…… having】；"></a>4、分组语句【group by…… having】；</h3><p> group by是分组语句 </p><p> having是和group by配合使用的，用来作条件限定 </p><h3 id="5、聚合函数；"><a href="#5、聚合函数；" class="headerlink" title="5、聚合函数；"></a>5、聚合函数；</h3><p> 常用的聚合函数有max，min， count，sum，聚合函数的执行在group by之后，having之前 </p><p> 举例：count函数查询分组后，每一组分别有多少条<a href>数据</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="title function_">count</span><span class="params">(*)</span> from user group by gender</span><br></pre></td></tr></table></figure><p> 值得注意的是：<strong>聚合函数的执行在group by之后，having之前</strong> </p><h3 id="6、select语句；"><a href="#6、select语句；" class="headerlink" title="6、select语句；"></a>6、select语句；</h3><p> 对分组聚合完的表挑选出需要查询的<a href>数据</a> </p><h3 id="7、Distinct"><a href="#7、Distinct" class="headerlink" title="7、Distinct"></a>7、Distinct</h3><p> distinct对<a href>数据</a>进行去重 </p><p> 如果sql语句存在聚合函数，例如count、max等，会<strong>先执行聚合函数再去重</strong> </p><h3 id="8、order-by排序语句。"><a href="#8、order-by排序语句。" class="headerlink" title="8、order by排序语句。"></a>8、order by<a href>排序</a>语句。</h3><p> order by<a href>排序</a>语句 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id  升序排序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> 降序排序</span><br></pre></td></tr></table></figure><h3 id="9、limit"><a href="#9、limit" class="headerlink" title="9、limit"></a>9、limit</h3><p> limit用于指定返回的<a href>数据</a>条数 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">2</span></span><br><span class="line">从<span class="keyword">user</span>表中查询前两条数据</span><br><span class="line">该<span class="keyword">sql</span>等同于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">0</span>,<span class="number">2</span></span><br><span class="line">表示从第<span class="number">0</span>条开始取两条数据</span><br></pre></td></tr></table></figure><p> limit常配合order by使用 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">3</span></span><br><span class="line">根据id排序，选出id排序前三的数据</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <strong>from&gt;join&gt;where&gt;group by&gt;聚合函数&gt;having&gt;select&gt;order by&gt;limit</strong> </p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">distinct</span> user.name </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">join</span> vip <span class="keyword">on</span> user.id<span class="operator">=</span>vip.id </span><br><span class="line"><span class="keyword">where</span> user.id<span class="operator">&gt;</span><span class="number">10</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user.mobile </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> user.id</span><br><span class="line">limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol><li> from user </li><li> join vip on user.id=vip.id ，join是表示要关联的表，on是连接的条件 </li><li> where user.id&gt;10  </li><li> group by user.mobile 根据user.mobile分组 </li><li> 然后先执行count(*)在执行having，查询分组之后数量大于2的分组<a href>数据</a> </li><li> select 对分组聚合完的表挑选出需要查询的<a href>数据</a> </li><li> distinct查询出来的<a href>数据</a>去重 </li><li> order by user.id 对去重后的<a href>数据</a><a href>排序</a> </li><li> limit 3对<a href>排序</a>后的<a href>数据</a>选出前面3条</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-SQL的执行顺序&quot;&gt;&lt;a href=&quot;#1-SQL的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;1.SQL的执行顺序&quot;&gt;&lt;/a&gt;1.SQL的执行顺序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; from&amp;gt;join&amp;gt;where&amp;gt</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux防火墙</title>
    <link href="https://gwtt.github.io/2022/09/05/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E5%90%AF/"/>
    <id>https://gwtt.github.io/2022/09/05/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E5%90%AF/</id>
    <published>2022-09-05T10:32:23.000Z</published>
    <updated>2022-09-05T10:35:55.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-防火墙开启指定端口"><a href="#Linux-防火墙开启指定端口" class="headerlink" title="Linux 防火墙开启指定端口"></a>Linux 防火墙开启指定端口</h3><p>通常情况下，CentOS 系统部署完成后，关闭并禁用防火墙。但有些特殊情况需要保持防火墙的启用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启用防火墙</span></span><br><span class="line">systemctl enable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看已经开放的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启指定端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=[端口号]/[协议] --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line">--zone=&lt;zone&gt; # 指定 zone</span><br><span class="line">--add-port=&lt;portid&gt;]/&lt;protocol&gt; # 端口id / 协议</span><br><span class="line">--permanent # 永久开启，不添加则重启失效</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭指定端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public –remove-port=[端口号]/[协议] --permanent</span><br><span class="line">firewall-cmd --zone=public –remove-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新加载防火墙</span></span><br><span class="line">systemctl reload firewalld</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux-防火墙开启指定端口&quot;&gt;&lt;a href=&quot;#Linux-防火墙开启指定端口&quot; class=&quot;headerlink&quot; title=&quot;Linux 防火墙开启指定端口&quot;&gt;&lt;/a&gt;Linux 防火墙开启指定端口&lt;/h3&gt;&lt;p&gt;通常情况下，CentOS 系统部署完</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="运维" scheme="https://gwtt.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Mysql代码例子</title>
    <link href="https://gwtt.github.io/2022/09/05/Mysql%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90/"/>
    <id>https://gwtt.github.io/2022/09/05/Mysql%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90/</id>
    <published>2022-09-05T10:21:18.000Z</published>
    <updated>2022-09-05T10:29:11.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立一个用户允许远程连接，并赋予对应库的权限"><a href="#建立一个用户允许远程连接，并赋予对应库的权限" class="headerlink" title="建立一个用户允许远程连接，并赋予对应库的权限"></a>建立一个用户允许远程连接，并赋予对应库的权限</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p;#用密码登录mysql数据库</span><br><span class="line">use mysql;#使用对应的数据库</span><br><span class="line">select host,user,password from user;#查看数据库所有用户和密码</span><br><span class="line"></span><br><span class="line">修改host：update user set host = &#x27;%&#x27; where user = &#x27;用户名&#x27;;</span><br><span class="line">刷新数据：flush privileges;</span><br><span class="line">#或者</span><br><span class="line">添加用户：grant all privileges on *.* to 用户名@&#x27;%&#x27; identified by &quot;用户密码&quot;;</span><br><span class="line">刷新数据：flush privileges;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建立一个用户允许远程连接，并赋予对应库的权限&quot;&gt;&lt;a href=&quot;#建立一个用户允许远程连接，并赋予对应库的权限&quot; class=&quot;headerlink&quot; title=&quot;建立一个用户允许远程连接，并赋予对应库的权限&quot;&gt;&lt;/a&gt;建立一个用户允许远程连接，并赋予对应库的</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>gitlab自动部署</title>
    <link href="https://gwtt.github.io/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://gwtt.github.io/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2022-09-03T02:29:18.000Z</published>
    <updated>2022-09-05T05:08:22.295Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于GItlab CI/CD的自动部署方案</p><h3 id="GitLabCI-CD工作原理"><a href="#GitLabCI-CD工作原理" class="headerlink" title="GitLabCI/CD工作原理"></a>GitLabCI/CD工作原理</h3><blockquote><ul><li>将代码托管到Git存储库</li><li>在项目根目录创建ci文件.gitlab-ci.yml,在文件中指定构建、测试和部署脚本</li><li>GitLab将检测到它并使用名为GitLab Runner的工具运行脚本</li><li>脚本被分组为作业，它们共同组成一个管道 </li></ul><p>运行效果:</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904095646489.png" alt="image-20220904095646489"></p></blockquote><h3 id="首先什么我们要知道Gitlab是什么"><a href="#首先什么我们要知道Gitlab是什么" class="headerlink" title="首先什么我们要知道Gitlab是什么"></a>首先什么我们要知道Gitlab是什么</h3><blockquote><p>是一种类似github的服务，组织可以使用它来提供git存储库的内部管理。 它是一个自我托管的Git-repository管理系统，可以保持用户代码的私密性，并且可以轻松地部署代码的更改。</p></blockquote><h3 id="GitLab安装"><a href="#GitLab安装" class="headerlink" title="GitLab安装"></a>GitLab安装</h3><blockquote><ul><li>检查配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The following is the recommended minimum CPU hardware guidance for a handful of example GitLab user base sizes.</span><br><span class="line"></span><br><span class="line">4 cores is the recommended minimum number of cores and supports up to 500 users</span><br><span class="line">8 cores supports up to 1000 users</span><br><span class="line"></span><br><span class="line">The following is the recommended minimum Memory hardware guidance for a handful of example GitLab user base sizes.</span><br><span class="line"></span><br><span class="line">4GB RAM is the required minimum memory size and supports up to 500 users</span><br><span class="line">8GB RAM supports up to 1000 users</span><br><span class="line"></span><br><span class="line">一般来说，两核八GB就够用了</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查询cpu指令</span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line">查询内存指令</span><br><span class="line">cat /proc/meminfo</span><br><span class="line">查询Linux内核版本</span><br><span class="line">cat /proc/version</span><br><span class="line">友情提示：如果是一核两G不用试了</span><br></pre></td></tr></table></figure><ul><li>使用rpm包安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/e17/gitlab-ce-15.3.2-ce.0.el7.x86_64.rpm</span><br><span class="line">rpm -ivh gitlab-ce-15.3.2-ce.0.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">vim /etc/gitlab.rb #编辑站点地址</span><br><span class="line"></span><br><span class="line">gitlab-ctl reconfigure #配置</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">启动</span></span><br><span class="line">gitlab-ctl start</span><br><span class="line">状态</span><br><span class="line">gitlab-ctl status</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">停止</span></span><br><span class="line">gitlab-ctl stop</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">重启</span></span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>另外docker安装和kubernetes安装就不赘述了</p></blockquote><h3 id="GitLab-Runner介绍相关"><a href="#GitLab-Runner介绍相关" class="headerlink" title="GitLab Runner介绍相关"></a>GitLab Runner介绍相关</h3><blockquote><h3 id="GitLab-Runner简介"><a href="#GitLab-Runner简介" class="headerlink" title="GitLab Runner简介:"></a>GitLab Runner简介:</h3><ul><li>GitLab Runner是一个开源项目，用于运行作业并将结果发送GitLab</li><li>与GitLabCI结合使用，GitLabCI是GitLab随附的用于协调作业的开源持续集成服务</li><li>GitLab Runner是用Go编写的，可以在Linux,macOS和Windos操作系统上运行</li><li>容器部署需使用最新Docker版本。</li><li>可以根据配置需要配置任意数量的Runner</li></ul><h3 id="Runner特点"><a href="#Runner特点" class="headerlink" title="Runner特点:"></a>Runner特点:</h3><ul><li><p>作业运行控制：同时执行多个作业</p></li><li><p>作业运行环境:</p><ol><li>在本地、使用Docker容器、使用Docker容器并通过SSH执行作业</li><li>使用Docker容器在不同的云和虚拟化管理程序上自动缩放</li><li>连接到远程SSH服务器</li></ol></li><li><p>自动重新加载配置，无需重启</p></li><li><p>易于安装，可作为Linux,macOS和Windos的服务</p></li></ul><h3 id="GitLab-Runner类型与状态"><a href="#GitLab-Runner类型与状态" class="headerlink" title="GitLab Runner类型与状态"></a>GitLab Runner类型与状态</h3><ul><li>类型:<ul><li>shared 共享类型,运行整个平台项目的作业</li><li>group项目组类型，运行特定group下所有项目的作业</li><li>specific项目类型，运行指定的项目作业</li></ul></li><li>状态<ul><li>locked：锁定状态，无法运行项目作业</li><li>paused：暂停状态，暂时不会接受新的作业</li></ul></li></ul><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220903215422460.png" alt="image-20220903215422460"></p></blockquote><h3 id="GitLab-Runner安装相关"><a href="#GitLab-Runner安装相关" class="headerlink" title="GitLab Runner安装相关"></a>GitLab Runner安装相关</h3><blockquote><p>包管理工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Add the official GitLab repository 添加官方仓库</span><br><span class="line">curl -L &quot;https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh&quot; | sudo bash</span><br><span class="line"></span><br><span class="line">Install the latest version of GitLab Runner, or skip to the next step to install a specific version 安装最新版本或者下一步</span><br><span class="line">sudo yum install gitlab-runner</span><br><span class="line"></span><br><span class="line">To install a specific version of GitLab Runner:安装指定版本</span><br><span class="line">yum list gitlab-runner --showduplicates | sort -r</span><br><span class="line">sudo yum install gitlab-runner-10.0.0-1</span><br><span class="line"></span><br><span class="line">更新runner</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install gitlab-runner</span><br></pre></td></tr></table></figure></blockquote><h3 id="GitLab-Runner注册"><a href="#GitLab-Runner注册" class="headerlink" title="GitLab Runner注册"></a>GitLab Runner注册</h3><blockquote><p>获取shared类型runnertoken</p><p>进入系统设置-&gt;Runners</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904160532695.png" alt="image-20220904160532695"></p><p>同理也可以找到对应得group CI/CD Runner和单项目得CI/CD Runner</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/gitlab-runner register --locked=&quot;false&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向GitLab-CI注册一个Runner需要两样东西：</span></span><br><span class="line">GitLab-CI的url和注册token。 其中，token是为了确定你这个Runner是所有工程都能够使用的Shared Runner还是具体某一个工程才能使用的Specific Runner。 如果要注册Shared Runner，你需要到管理界面的Runners页面里面去找注册token。如下图所示</span><br></pre></td></tr></table></figure><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220903215549856.png" alt="image-20220903215549856"></p><p>GitLab CI/CD支持的执行器有很多种，最常用的是Docker， shell，Kubernets三种。</p><p>Shell 是最易于配置的执行器。构建中所需的依赖得你手工装在 Runner 所在机器上。</p><p>更好的方式是使用 Docker，它让你拥有干净的构建环境，以及简易的依赖管理——所有的编译项目所需的依赖都可以放进 Docker 镜像中。Docker 执行器很容易就能创建带有依赖服务的编译环境，比如 MySQL。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v v/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor &quot;docker&quot; \</span><br><span class="line">  --docker-image alpine:latest \</span><br><span class="line">  --url &quot;url&quot; \# 网页端域名 </span><br><span class="line">  --registration-token &quot;token&quot; \# gitlab提供的token</span><br><span class="line">  --description &quot;first-register-runner&quot; \</span><br><span class="line">  --tag-list &quot;test-cicd1,dockercicd1&quot; \</span><br><span class="line">  --run-untagged=&quot;true&quot; \</span><br><span class="line">  --locked=&quot;false&quot; \</span><br><span class="line">  --access-level=&quot;not_protected&quot;</span><br></pre></td></tr></table></figure></blockquote><h3 id="gitlab-ci-yml文件"><a href="#gitlab-ci-yml文件" class="headerlink" title=".gitlab-ci.yml文件"></a>.gitlab-ci.yml文件</h3><blockquote><p>如何检查你的yml文件是否符合,可以用CI Lint</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904164146671-16623544839293.png" alt="image-20220904164146671"></p></blockquote><h2 id="Pipeline语法"><a href="#Pipeline语法" class="headerlink" title="Pipeline语法"></a>Pipeline语法</h2><h3 id="1-Job"><a href="#1-Job" class="headerlink" title="1.Job"></a>1.Job</h3><blockquote><p>在.gitlab-ci.yml的文件中，可以定义一个或多个作业（job）。每个作业必须具有唯一的名称（不能使用关键字），每个作业是独立执行。作业定义了在约束条件下进行相关操作，每一个作业至少要包含至少一个script</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;execute-script-for-job1&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-script"><a href="#2-script" class="headerlink" title="2.script"></a>2.script</h3><blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure><p>有时，script命令将需要用单引号或双引号引起来。例如，包含冒号命令(:)需要加引号，以便被包裹的YAML解析器知道来解释整个事情作为一个字符串，而不是一个”键:值”对.使用特殊字符时要小心<code>:</code> ,<code>&#123;</code>,<code>&#125;</code>,<code>[</code>,<code>]</code>, <code>,</code> 等等</p></blockquote><h3 id="3-before-script"><a href="#3-before-script" class="headerlink" title="3.before_script"></a>3.before_script</h3><blockquote><p>跟script差不多，只不过在作业之前运行，如果失败则整个任务失败，作业失败不会影响after_sciprt</p></blockquote><h3 id="4-stages"><a href="#4-stages" class="headerlink" title="4.stages"></a>4.stages</h3><blockquote><p>用于定义作业可以使用的阶段，并且是全局定义的。同一阶段的作业并行运行，不同阶段按顺序执行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">codescan</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="5-pre-amp-post"><a href="#5-pre-amp-post" class="headerlink" title="5. .pre&amp;.post"></a>5. .pre&amp;.post</h3><blockquote><p>.pre始终是整个管道的第一个运行阶段, .post始终是整个管道的最后一个运行阶段。用户定义的阶段都在两者之间运行。.pre和.post的顺序无法更改。如果管道仅包含.pre或.post阶段的作业，则不会创建管道</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codescan:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">.pre</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;codescan&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="6-tags-指定runner"><a href="#6-tags-指定runner" class="headerlink" title="6.tags(指定runner)"></a>6.tags(指定runner)</h3><blockquote><p>用于从允许运行该项目的所有Runner列表中选择特定的Runner，在Runner注册期间，您可以指定Runner标签</p></blockquote><h3 id="7-allow-failure允许失败"><a href="#7-allow-failure允许失败" class="headerlink" title="7.allow_failure允许失败"></a>7.allow_failure允许失败</h3><blockquote><p>allow_failure允许作业失败，默认值为false。启用后，如果作业失败，将会在用户界面中显示橙色警告。但是，管道的逻辑流程将认为作业成功/通过，并且不会阻塞。假设所有其他作业均成功，则该作业的阶段及其管道将显示相同的橙色警告。但是，关联的提交将被标记”通过”,而不会发出警告。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">execute</span></span><br><span class="line">  <span class="attr">allow_failure:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">MAVEN_CLI_OPTS:</span> <span class="string">&quot;--batch-mode --errors --fail-at-end --show-version -s .m2/settings.xml&quot;</span></span><br><span class="line">  <span class="attr">MAVEN_OPTS:</span> <span class="string">&quot;-Dmaven.repo.local=.m2/repository&quot;</span></span><br><span class="line">  <span class="attr">PACKAGE_NAME:</span> <span class="string">&quot;certificate.jar&quot;</span></span><br><span class="line">  <span class="attr">PACKAGE_BACK_NAME:</span> <span class="string">&quot;certificateBack.jar&quot;</span></span><br><span class="line">  <span class="attr">PROD_ENV_1:</span> <span class="string">&quot;10.166.41.101&quot;</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">maven:3.8.1-openjdk-11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">$&#123;CI_COMMIT_REF_SLUG&#125;</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.m2/repository</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sacc/target/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;cd sacc&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mvn $MAVEN_CLI_OPTS package -Dmaven.test.skip=true -Pprod&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al target&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-prod:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh/&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;echo &quot;$SSH_PRIVATE_KEY&quot; &gt;&gt; ./id_rsa &amp;&amp; chmod 600 ./id_rsa&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;echo -e &quot;Host *\n\tStrictHostKeyChecking no\n\n&quot; &gt; ~/.ssh/config&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al sacc/target&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;yum install net-tools&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;/bin/cp -rf /opt/webapps/certificate/$PACKAGE_NAME \&quot;/opt/webapps/certificate/$PACKAGE_NAME.$(date +\&quot;%y%m%d\&quot;)\&quot;&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;scp -i ./id_rsa -r sacc/target/$PACKAGE_NAME root@$PROD_ENV_1:/opt/webapps/certificate/$PACKAGE_NAME&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;cp /dev/null /opt/webapps/certificate/nohup.out&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;ssh -i ./id_rsa root@$PROD_ENV_1 \&quot;pkill -f certificate.jar\&quot;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;nohup java -jar /opt/webapps/certificate/certificate.jar &amp;&gt; /opt/webapps/certificate/nohup.out &amp;&quot;&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是关于GItlab CI/CD的自动部署方案&lt;/p&gt;
&lt;h3 id=&quot;GitLabCI-CD工作原理&quot;&gt;&lt;a href=&quot;#GitLabCI-CD工作原理&quot; class=&quot;headerlink&quot; title=&quot;GitLabCI/CD工作原理&quot;&gt;&lt;/a&gt;GitLabCI/</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="运维" scheme="https://gwtt.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型</title>
    <link href="https://gwtt.github.io/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gwtt.github.io/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-09-01T10:54:21.938Z</published>
    <updated>2022-09-01T11:45:02.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的三大IO模型"><a href="#Java中的三大IO模型" class="headerlink" title="Java中的三大IO模型"></a>Java中的三大IO模型</h2><p>在JDK1.4之前，基于Java所有的socket通信都采用了同步阻塞模型（BIO），这种模型性能低下，当时大型的服务均采用C或C++开发，因为它们可以直接使用操作系统提供的异步IO或者AIO，使得性能得到大幅提升。</p><p>2002年，JDK1.4发布，新增了java.nio包，提供了许多异步IO开发的API和类库。新增的NIO，极大的促进了基于Java的异步非阻塞的发展和应用。</p><p>2011年，JDK7发布，将原有的NIO进行了升级，称为NIO2.0，其中也对AIO进行了支持。</p><h3 id="BIO模型"><a href="#BIO模型" class="headerlink" title="BIO模型"></a>BIO模型</h3><blockquote><p>java中的BIO是blocking I/O的简称，它是同步阻塞型IO，其相关的类和接口在java.io下。</p><p>BIO模型简单来讲，就是服务端为每一个请求都分配一个线程进行处理，如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/e8e029a04700e7f4523e63108c6c771992b4b1be.png@942w_497h_progressive.webp" alt="img"></p><p>示例代码：</p><p>public class BIOServer {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等待客户端连接。。。。&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">//阻塞</span></span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); <span class="comment">//阻塞</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                    <span class="keyword">if</span>(length == -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, length, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}<br>这种模式存在的问题：</p><p>客户端的并发数与后端的线程数成1:1的比例，线程的创建、销毁是非常消耗系统资源的，随着并发量增大，服务端性能将显著下降，甚至会发生线程堆栈溢出等错误。</p><p>当连接创建后，如果该线程没有操作时，会进行阻塞操作，这样极大的浪费了服务器资源。</p></blockquote><h3 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h3><blockquote><p>NIO，称之为New IO 或是 non-block IO （非阻塞IO），这两种说法都可以，其实称之为非阻塞IO更恰当一些。</p><p>NIO相关的代码都放在了java.nio包下，其三大核心组件：Buffer（缓冲区）、Channel（通道）、Selector（选择器/多路复用器）</p><p>Buffer</p><p>在NIO中，所有的读写操作都是基于缓冲区完成的，底层是通过数组实现的，常用的缓冲区是ByteBuffer，每一种java基本类型都有对应的缓冲区对象（除了Boolean类型），如：CharBuffer、IntBuffer、LongBuffer等。</p><p>Channel</p><p>在BIO中是基于Stream实现，而在NIO中是基于通道实现，与流不同的是，通道是双向的，既可以读也可以写。</p><p>Selector</p><p>Selector是多路复用器，它会不断的轮询注册在其上的Channel，如果某个Channel上发生读或写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey获取就绪Channel的集合，进行IO的读写操作。</p><p>基本示意图如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/262bc99c60a8dacc1116aff1585ec53655e1c44b.png@942w_509h_progressive.webp" alt="img"></p><p>可以看出，NIO模型要优于BIO模型，主要是：</p><p>通过多路复用器就可以实现一个线程处理多个通道，避免了多线程之间的上下文切换导致系统开销过大。</p><p>NIO无需为每一个连接开一个线程处理，并且只有通道真正有有事件时，才进行读写操作，这样大大的减少了系统开销。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectorDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Selector <span class="title function_">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取selector对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取通道并且绑定端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6677</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册感兴趣的事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="built_in">this</span>.getSelector();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select(); <span class="comment">//该方法会阻塞，直到至少有一个事件的发生</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                process(selectionKey, selector);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable())&#123; <span class="comment">//新连接请求</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel)key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123; <span class="comment">//读数据</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel)key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;form 客户端 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(), <span class="number">0</span>, byteBuffer.position()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SelectorDemo</span>().listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="AIO模型"><a href="#AIO模型" class="headerlink" title="AIO模型"></a>AIO模型</h3><blockquote><p>在NIO中，Selector多路复用器在做轮询时，如果没有事件发生，也会进行阻塞，如何能把这个阻塞也优化掉呢？那么AIO就在这样的背景下诞生了。</p><p>AIO是asynchronous I/O的简称，是异步IO，该异步IO是需要依赖于操作系统底层的异步IO实现。</p><p>AIO的基本流程是：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p><ul><li><p>kernel的数据准备</p><p>将数据从网络物理设备（网卡）读取到内核缓冲区。</p></li><li><p>kernel的数据复制</p><p>将数据从内核缓冲区拷贝到用户程序空间的缓冲区。</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/583df5514d2c98bf09ae08637144d8e96e47704f.png@731w_681h_progressive.webp" alt="img"></p><p>目前AIO模型存在的不足：</p><ol><li><p>需要完成事件的注册与传递，这里边需要底层操作系统提供大量的支持，去做大量的工作。</p></li><li><p>Windows 系统下通过 IOCP 实现了真正的异步 I/O。但是，就目前的业界形式来说，Windows 系统，很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p></li><li><p>而在 Linux 系统下，异步IO模型在2.6版本才引入，目前并不完善。所以，这也是在 Linux 下，实现高并发网络编程时都是以 NIO 多路复用模型模式为主。</p></li></ol></li></ul></blockquote><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><blockquote><p>Reactor线程模型不是Java专属，也不是Netty专属，它其实是一种并发编程模型，是一种思想，具有指导意义。比如，Netty就是结合了NIO的特点，应用了Reactor线程模型所实现的。</p><p>Reactor模型中定义的三种角色：</p><ul><li>Reactor：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li>Acceptor：处理客户端新连接，并分派请求到处理器链中。</li><li>Handler：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。</li></ul><p>常见的Reactor线程模型有三种，如下：</p><ul><li>Reactor单线程模型</li><li>Reactor多线程模型</li><li>主从Reactor多线程模型</li></ul><h4 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/9d48bbccca4988a42fceda53b7faef999a4593c0.png@942w_381h_progressive.webp" alt="img"></p><p>说明:</p><ul><li>Reactor充当多路复用器角色，监听多路连接的请求，由单线程完成</li><li>Reactor收到客户端发来的请求时，如果是新建连接通过Acceptor完成，其他的请求Handler完成。</li><li>Handler完成业务逻辑的处理，基本的流程是：Read –&gt; 业务处理 –&gt; Send 。</li></ul><p>这种模型优点:</p><ul><li>结构简单，由单线程完成，没有多线程、进程通信等问题</li><li>适合在一些业务逻辑比较简单、对于性能要求不高的应用场景</li></ul><p>缺点：</p><ul><li>由于是单线程操作、不能充分发挥多核CPU的性能</li><li>当Reactor线程负载过重之后、处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重Reactor线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈。</li><li>可靠性差，如果该线程进入死循环或意外终止，就会导致整个通信系统不可用，容易造成单点故障。 </li></ul><h4 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/0a19c9de9af761ed990068f2f48871268bd0cb02.png@942w_576h_progressive.webp" alt="img"></p><p>说明:</p><ul><li>在Reactor多线程模型相比较单线程模型而言，不同点在于，Handler不会处理业务逻辑，只是负责响应用户请求，真正的业务逻辑，在另外的线程中完成。</li><li>这样可以降低Reactor的性能开销，充分利用CPU资源，从而更专注的做事件分发工作了，提升整个应用的吞吐。 </li></ul><p>但是这个模型存在的问题：</p><ul><li><p>多线程数据共享和访问比较复杂。如果子线程完成业务处理后，把结果传递给主线程Reactor进行发送，就会涉及共享数据的互斥和保护机制。</p></li><li><p>Reactor承担所有事件的监听和响应，只在主线程中运行，可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。</p></li></ul><p>为了解决性能问题，产生了第三种主从Reactor多线程模型。</p><h4 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/348b425d88ffbce6873196c1ca299f07320f70ac.png@942w_432h_progressive.webp" alt="img"></p><p>在主从模型中，将Reactor分成2部分：</p><ul><li>MainReactor负责监听server socket，用来处理网络IO连接建立操作，将建立的socketChannel指定注册给SubReactor。</li><li>SubReactor主要完成和建立起来的socket的数据交互和事件业务处理操作。</li></ul><p>该模型的优点：</p><ul><li><p>响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的。</p></li><li><p>可扩展性强，可以方便地通过增加SubReactor实例个数来充分利用CPU资源。</p></li><li><p>可复用性高，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性。</p></li></ul></blockquote><h3 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h3><blockquote><p>Netty模型是基于Reactor模型实现的，对于以上三种模型都有非常好的支持，也非常的灵活，一般情况，在服务端会采用主从架构模型，基本示意图如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/a463c8eb5c2ebd4db875eed66346404d55c741b6.png@942w_369h_progressive.webp" alt="img"></p><p>说明：</p><ul><li><p>在Netty模型中，负责处理新连接事件的是BossGroup，负责处理其他事件的是WorkGroup。Group就是线程池的概念。</p></li><li><p>NioEventLoop表示一个不断循环的执行处理任务的线程，用于监听绑定在其上的读/写事件。</p></li><li><p>通过Pipeline（管道）执行业务逻辑的处理，Pipeline中会有多个ChannelHandler，真正的业务逻辑是在ChannelHandler中完成的。</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java中的三大IO模型&quot;&gt;&lt;a href=&quot;#Java中的三大IO模型&quot; class=&quot;headerlink&quot; title=&quot;Java中的三大IO模型&quot;&gt;&lt;/a&gt;Java中的三大IO模型&lt;/h2&gt;&lt;p&gt;在JDK1.4之前，基于Java所有的socket通信都采用</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Linux" scheme="https://gwtt.github.io/tags/Linux/"/>
    
    <category term="IO" scheme="https://gwtt.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>浅谈AQS</title>
    <link href="https://gwtt.github.io/2022/09/01/%E6%B5%85%E8%B0%88AQS/"/>
    <id>https://gwtt.github.io/2022/09/01/%E6%B5%85%E8%B0%88AQS/</id>
    <published>2022-09-01T09:53:23.000Z</published>
    <updated>2022-09-01T10:43:11.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h3><blockquote><p>AQS:全称是AbstractQuenedSynchronizer（抽象队列同步器）。是除了java自带的synchronized关键字之外的锁机制。</p></blockquote><h3 id="AQS的核心思想是"><a href="#AQS的核心思想是" class="headerlink" title="AQS的核心思想是:"></a><strong>AQS的核心思想</strong>是:</h3><blockquote><p> 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH（Craig，Landin，and Hagersten locks）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p><p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p><p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p><p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong></p></blockquote><p><img src="/2022/09/01/%E6%B5%85%E8%B0%88AQS/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211bGluc2VuNzc=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>如图示，AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line"></span><br><span class="line">setState()</span><br><span class="line"></span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure><p>AQS 定义了两种资源共享方式：<br>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(<span class="type">int</span>)：独占方式。尝试获取资源，成功则返回<span class="literal">true</span>，失败则返回<span class="literal">false</span>。</span><br><span class="line">tryRelease(<span class="type">int</span>)：独占方式。尝试释放资源，成功则返回<span class="literal">true</span>，失败则返回<span class="literal">false</span>。</span><br><span class="line">tryAcquireShared(<span class="type">int</span>)：共享方式。尝试获取资源。负数表示失败；<span class="number">0</span>表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(<span class="type">int</span>)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure><h3 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h3><p>AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; write.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用实现"><a href="#应用实现" class="headerlink" title="应用实现"></a>应用实现</h3><ul><li><p>Lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>通过注释我们知道，acquire方法是一种互斥模式，且忽略中断。该方法至少执行一次tryAcquire(int)方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。函数流程如下：</p><ul><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ul><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>1.判断状态位是否为0,0是可以占用,如果是0的话占用,不是0的话返回false</p><p>2.判断当前线程是否为得到位置的线程,比如如果前一个线程走了,然后又回来有点事情的话,那么返回false</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;AQS的原理&quot;&gt;&lt;a href=&quot;#AQS的原理&quot; class=&quot;headerlink&quot; title=&quot;AQS的原理&quot;&gt;&lt;/a&gt;AQS的原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;AQS:全称是AbstractQuenedSynchronizer（抽象队列同步器</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Juc" scheme="https://gwtt.github.io/tags/Juc/"/>
    
  </entry>
  
  <entry>
    <title>手动实现栈和队列</title>
    <link href="https://gwtt.github.io/2022/09/01/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://gwtt.github.io/2022/09/01/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-09-01T04:55:57.000Z</published>
    <updated>2022-09-01T09:41:55.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-手动实现栈"><a href="#1-手动实现栈" class="headerlink" title="1. 手动实现栈"></a>1. 手动实现栈</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[]stack;<span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;<span class="comment">//当前可以存放数据元素的下标——&gt;栈顶指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用构造函数给定一个初始容量10的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">( )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stack = (T[])<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];<span class="comment">//泛型不能实例化对象，但是可以类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否满了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (stack.length == <span class="built_in">this</span>.top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.top == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//判断栈是否已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="built_in">this</span>.stack = Arrays.copyOf(stack,<span class="number">2</span>*stack.length);<span class="comment">//满了就扩容成原来容量的两倍</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.stack[<span class="built_in">this</span>.top] = value;<span class="comment">//给top位置添加元素</span></span><br><span class="line">        <span class="built_in">this</span>.top++;<span class="comment">//top指针指向下一可用空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈操作，并返回弹出（删除）栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.top-<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.top--;</span><br><span class="line">        <span class="keyword">return</span> ret;<span class="comment">//返回删除的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到栈顶元素，但是不删除</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回栈顶元素，不删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stack[top-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示栈元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top-<span class="number">1</span>; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            System.out.print(stack[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-手动实现队列"><a href="#2-手动实现队列" class="headerlink" title="2.手动实现队列"></a>2.手动实现队列</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">//队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.first == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//尾插法，要判断是否第一次插入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.first == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.first = node;</span><br><span class="line">            <span class="built_in">this</span>.last = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.last.setNext(node);</span><br><span class="line">            <span class="built_in">this</span>.last = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="built_in">this</span>.first.getVal();</span><br><span class="line">        <span class="built_in">this</span>.first = <span class="built_in">this</span>.first.getNext();</span><br><span class="line">        <span class="keyword">return</span> ret;<span class="comment">//返回出队元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到队头元素但是不删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不要移动first</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.first.getVal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.first;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.getVal()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-手动实现栈&quot;&gt;&lt;a href=&quot;#1-手动实现栈&quot; class=&quot;headerlink&quot; title=&quot;1. 手动实现栈&quot;&gt;&lt;/a&gt;1. 手动实现栈&lt;/h3&gt;&lt;blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="java基础" scheme="https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的MVCC</title>
    <link href="https://gwtt.github.io/2022/08/30/Mysql%E7%9A%84MVCC/"/>
    <id>https://gwtt.github.io/2022/08/30/Mysql%E7%9A%84MVCC/</id>
    <published>2022-08-30T07:06:22.000Z</published>
    <updated>2022-08-30T09:32:54.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><blockquote><p><strong><code>MVCC</code><strong>，全称 <code>Multi-Version Concurrency Control</code> ，即多版本并发控制。</strong>mvcc</strong>，它是一种并发控制方法，一般在数据库管理系统中，实现数据库的并发访问，在编程语言中实现事务内存。</p><p><strong>总结：</strong>主要为了提升并发性能</p></blockquote><h3 id="为什么需要MVCC"><a href="#为什么需要MVCC" class="headerlink" title="为什么需要MVCC"></a>为什么需要MVCC</h3><blockquote><p><strong>数据库原生的锁</strong><br>        最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。</p><p><strong>读写锁的出现</strong><br>        读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够</p><p><strong>mvcc概念出现</strong><br>        能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能</p></blockquote><h3 id="MVCC适用于的事务隔离级别"><a href="#MVCC适用于的事务隔离级别" class="headerlink" title="MVCC适用于的事务隔离级别"></a>MVCC适用于的事务隔离级别</h3><blockquote><p>MVCC只在 READ COMMITTED (读取已提交) 和 REPEATABLE READ (可重复读) 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED (读取未提交) 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE (可串行化) 则会对所有读取的行都加锁。</p></blockquote><h3 id="MVCC实现原理✔"><a href="#MVCC实现原理✔" class="headerlink" title="MVCC实现原理✔"></a>MVCC实现原理✔</h3><blockquote><p><strong>MVCC</strong>的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <strong><code>3个隐式字段</code><strong>，</strong><code>undo日志</code></strong> ，**<code>Read View</code>** 来实现的。</p><h3 id="3个隐式字段"><a href="#3个隐式字段" class="headerlink" title="3个隐式字段"></a>3个隐式字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`DB_TRX_ID`, `DB_ROLL_PTR`, `DB_ROW_ID</span><br></pre></td></tr></table></figure><table><thead><tr><th>列名</th><th>长度（字节）</th><th>作用</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>6</td><td>插入或更新行的最后一个事务的事务标识符。（删除视为更新，将其标记为已删除）</td></tr><tr><td>DB_ROLL_PTR</td><td>7</td><td>写入回滚段的撤销日志记录（若行已更新，则撤销日志记录包含在更新之前重建行内容所需的信息）</td></tr><tr><td>DB_ROW_ID</td><td>6</td><td>行标识（隐藏单调自增id）</td></tr></tbody></table><p>比如:</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><p> <code>DB_ROW_ID</code> 是数据库默认为该行记录生成的唯一隐式主键，<code>DB_TRX_ID</code> 是当前操作该记录的事务 ID ,而 <code>DB_ROLL_PTR</code> 是一个回滚指针，用于配合 undo日志，指向上一个旧版本</p><p> <strong>事务A：</strong>对数据进行了修改（将name中的张三改为李四）</p><ul><li>第一步：用<strong>排他锁</strong>锁定这一条记录</li></ul><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><ul><li> 第二步：UNDOLOG会记录日志，作为旧记录，既在 <code>undo log</code> 中有当前行的拷贝副本</li></ul><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><ul><li> 第三步：将回滚指针的值copy到UNDOLOG中</li></ul><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR(这就是存储回滚指针的值)</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>ox29349384</td></tr></tbody></table><ul><li>第四步：修改当前的name值并且修改隐藏字段的事务 ID 为当前<code>事务 1</code>的 ID, 我们默认从 <code>1</code> 开始，之后递增，回滚指针指向拷贝到 <code>undo log</code> 的副本记录，既表示我的上一个版本就是它</li></ul><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR(这就是存储回滚指针的值)</th></tr></thead><tbody><tr><td>1</td><td>李四</td><td>18</td><td>1</td><td>1</td><td>ox29349384</td></tr></tbody></table><p><strong>事务B：</strong>事务A修改但未提交，同时对事务B也对该行数据做了修改</p><p>下表就是事务B做出的改变（改变的是年龄）</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td><strong>30</strong></td><td>1</td><td>2</td><td>ox23874982</td></tr></tbody></table><p>  上表的ox23874982指的地址是下表的地址</p><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>1</td><td>ox29349384</td></tr></tbody></table><p>上表的ox29349384指的地址是下表的地址</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><p>所以总结:</p><p>如果有当前事务，最早事务，最晚事务</p><p>最早事务ID&lt;当前事务ID&lt;最晚事务ID</p><ul><li>事务的排他锁形式修改数据</li><li>修改之前先把数据放到undolog，通过回滚指针关联</li><li>失败了从undolog回滚</li></ul></blockquote><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><blockquote><p>insert undo log<br>代表事务在 insert 新记录时产生的 undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>update undo log<br>事务在进行 update 或 delete 时产生的 undo log ; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除<br>在不考虑redo log 的情况下利用undo log工作的简化过程为：</p><table><thead><tr><th>序号</th><th>动作</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td></tr><tr><td>2</td><td>记录数据行数据快照到undolog</td></tr><tr><td>3</td><td>更新数据</td></tr><tr><td>4</td><td>将undolog写到磁盘</td></tr><tr><td>5</td><td>将数据写到磁盘</td></tr><tr><td>6</td><td>提交事务</td></tr></tbody></table><p> 1）为了保证数据的持久性数据要在事务提交之前持久化</p><p> 2）undo log的持久化必须在在数据持久化之前，这样才能保证系统崩溃时，可以用undo log来回滚事务</p></blockquote><h3 id="执行流程如下："><a href="#执行流程如下：" class="headerlink" title="执行流程如下："></a><strong>执行流程如下：</strong></h3><blockquote><p>*<em>一、比如一个有个事务插入 persion 表插入了一条新记录，记录如下，<code>name</code> 为 小明 , <code>age</code> 为 10 岁，*</em><code>隐式主键</code>*<em>是 1，*</em><code>事务 ID</code>*<em>和*</em><code>回滚指针</code>*<em>，我们假设为 NULL</em>*</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830171156856.png" alt="image-20220830171156856"></p><p><strong>二、 现在来了一个事务 1对该记录的 name 做出了修改，改为 小红</strong></p><ul><li>在<code>事务 1</code>修改该行(记录)数据时，数据库会先对该行加<code>排他锁</code></li></ul><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830171325637.png" alt="image-20220830171325637"></p><ul><li>然后把该行数据拷贝到 <code>undo log</code> 中，作为旧记录，既在 <code>undo log</code> 中有当前行的拷贝副本</li></ul><p>Undo日志</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172747995.png" alt="image-20220830172747995"></p><ul><li><p>拷贝完毕后，修改该行<code>name</code>为小红，并且修改隐藏字段的事务 ID 为当前<code>事务 1</code>的 ID, 我们默认从 <code>1</code> 开始，之后递增，回滚指针指向拷贝到 <code>undo log</code> 的副本记录，既表示我的上一个版本就是它</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172826227.png" alt="image-20220830172826227"></p><p>上个表的回滚指针地址指的是下个表</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172852127.png" alt="image-20220830172852127"></p></li><li><p>事务提交后，释放锁</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是MVCC&quot;&gt;&lt;a href=&quot;#什么是MVCC&quot; class=&quot;headerlink&quot; title=&quot;什么是MVCC&quot;&gt;&lt;/a&gt;什么是MVCC&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;MVCC&lt;/code&gt;&lt;strong&gt;，全称 </summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>聚集索引和非聚集索引</title>
    <link href="https://gwtt.github.io/2022/08/29/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    <id>https://gwtt.github.io/2022/08/29/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/</id>
    <published>2022-08-29T08:51:49.429Z</published>
    <updated>2022-08-29T09:10:55.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><h3 id="什么是聚集索引"><a href="#什么是聚集索引" class="headerlink" title="什么是聚集索引"></a>什么是聚集索引</h3><blockquote><p>聚集索引是将<strong>索引列字段</strong>和<strong>行记录数据</strong>维护在了一起,它的叶子节点存储的是 <strong>索引列字段 + 完整的行记录数据</strong>,通过聚集索引能直接获取到整行数据</p><p>Innodb 的主键索引就是基于聚集索引实现的</p><p>通俗点讲:利用聚集索引可以<strong>直接</strong>获取对应的元素数据</p><p><img src="https://img2022.cnblogs.com/blog/1636535/202204/1636535-20220427020132699-1363305095.png" alt="img"></p></blockquote><h3 id="什么是非聚集索引"><a href="#什么是非聚集索引" class="headerlink" title="什么是非聚集索引"></a>什么是非聚集索引</h3><blockquote><p>非聚集索引是相比较于聚集索引来说,它是把<strong>索引和行数据分开维护</strong>,叶子节点并没有包含完整的数据记录(叶子节点的数据区存储的是聚集索引的 id 或 数据的磁盘地址)Mysql 非聚集索引底层的数据结构也是 b+ 树,例如 Myisam 的索引、Innodb 的辅助索引</p><p><img src="https://img2022.cnblogs.com/blog/1636535/202204/1636535-20220428224329312-1207567303.png" alt="img"></p><p>比如在搜索年龄为41的数据时，会找到13，然后再去找利用聚集索引找主键为13的数据</p></blockquote><h3 id="回表（尽量去减少回表的产生）"><a href="#回表（尽量去减少回表的产生）" class="headerlink" title="回表（尽量去减少回表的产生）"></a>回表（尽量去减少回表的产生）</h3><blockquote><p>当通过非聚集索引来查询数据时,存储引擎会根据索引字段定位到最底层的叶子节点,并通过叶子节点获得指向主键索引的主键 id,然后通过主键 id 去主键索引(聚集索引)上找到一个完整的行记录.这个过程被称为 <strong>回表</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;聚集索引和非聚集索引&quot;&gt;&lt;a href=&quot;#聚集索引和非聚集索引&quot; class=&quot;headerlink&quot; title=&quot;聚集索引和非聚集索引&quot;&gt;&lt;/a&gt;聚集索引和非聚集索引&lt;/h2&gt;&lt;h3 id=&quot;什么是聚集索引&quot;&gt;&lt;a href=&quot;#什么是聚集索引&quot; class</summary>
      
    
    
    
    <category term="数据库" scheme="https://gwtt.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
    <category term="索引" scheme="https://gwtt.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>jdk动态代理和cglib动态代理</title>
    <link href="https://gwtt.github.io/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://gwtt.github.io/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2022-08-28T08:32:02.000Z</published>
    <updated>2022-08-28T11:54:16.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两者有何区别"><a href="#两者有何区别" class="headerlink" title="两者有何区别"></a>两者有何区别</h2><p>1、<strong>Jdk动态代理</strong>：利用拦截器（必须实现InvocationHandler接口）加上<strong>反射机制</strong>生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理</p><blockquote><p>JDK动态代理主要是通过，反射包中的Porxy类和InvokationHandler接口。它们结合在一起后可以创建动态代理类。Porxy类基于传递的参数创建动态代理类。InvokationHandler则用于激发动态代理类的方法。这个过程是在程序执行过程中动态生成与处理的，所以叫动态代理。</p></blockquote><p>2、 <strong>Cglib动态代理</strong>：利用ASM框架，对代理对象类生成的class文件加载进来，通过<strong>修改其字节码生成子类来进行代理</strong></p><p><strong>所以：</strong></p><ul><li><strong>如果想要实现JDK动态代理那么代理类必须实现接口，否则不能使用;</strong></li><li><strong>如果想要使用CGlib动态代理，那么代理类不能使用final修饰类和方法；</strong></li></ul><p>还有： 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理。</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="JDk动态代理例子"><a href="#JDk动态代理例子" class="headerlink" title="JDk动态代理例子"></a>JDk动态代理例子</h2><blockquote><p><strong>UserService接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新用户信息&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserProxy代理类，实现InvocationHandler接口重写invoke方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;记录日志&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserProxy</span> <span class="variable">userProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProxy</span>(impl);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(impl.getClass().getClassLoader(),impl.getClass().getInterfaces(),userProxy);</span><br><span class="line">        userService.addUser();</span><br><span class="line">        userService.updateUser(<span class="string">&quot;：我是滚韬&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20220828185237100.png" alt="image-20220828185237100"></p></blockquote><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><blockquote><p>首先要加入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(<span class="type">boolean</span> throwException)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello everyone!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(throwException)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;test exception&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现MethodInterceptor接口"><a href="#实现MethodInterceptor接口" class="headerlink" title="实现MethodInterceptor接口"></a>实现MethodInterceptor接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">     <span class="comment">//要代理的原始对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = target;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(<span class="built_in">this</span>.obj.getClass());<span class="comment">// 设置代理目标</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);<span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setClassLoader(target.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 前置通知</span></span><br><span class="line">            before();</span><br><span class="line">            result = proxy.invokeSuper(obj, args);</span><br><span class="line">            <span class="comment">// 后置通知</span></span><br><span class="line">            after();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            exception();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            beforeReturning();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after method invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exception</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method invoke exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">beforeReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before returning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) cglibProxy.createProxy(hello);</span><br><span class="line">        String result=proxy.sayHello(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="两个动态代理的使用场景是哪里"><a href="#两个动态代理的使用场景是哪里" class="headerlink" title="两个动态代理的使用场景是哪里"></a>两个动态代理的使用场景是哪里</h2><blockquote><p>我们主要是在Spring Aop项目中去使用它们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">     Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">     <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">              <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果</span></span><br><span class="line">     <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="number">1</span>、如果目标对象实现了接口，默认情况下会采用JDK的动态代理</span><br><span class="line">&gt;<span class="number">2</span>、如果目标对象实现了接口，也可以强制使用CGLIB</span><br><span class="line">&gt;<span class="number">3</span>、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</span><br></pre></td></tr></table></figure><h4 id="如果需要强制使用CGLIB来实现AOP，需要配置spring-aop-proxy-target-class-true或-EnableAspectJAutoProxy-proxyTargetClass-true"><a href="#如果需要强制使用CGLIB来实现AOP，需要配置spring-aop-proxy-target-class-true或-EnableAspectJAutoProxy-proxyTargetClass-true" class="headerlink" title="如果需要强制使用CGLIB来实现AOP，需要配置spring.aop.proxy-target-class=true或**@EnableAspectJAutoProxy(proxyTargetClass = true**"></a>如果需要强制使用CGLIB来实现AOP，需要配置<strong>spring.aop.proxy-target-class=true</strong>或**@EnableAspectJAutoProxy(proxyTargetClass = true**</h4></blockquote><h2 id="补充-Porxy类"><a href="#补充-Porxy类" class="headerlink" title="(补充)Porxy类"></a>(补充)Porxy类</h2><p>Porxy类提供了一个静态方法创建动态代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,           </span></span><br><span class="line"><span class="params">    Class&lt;?&gt;[] interfaces,                                      </span></span><br><span class="line"><span class="params">    InvocationHandler h)</span></span><br><span class="line"><span class="keyword">throws</span> IllegalArgumentException</span><br></pre></td></tr></table></figure><p>1、ClassLoader：</p><blockquote><p>ClassLoader会定义动态代理类，ClassLoader可以通过类或者接口获得，如果我们想通过接口获得，调用方法如下。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.class.getClassLoader()</span><br></pre></td></tr></table></figure><p>如果通过类来获得，加入我们有一个类TaskImpl实现了Task接口，我们有个TaskImpl的对象ob，然后ClassLoader获取方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob.getClassLoader()</span><br></pre></td></tr></table></figure><p>2、 Class&lt;?&gt;[] interfaces：动态代理类需要实现的接口</p><p>3、InvocationHandler：传递一个实现了InvokationHandler接口的类的实例</p><blockquote><p>InvokationHandler是Java 反射包里面的一个接口。InvokationHandler通过用户类来实现，来激发一个动态代理类的方法。它只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>    <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure><p>1、Object：实现方法的代理对象 </p><p>2、Method：代理实例激发的方法，Porxy参数中的接口方法 </p><p>3、Object[]：传递给方法的一系列参数</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两者有何区别&quot;&gt;&lt;a href=&quot;#两者有何区别&quot; class=&quot;headerlink&quot; title=&quot;两者有何区别&quot;&gt;&lt;/a&gt;两者有何区别&lt;/h2&gt;&lt;p&gt;1、&lt;strong&gt;Jdk动态代理&lt;/strong&gt;：利用拦截器（必须实现InvocationHandler</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="动态代理" scheme="https://gwtt.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>手写生产者消费者模式</title>
    <link href="https://gwtt.github.io/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwtt.github.io/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-27T11:47:36.000Z</published>
    <updated>2022-08-28T08:27:27.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生产者-消费者模式设计要求"><a href="#生产者-消费者模式设计要求" class="headerlink" title="生产者-消费者模式设计要求"></a>生产者-消费者模式设计要求</h3><p>这种模式满足三点要求：<br>（1）生产者生产数据到缓冲区中，消费者从缓冲区中取数据。<br>（2）缓冲区满时，生产者线程阻塞，进入等待状态。这期间消费者一旦取走数据，队列未满，就会唤醒阻塞的生产者。<br>（3）缓冲区空时，消费者线程阻塞，进入等待状态。这期间生产者一旦往队列中放入数据，就会唤醒阻塞的消费者。</p><blockquote><p>模式组成：<br>公共的缓存队列（给予缓存上限）+ 生产者线程 + 消费者线程。<br>特点：<br>1.实现了生产者、消费者的解耦：通过共享的数据缓冲区域，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。<br>2.实现了线程间的并发协作：如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；如果共享数据区为空的话，阻塞消费者继续消费数据。<br>应用场景：<br>模式解耦、消息队列、分布式场景中很常见。</p></blockquote><p>通常情况下，有5种方式来实现</p><ul><li>synchronized + wait() + notify() 方式</li><li>可重入锁ReentrantLock （配合Condition）</li><li>BlockingQueue 阻塞队列方式</li><li>信号量Semaphore 方式</li><li>管道输入输出流PipedInputStream和PipedOutputStream 方式</li></ul><h3 id="第一种方式（synchronized-）"><a href="#第一种方式（synchronized-）" class="headerlink" title="第一种方式（synchronized ）"></a>第一种方式（synchronized ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.maxSize = size;</span><br><span class="line">queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == maxSize) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列已满，生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;队列未满，生产者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;放入数据&quot;</span> + i);</span><br><span class="line"><span class="keyword">if</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列为空，消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == maxSize) &#123;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;队列有数据，消费者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;取出数据&quot;</span> + queue.remove());<span class="comment">//删除第一个数据，最早放入的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueue myBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(MyBlockingQueue myBlockingQueue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueue = myBlockingQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueue.put();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueue myBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(MyBlockingQueue myBlockingQueue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueue = myBlockingQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueue.take();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">producer_consumer_1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyBlockingQueue</span> <span class="variable">myBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBlockingQueue</span>(<span class="number">8</span>);</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(myBlockingQueue);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();<span class="comment">//生产者线程1，Thread-0</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer2).start();<span class="comment">//生产者线程2，Thread-1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();<span class="comment">//消费者线程1，Thread-3</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer2).start();<span class="comment">//消费者线程2，Thread-4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgwNzgw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><blockquote><p>补充说明：<br>1.使用Linkedlist+等待唤醒机制（wait、notify/notifyAll）+Synchronized实现线程安全。</p><p>2.为什么使用while不是if？</p><p>判断线程是否进入等待状态时，判断需要while，不能用if。在生产者、消费者线程只有一个时，if可以使用。但是多个线程的情况时就会出现问题。</p><p>例如：假设有两个消费者线程，一个生产者线程。队列为空时，消费者1进入等待状态，释放锁。消费者2抢到锁，进去后判断也进入等待，释放锁。这时生产者抢到锁生产数据，队列中有数据了，反过来唤醒两个消费者。<br>消费者1抢到锁执行wait()的逻辑，取出数据并释放锁。这时消费者2拿到锁，执行wait()后的逻辑取数据，但是此时队列中的数据已经被消费者1取出了，没有数据，这时就会出现线程不安全的情况。<br>利用while实现多次判断，不管消费者1还是2抢到锁，执行循环体的逻辑之前，会再一次判断条件是否成立，而if不会，所以使用while。</p></blockquote><h3 id="第二种方式（ReentrantLock-）"><a href="#第二种方式（ReentrantLock-）" class="headerlink" title="第二种方式（ReentrantLock ）"></a>第二种方式（ReentrantLock ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueueForCondition</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyBlockingQueueForCondition</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.max = max;</span><br><span class="line">queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == max) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列已满，生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">notFull.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">notEmpty.signalAll();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;队列未满，生产者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;放入数据&quot;</span> + i);</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列为空，消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">notEmpty.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == max) &#123;</span><br><span class="line">notFull.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">System.out.println(<span class="string">&quot;队列有数据，消费者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;取出数据&quot;</span> + i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerForCondition</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueueForCondition myBlockingQueueForCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerForCondition</span><span class="params">(MyBlockingQueueForCondition myBlockingQueueForCondition)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueueForCondition = myBlockingQueueForCondition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueueForCondition.put(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerForCondition</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueueForCondition myBlockingQueueForCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsumerForCondition</span><span class="params">(MyBlockingQueueForCondition myBlockingQueueForCondition)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueueForCondition = myBlockingQueueForCondition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueueForCondition.take();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">producer_consumer_2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">MyBlockingQueueForCondition</span> <span class="variable">myBlockingQueueForCondition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBlockingQueueForCondition</span>(<span class="number">8</span>);</span><br><span class="line"><span class="type">ProducerForCondition</span> <span class="variable">producerForCondition1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ProducerForCondition</span> <span class="variable">producerForCondition2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ConsumerForCondition</span> <span class="variable">consumerForCondition1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ConsumerForCondition</span> <span class="variable">consumerForCondition2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producerForCondition1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producerForCondition2).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumerForCondition1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumerForCondition2).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgwNzgw,size_16,color_FFFFFF,t_70-16616110494823.png" alt="在这里插入图片描述"></p><h3 id="第三种方式（BlockingQueue-）"><a href="#第三种方式（BlockingQueue-）" class="headerlink" title="第三种方式（BlockingQueue ）"></a>第三种方式（BlockingQueue ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueueTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer1).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;生产数据：&quot;</span> + element);</span><br><span class="line">queue.put(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">element</span> <span class="operator">=</span> (Integer) queue.take();</span><br><span class="line">System.out.println(<span class="string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;消费数据：&quot;</span> + element);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;生产者-消费者模式设计要求&quot;&gt;&lt;a href=&quot;#生产者-消费者模式设计要求&quot; class=&quot;headerlink&quot; title=&quot;生产者-消费者模式设计要求&quot;&gt;&lt;/a&gt;生产者-消费者模式设计要求&lt;/h3&gt;&lt;p&gt;这种模式满足三点要求：&lt;br&gt;（1）生产者生产数据到</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈股票dp问题</title>
    <link href="https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/"/>
    <id>https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-23T09:40:23.000Z</published>
    <updated>2022-08-23T16:03:13.801Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在力扣算题时，遇到股票题，觉得很有意思，于是写下自己的总结</p><h3 id="1-第一个股票问题（一次买卖）"><a href="#1-第一个股票问题（一次买卖）" class="headerlink" title="1.第一个股票问题（一次买卖）"></a>1.第一个股票问题（一次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823215745512.png" alt="image-20220823215745512"></p><blockquote><p> 首先是最简单的题目，只有一次购买，一次卖出</p><p>思路还是挺清晰的，还是DP思想：</p><ol><li>记录【今天之前买入的最小值】</li><li>计算【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】</li><li>比较【每天的最大获利】，取最大值即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当然因为我们只是用二维数组保存了两个状态，有股票和没股票，所以可以简化一下</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> prices.length;</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>,dp1 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp0 = Math.max(dp0,dp1 + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp1 = Math.max(dp1,-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回没股票的时候</span></span><br><span class="line">            <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，没股票可以从昨天的有股票卖出，或者昨天的没股票得出（当然我们要尽量去获取最大值，毕竟利润最大），有股票可以是<strong>买今天的，或者昨天的有股票得到。</strong></p></blockquote><h3 id="2-第二个股票问题（多次买卖）"><a href="#2-第二个股票问题（多次买卖）" class="headerlink" title="2.第二个股票问题（多次买卖）"></a>2.第二个股票问题（多次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823222025568.png" alt="image-20220823222025568"></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将dp[i-<span class="number">1</span>][<span class="number">0</span>] 和dp[i-<span class="number">1</span>][<span class="number">1</span>] 存放在两个变量中，通过它们计算出 dp[i][<span class="number">0</span>] 和 dp[i][<span class="number">1</span>] 并存回对应的变量，以便于第 i+<span class="number">1</span> 天的状态转移即可。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>,dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp0 = Math.max(dp0,dp1 + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp1 = Math.max(dp1,dp0 - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回没股票的时候</span></span><br><span class="line">            <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比第一题，<strong>这题多了一个条件，可以多次买卖。</strong></p><p>总之，没股票可以从昨天的有股票卖出，或者昨天的没股票得出（当然我们要尽量去获取最大值，毕竟利润最大），有股票可以是<strong>从之前没股票的状态买今天的（之前的是不能的，只能是买一次），或者昨天的有股票得到。</strong></p></blockquote><h3 id="3-第三个股票问题（两次买卖）"><a href="#3-第三个股票问题（两次买卖）" class="headerlink" title="3.第三个股票问题（两次买卖）"></a>3.第三个股票问题（两次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823230742789.png" alt="image-20220823230742789"></p><blockquote><p>相比第二问，加了条只能买卖两次的设定，这使得我们必须要记录下数次交易中的两次最大值，所以我们必须新加状态进行购买次数的限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">一天结束时，可能有持股、可能未持股、可能卖出过<span class="number">1</span>次、可能卖出过<span class="number">2</span>次、也可能未卖出过</span><br><span class="line"></span><br><span class="line">所以定义状态转移数组dp[天数][当前是否持股][卖出的次数]</span><br><span class="line"></span><br><span class="line">具体一天结束时的<span class="number">6</span>种状态：</span><br><span class="line"></span><br><span class="line">未持股，未卖出过股票：说明从未进行过买卖，利润为<span class="number">0</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">未持股，卖出过<span class="number">1</span>次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>]=max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">未持股，卖出过<span class="number">2</span>次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">2</span>]=max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>]=max(dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">持股，卖出过<span class="number">1</span>次股票：可能是今天买的，也可能是之前买的（昨天也持股）</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>]=max(dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">持股，卖出过<span class="number">2</span>次股票：最多交易<span class="number">2</span>次，这种情况不存在</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">2</span>]=<span class="type">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfitDP</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值Integer.MIN_VALUE-1=Integer.MAX_VALUE</span></span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//持有昨天的股票，或者昨天没买，今天买了</span></span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">2</span>] = MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.max(<span class="number">0</span>, Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大神版</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一天考虑四个变量:</span></span><br><span class="line"><span class="comment">        fstBuy: 在该天第一次买入股票可获得的最大收益 </span></span><br><span class="line"><span class="comment">        fstSell: 在该天第一次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secBuy: 在该天第二次买入股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secSell: 在该天第二次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        分别对四个变量进行相应的更新, 最后secSell就是最大</span></span><br><span class="line"><span class="comment">        收益值(secSell &gt;= fstSell)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fstBuy</span> <span class="operator">=</span> Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">secBuy</span> <span class="operator">=</span> Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p : prices) &#123;</span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上也是考察的是对于状态的分析变化，需要我们理清昨天和今天的状态关系</p></blockquote><h3 id="4-第四个股票问题（k次买卖）"><a href="#4-第四个股票问题（k次买卖）" class="headerlink" title="4.第四个股票问题（k次买卖）"></a>4.第四个股票问题（k次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823233637735.png" alt="image-20220823233637735"></p><blockquote><p>其实套路跟第三题一模一样，只是要求我们发现创建dp数组的规律</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>][k+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值,防止数据溢出</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>][i] = dp[<span class="number">0</span>][<span class="number">1</span>][i] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>][i] = dp[<span class="number">0</span>][<span class="number">1</span>][i] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;l&lt;=k;l++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j==<span class="number">0</span>&amp;&amp;l==<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=<span class="number">0</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>&amp;&amp;l==k)&#123;</span><br><span class="line">                            dp[i][j][l]=MIN_VALUE;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][l-<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][l]);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>][l]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][l]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">                max=Math.max(max,dp[prices.length-<span class="number">1</span>][<span class="number">0</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-第二个股票问题加上冷冻期"><a href="#5-第二个股票问题加上冷冻期" class="headerlink" title="5.第二个股票问题加上冷冻期"></a>5.第二个股票问题加上冷冻期</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823234119843.png" alt="image-20220823234119843"></p><blockquote><p>题目中定义的“冷冻期”=卖出的那一天的后一天，题目设置冷冻期的意思是，<strong>如果昨天卖出了，今天不可买入</strong>，那么关键在于哪一天卖出，只要在今天想买入的时候判断一下前一天是不是刚卖出，即可，所以关键的一天其实是卖出的那一天，而不是卖出的后一天</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//0代表不持股且当天没卖出</span></span><br><span class="line">        <span class="comment">//1代表持股</span></span><br><span class="line">        <span class="comment">//2代表不持股且当天卖出</span></span><br><span class="line">        <span class="type">int</span> [][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//从[1]...[n-1]</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">0</span>],dp[n-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者在力扣算题时，遇到股票题，觉得很有意思，于是写下自己的总结&lt;/p&gt;
&lt;h3 id=&quot;1-第一个股票问题（一次买卖）&quot;&gt;&lt;a href=&quot;#1-第一个股票问题（一次买卖）&quot; class=&quot;headerlink&quot; title=&quot;1.第一个股票问题（一次买卖）&quot;&gt;&lt;/a&gt;1.</summary>
      
    
    
    
    <category term="算法" scheme="https://gwtt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试， 动态规划" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>浅谈垃圾回收器</title>
    <link href="https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2022-08-23T02:57:34.000Z</published>
    <updated>2022-08-23T10:37:44.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h1><p>如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直至垃圾回收结束！</p><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251706505-16612506422341.jpeg" alt="img"></p><p>CMS的全称：Concurrent Mark Sweep，翻译过来是<strong>并发标记清除</strong></p><p>用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是<strong>并发</strong>：在GC线程工作的时候，用户线程<strong>不会完全停止</strong>，用户线程在<strong>部分场景下</strong>与GC线程一起并发执行。</p><p>但是，要理解的是，无论是什么垃圾收集器，Stop The World是一定无法避免的！</p><p>CMS只是在<strong>部分</strong>的GC场景下可以让GC线程与用户线程并发执行</p><p>CMS的设计目标是为了避免<strong>老年代 GC</strong>出现<strong>长时间</strong>的卡顿（Stop The World）</p><h2 id="CMS的工作流程"><a href="#CMS的工作流程" class="headerlink" title="CMS的工作流程"></a>CMS的工作流程</h2><p>CMS可以简单分为5个步骤：初始标记、并发标记、（并发预清理）、重新标记以及并发清除</p><p>从步骤就不难看出，CMS主要是实现了<strong>标记清除</strong>垃圾回收算法</p><h2 id="初始标记的过程"><a href="#初始标记的过程" class="headerlink" title="初始标记的过程"></a>初始标记的过程</h2><p><strong>初始标记</strong>会标记GCRoots<strong>直接关联</strong>的对象以及<strong>年轻代</strong>指向<strong>老年代</strong>的对象</p><p><strong>初始标记</strong>这个过程是会发生Stop The World的。但这个阶段的速度算是很快的，因为没有<strong>向下追溯</strong>（只标记一层）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251706562.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251706562.jpeg" alt="img"></a></p><h2 id="并发标记的过程"><a href="#并发标记的过程" class="headerlink" title="并发标记的过程"></a>并发标记的过程</h2><p>在<strong>初始标记</strong>完了之后，就进入了<strong>并发标记</strong>阶段啦</p><p><strong>并发标记</strong>这个过程是不会停止用户线程的（不会发生 Stop The World）。这一阶段主要是从GC Roots向下<strong>追溯</strong>，标记所有可达的对象。</p><p><strong>并发标记</strong>在GC的角度而言，是比较耗费时间的（需要追溯）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707207.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707207.jpeg" alt="img"></a></p><p><strong>并发标记</strong>这个阶段完成之后，就到了<strong>并发预处理</strong>阶段啦</p><p><strong>并发预处理</strong>这个阶段主要想干的事情：希望能减少下一个阶段<strong>重新标记</strong>所消耗的时间</p><p>因为下一个阶段<strong>重新标记</strong>是需要Stop The World的</p><p><strong>并发标记</strong>这个阶段由于用户线程是没有被挂起的，所以对象是有可能发生变化的</p><p>可能有些对象，从新生代晋升到了老年代。可能有些对象，直接分配到了老年代（大对象）。可能老年代或者新生代的对象引用发生了变化…</p><h2 id="跨代引用的问题"><a href="#跨代引用的问题" class="headerlink" title="跨代引用的问题"></a>跨代引用的问题</h2><p>针对老年代的对象，其实还是可以借助类card table的存储（将老年代对象发生变化所对应的卡页标记为dirty）</p><p>所以<strong>并发预处理</strong>这个阶段会扫描可能由于<strong>并发标记</strong>时导致老年代发生变化的对象，会再扫描一遍标记为dirty的卡页</p><p>对于新生代的对象，我们还是得遍历新生代来看看在<strong>并发标记</strong>过程中有没有对象引用了老年代..</p><p>不过JVM里给我们提供了很多<strong>参数</strong>，有可能在这个过程中会触发一次 minor GC（触发了minor GC 是意味着就可以更少地遍历新生代的对象）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707070.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707070.jpeg" alt="img"></a></p><h2 id="重新标记的过程"><a href="#重新标记的过程" class="headerlink" title="重新标记的过程"></a>重新标记的过程</h2><p><strong>并发预处理</strong>这个阶段阶段结束后，就到了<strong>重新标记</strong>阶段</p><p><strong>重新标记</strong>阶段会Stop The World，这个过程的停顿时间其实很大程度上取决于上面<strong>并发预处理</strong>阶段（可以发现，这是一个追赶的过程：一边在标记存活对象，一边用户线程在执行产生垃圾）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707172.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707172.jpeg" alt="img"></a></p><h2 id="并发清除的过程"><a href="#并发清除的过程" class="headerlink" title="并发清除的过程"></a>并发清除的过程</h2><p>最后就是<strong>并发清除</strong>阶段，不会Stop The World</p><p>一边用户线程在执行，一边GC线程在回收不可达的对象</p><p>这个过程，还是有可能用户线程在不断产生垃圾，但只能留到下一次GC 进行处理了，产生的这些垃圾被叫做“浮动垃圾”</p><p>完了以后会重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207252308270.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207252308270.jpeg" alt="img"></a></p><h2 id="CMS的缺点"><a href="#CMS的缺点" class="headerlink" title="CMS的缺点"></a>CMS的缺点</h2><ol><li>空间需要预留：CMS垃圾收集器可以一边回收垃圾，一边处理用户线程，那需要在这个过程中保证有充足的内存空间供用户使用。如果CMS运行过程中预留的空间不够用了，会报错（Concurrent Mode Failure），这时会启动 Serial Old垃圾收集器进行老年代的垃圾回收，会导致停顿的时间很长。显然啦，空间预留多少，肯定是有参数配置的。</li><li><strong>浮动垃圾</strong>：由于垃圾回收和用户线程是同时进行的，在进行标记或者清除的同时，用户的线程还会去改变对象的引用，使得原来某些对象不是垃圾，但是当 CMS 进行清理的时候变成了垃圾，CMS 收集器无法收集，只能等到下一次 GC。CMS 收集器无法处理<strong>浮动垃圾</strong>（Floating Garbage），可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。如果在应用中老年代增长不是太快，可以适当调高参数 - XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。</li><li>内存碎片问题：CMS本质上是实现了<strong>标记清除算法</strong>的收集器（从过程就可以看得出），这会意味着会产生内存碎片。由于碎片太多，又可能会导致内存空间不足所触发full GC，CMS一般会在触发full GC这个过程对碎片进行整理。整理涉及到<strong>移动</strong>/<strong>标记</strong>，那这个过程肯定会Stop The World的，如果内存足够大（意味着可能装载的对象足够多），那这个过程卡顿也是需要一定的时间的。</li></ol><h2 id="补充面试题"><a href="#补充面试题" class="headerlink" title="补充面试题:"></a>补充面试题:</h2><h3 id="1-CMS的过程？"><a href="#1-CMS的过程？" class="headerlink" title="1.CMS的过程？"></a>1.CMS的过程？</h3><blockquote><p>初始标记、并发标记、（并发预清理）、重新标记以及并发清除</p></blockquote><h3 id="2-怎么标记垃圾的？"><a href="#2-怎么标记垃圾的？" class="headerlink" title="2,怎么标记垃圾的？"></a>2,怎么标记垃圾的？</h3><blockquote><p>使用三色标记法</p></blockquote><h3 id="3-什么是三色标记法"><a href="#3-什么是三色标记法" class="headerlink" title="3.什么是三色标记法"></a>3.什么是三色标记法</h3><blockquote><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Nzk4NTU2,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>　三色标记法，是把内存中的对象，标记为3种颜色，分布是：黑、灰、白。(<strong>上文图中的红色仅供参考</strong>)</p><ul><li><p>黑：表示该对象已经扫描到，并且它可触达的对象也已经扫描到；</p></li><li><p>灰：表示该对象已经扫描到，但是它能触发的对象至少还有一个没有扫描到；</p></li><li><p>白：表示该节点没有被扫描到；</p></li></ul></blockquote><h3 id="4-CMS和G1的区别"><a href="#4-CMS和G1的区别" class="headerlink" title="4.CMS和G1的区别"></a>4.CMS和G1的区别</h3><blockquote><ul><li>G1和CMS都分为4个阶段,前三个阶段基本相同都为初始标记,并发标记,再次标记,区别在于最后清除阶段CMS是并发的,G1不是并发的,因此CMS最终会产生浮动垃圾,只能等待下次gc才能清除</li><li>G1可以管理整个堆,而CMS只能作用于老年代,并且CMS在老年代使用的是标记清除算法,会产生内存碎片,而G1使用标记整理算法,不会产生内存碎片</li><li>G1相比于CMS最大的区别是G1将内存划分为大小相等的Region,可以选择垃圾对象多的Region而不是整个堆从而减少STW,同时使用Region可以更精确控制收集,我们可以手动明确一个垃圾回收的最大时间</li></ul></blockquote><h3 id="5-CMS什么时候会STW？为什么要STW（咋瓦鲁多）"><a href="#5-CMS什么时候会STW？为什么要STW（咋瓦鲁多）" class="headerlink" title="5.CMS什么时候会STW？为什么要STW（咋瓦鲁多）?"></a>5.CMS什么时候会STW？为什么要STW（咋瓦鲁多）?</h3><blockquote><p><strong>初始标记和重新标记的时候</strong></p><p>因为初始标记标记的是GC Root，而GC Root容易变动，比如栈帧中的本地变量表。所以需要STW。</p><p>因为在重新标记之前是并发标记，在并发标记的期间会出现漏标和多标的对象，所以为了修正这部分对象，需要在重新标记期间STW。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMS垃圾回收器&quot;&gt;&lt;a href=&quot;#CMS垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;CMS垃圾回收器&quot;&gt;&lt;/a&gt;CMS垃圾回收器&lt;/h1&gt;&lt;p&gt;如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Jvm" scheme="https://gwtt.github.io/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法</title>
    <link href="https://gwtt.github.io/2022/08/20/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://gwtt.github.io/2022/08/20/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-08-20T06:28:34.000Z</published>
    <updated>2022-08-27T11:48:02.950Z</updated>
    
    <content type="html"><![CDATA[<p> 下图展示了十大排序的名字和大致用法 </p><h3 id><a href="#" class="headerlink" title></a><img src="https://pic.leetcode-cn.com/1652691519-SVKUkM-image.png" alt="image.png"></h3><blockquote><p>说到排序，首先要用到就是交换数字，接下来谈谈三次交换方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: 利用临时数tmp</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二: 利用加减运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapCal</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>; <span class="comment">// 若无法保证swapCal被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span></span><br><span class="line">    arr[i] = arr[i] + arr[j]; <span class="comment">// a = a + b</span></span><br><span class="line">    arr[j] = arr[i] - arr[j]; <span class="comment">// b = a - b</span></span><br><span class="line">    arr[i] = arr[i] - arr[j]; <span class="comment">// a = a - b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三: 利用异或运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapXOR</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>; <span class="comment">// 若无法保证swapXOR被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// a = a ^ b，也可写成 arr[i] ^= arr[j];</span></span><br><span class="line">    arr[j] = arr[i] ^ arr[j]; <span class="comment">// b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a， 也可写成 arr[j] ^= arr[i];</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// a = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b， 也可写成 arr[i] ^= arr[j];</span></span><br><span class="line">&#125;</span><br><span class="line">方法一: 利用一个临时数 tmp 来交换 arr[i] ，arr[j] 。</span><br><span class="line">方法二: 利用 arr[i] 和和 arr[j] 的加减运算避免临时数 tmp 的开销，但由于涉及到加减法可能导致数字 「提前溢出」 。</span><br><span class="line">方法三: 利用位运算中的 异或 运算，能够避免 tmp 的开销且不会导致数字溢出。</span><br></pre></td></tr></table></figure></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>从第一位开始向后依次比较，如果前者大则交换（实际根据大小方向），循环arr.length-1次</p><h4 id="最笨的形式"><a href="#最笨的形式" class="headerlink" title="最笨的形式"></a>最笨的形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="提前结束优化"><a href="#提前结束优化" class="headerlink" title="提前结束优化"></a>提前结束优化</h5><p>当某一轮比较均未发生交换，说明排序已完成，可设置一个布尔值记录一轮排序是否有发生交换，若无则提前退出循环结束程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1轮次执行，当前 n - 1 个元素排好后，最后一个元素无需执行，故i &lt; arr.length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 本轮执行是否有交换的标志，若无则false，若有则true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 若左大于右则交换，并将swapped置为true</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无交换，表示当前数组已完全排序，退出大循环</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="冒泡界优化"><a href="#冒泡界优化" class="headerlink" title="冒泡界优化"></a>冒泡界优化</h5><p>记录前一轮交换的最终位置，说明该位置之后的元素为已排序状态，下一轮的交换只需执行到该处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastSwappedIdx</span> <span class="operator">=</span> arr.length - <span class="number">1</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">swappedIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// lastSwappedIdx表示前一轮交换的最终位置，即下标为lastSwappedIdx是未排序部分中的最后一个数的下标，</span></span><br><span class="line">    <span class="comment">// 因此for中的界是i &lt; lastSwappedIdx而不需要写成i &lt;= lastSwappedIdx</span></span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123; <span class="comment">// 当swapped = false时，排序完成</span></span><br><span class="line">        <span class="comment">// 本轮执行是否有交换的标志，若无则true，若有则false</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lastSwappedIdx; i++) &#123;</span><br><span class="line">            <span class="comment">// 若左大于右则交换，并将swapped置为true</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                swappedIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastSwappedIdx = swappedIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n^2)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>每一轮循环选一个最小（或者最大）的数放到第i位，循环arr.length-1次</p><h4 id="单元选择排序"><a href="#单元选择排序" class="headerlink" title="单元选择排序"></a>单元选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1 轮次执行,当前 n - 1 个元素排好后，最后一个元素无需执行，故 i &lt; arr.length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 找到本轮执行中最小的元素，将最小值下标赋值给min</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])  minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若本轮第一个数字不是最小值，则交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双元选择排序"><a href="#双元选择排序" class="headerlink" title="双元选择排序"></a>双元选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectSortDouble(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">// 每轮确定两个数字，因此界也会动态变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span> - i; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i, maxIdx = i;</span><br><span class="line">        <span class="comment">// 找到本轮执行中最小和最大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) minIdx = j;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[maxIdx]) maxIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若本轮最大值等于最小值，说明未排序部分所有元素相等，无需再排序</span></span><br><span class="line">        <span class="keyword">if</span>(minIdx == maxIdx) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 若本轮第一个数字不是最小值，则交换位置（将最小值与本轮第一个数字交换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) swap(arr, i, minIdx);</span><br><span class="line">        <span class="comment">// 在交换i和minIdx时，有可能出现i即maxIdx的情况，此时需要修改maxIdx为minIdx</span></span><br><span class="line">        <span class="keyword">if</span>(maxIdx == i) maxIdx = minIdx;</span><br><span class="line">        <span class="comment">// 若本轮最后一个数字不是最大值，则交换位置（将最大值与本轮最后一个数字交换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (maxIdx != n - <span class="number">1</span> - i) swap(arr, n - <span class="number">1</span> - i, maxIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间:O(n^2)</strong></p><p><strong>空间:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>对于待排序数组，从第2个元素开始(称作插入对象元素)，比较它与之前的元素(称作比较对象元素)，当插入对象元素小于比较对象元素时，继续往前比较，直到不小于(≥)比较对象，此时将插入对象元素插入到该次比较对象元素之后。重复这个插入过程直到最后一个元素作为插入对象元素完成插入操作。</p><h4 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// N-1轮次执行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; arr[j]) arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = target; <span class="comment">// 若发生移动，此时的插入对象数字≥j位置的数字，故插入位置为j + 1，若未移动也成立，无需判断</span></span><br><span class="line">        <span class="comment">// if(j != i - 1) arr[j + 1] = target; // 也可以用这种写法，表示发生移动才插入，否则不必插入(赋值)，但不判断效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="折半插入优化-利用二分来减少中间比较次数"><a href="#折半插入优化-利用二分来减少中间比较次数" class="headerlink" title="折半插入优化(利用二分来减少中间比较次数)"></a>折半插入优化(利用二分来减少中间比较次数)</h4><p>注意到插入排序的每一轮向前插入都使得该元素在完成插入后，从第一个元素到该元素是排序状态（指这部分的相对排序状态，在它们中间后续可能还会插入其他数字），利用这一点，对一个新的插入对象向前执行折半插入，能够显著减少比较的次数。另一种优化是增量递减插入排序，也叫希尔排序，将在希尔排序章节中介绍。</p><p>折半插入的关键在于找到插入位置，折半过程代码如下。这实际上是二分查找「模版一」中的「小于等于」情形。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSortBinary(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1 轮次执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 若当前插入对象大于等于前一个对象，无需插入</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &lt;= arr[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">// 折半查找 (二分查找「模版一」)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// while结束后，target要插入的位置为low或high + 1 (low = high + 1)</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[center] &lt;= target) low = center + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = center - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; low; j--) &#123; <span class="comment">// 移动</span></span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = target; <span class="comment">// 插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间:O(n^2)</strong></p><p><strong>空间:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="Shell增量"><a href="#Shell增量" class="headerlink" title="Shell增量"></a>Shell增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序：采用Shell增量 N / 2^k</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortShell(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// gap 初始为 n/2，缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; n; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Hibbard增量"><a href="#Hibbard增量" class="headerlink" title="Hibbard增量"></a>Hibbard增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序： 采用Hibbard增量 &#123;1, 3, 7, 15,...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortHibbard(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n / <span class="number">2</span>) gap = gap * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 初始化gap (Hibbard增量序列)</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// 缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; arr.length; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Knuth增量"><a href="#Knuth增量" class="headerlink" title="Knuth增量"></a>Knuth增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序： 采用Knuth增量 &#123;1, 4, 13, 40,...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortKnuth(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n / <span class="number">3</span>) gap = gap * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 初始化gap (Knuth增量序列)</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123; <span class="comment">// 缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; arr.length; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单插入排序和希尔排序比较</p><p><img src="https://pic.leetcode-cn.com/1653024423-RVrPou-image.png" alt="image.png"></p></blockquote><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序是 <strong>分治思想</strong> 的应用，即将原待排数组 <strong>递归或迭代地</strong> 分为左右两半，直到数组长度为1，然后对左右数组进行合并(merge)，在合并中完成排序。</p><p><strong>自顶向下</strong>(top-down)：从输入数组出发，不断二分该数组，直到数组长度为1，再执行合并。适合用 递归 实现。</p><p><strong>自底向上</strong>(bottom-up)：从输入数组的单个元素出发，一一合并，二二合并，四四合并直到数组有序。适合用 迭代 实现。</p><h4 id="自顶向下非原地归并"><a href="#自顶向下非原地归并" class="headerlink" title="自顶向下非原地归并"></a>自顶向下非原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, tmpArr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, tmpArr, left, center);</span><br><span class="line">        mergeSort(arr, tmpArr, center + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tmpArr, left, center, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原地合并方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> leftPos, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightPos</span> <span class="operator">=</span> leftEnd + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">startIdx</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpPos</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="keyword">while</span> (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[leftPos] &lt;= arr[rightPos]) &#123;</span><br><span class="line">            tmpArr[tmpPos++] = arr[leftPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmpArr[tmpPos++] = arr[rightPos++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后若左数组还有剩余，则将其添加到tmpArr剩余空间</span></span><br><span class="line">    <span class="keyword">while</span> (leftPos &lt;= leftEnd) &#123;</span><br><span class="line">        tmpArr[tmpPos++] = arr[leftPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后若右数组还有剩余，则将其添加到tmpArr剩余空间</span></span><br><span class="line">    <span class="keyword">while</span> (rightPos &lt;= rightEnd) &#123;</span><br><span class="line">        tmpArr[tmpPos++] = arr[rightPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容易遗漏的步骤，将tmpArr拷回arr中</span></span><br><span class="line">    <span class="comment">// 从小区间排序到大区间排序，大区间包含原来的小区间，需要从arr再对应比较排序到tmpArr中，</span></span><br><span class="line">    <span class="comment">// 所以arr也需要动态更新为排序状态，即随时将tmpArr拷回到arr中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt;= rightEnd; i++) &#123;</span><br><span class="line">        arr[i] = tmpArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自顶向下原地归并"><a href="#自顶向下原地归并" class="headerlink" title="自顶向下原地归并"></a>自顶向下原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, center);</span><br><span class="line">        mergeSort(arr, center + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, center, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地归并（手摇算法）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> leftPos, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftPos, j = leftEnd + <span class="number">1</span>; <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt;= arr[j]) i++; <span class="comment">// #2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j; <span class="comment">// #3</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= rightEnd &amp;&amp; arr[j] &lt; arr[i]) j++; <span class="comment">// #4 注意是 arr[j] &lt; arr[i]，即找到j使得arr[j] 为第一个大于等于 arr[i]值</span></span><br><span class="line">        exchange(arr, i, index - <span class="number">1</span>, j - <span class="number">1</span>); <span class="comment">// #5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三次翻转实现交换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    reverse(arr, left, leftEnd);</span><br><span class="line">    reverse(arr, leftEnd + <span class="number">1</span>, rightEnd);</span><br><span class="line">    reverse(arr, left, rightEnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        swap(arr, start, end);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自底向上非原地归并"><a href="#自底向上非原地归并" class="headerlink" title="自底向上非原地归并"></a>自底向上非原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSortBU(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="comment">// 间隔，注意不能写成gap &lt; arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; arr.length; gap *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - gap; left += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="comment">// 调用非原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;</span></span><br><span class="line">            merge(arr, tmpArr, left, left + gap - <span class="number">1</span>, Math.min(left + <span class="number">2</span> * gap - <span class="number">1</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自底向上原地归并"><a href="#自底向上原地归并" class="headerlink" title="自底向上原地归并"></a>自底向上原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSortBUInPlace(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 间隔，注意不能写成gap &lt; arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; arr.length; gap *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - gap; left += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="comment">// 调用原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;</span></span><br><span class="line">            merge(arr, left, left + gap - <span class="number">1</span>, Math.min(left + <span class="number">2</span> * gap - <span class="number">1</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p><strong>与归并排序一样，快速排序也是一种利用 分治思想 的排序方法，确定 主轴及分区 是快速排序的核心操作。首先在数组中确定一个主轴元素(下标记为 pivot)，然后将数组分为两部分，小于主轴的放在（确定最终位置的）主轴左侧，大于等于主轴的放在主轴右侧。递归地对主轴左右两侧数组执行这个过程，每次递归都传入待排序数组 arr 和本次要处理的部分的左右界，只处理这个范围内的序列。当所有递归都到达基准情形时，排序完成。因为是原地交换，递归过程中 arr总是在动态排序，递归过程无需返回，为尾递归形式。</strong></p><h4 id="递归快排"><a href="#递归快排" class="headerlink" title="递归快排"></a>递归快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三数取中快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortMedian3(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    quickSortMedian3(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortMedian3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; right) &#123; </span><br><span class="line">        <span class="comment">// 执行median3将左，中，右三数中值放到left位置上</span></span><br><span class="line">        median3(arr, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortMedian3(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortMedian3(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将left, center, right下标三个数中，大小居中者放到left下标处</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">median3</span><span class="params">(<span class="type">int</span>[]arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[c]) swap(arr, l, c); <span class="comment">// 左中，大者居中</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[r]) swap(arr, c, r); <span class="comment">// 中右，大者居右，此时最大者居右</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[l]) swap(arr, l, c); <span class="comment">// 左中，大者居左，此时中者居左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机主轴快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortRandom(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSortRandom(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortRandom</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 取区间内随机下标，注意Random().nextInt(int x)方法的使用（含0不含x）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left) + left + <span class="number">1</span>; <span class="comment">// 在[left + 1, right]范围内的随机值</span></span><br><span class="line">        <span class="comment">// 交换随机取得的下标元素与当前起始元素</span></span><br><span class="line">        swap(arr, left, randomIndex); <span class="comment">// arr[left]与它之后的某个数交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortRandom(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortRandom(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素快排(首位为主轴)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortSimple(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    quickSortSimple(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortSimple</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 若left == right，表示此时arr只有一个元素，即为基准情形，完成递归(准确说是完成递进)</span></span><br><span class="line">    <span class="comment">// (尾递归，“回归”过程中不做任何事情）</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortSimple(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortSimple(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//　partition方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left, index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意此时right是坐标，要执行到最后一个元素，所以是&lt;=</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, index, i);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个小于主轴元素的元素下标是index - 1</span></span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="非递归快排-迭代快排"><a href="#非递归快排-迭代快排" class="headerlink" title="非递归快排 (迭代快排)"></a><strong>非递归快排 (迭代快排)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortStack(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 用于保存区间左右边界的栈，按right到left的顺序将初始区间界入栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 判断栈是否空，不空则弹出一对left，right界</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop(), right = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123; <span class="comment">// 执行partition的前提是left小于right</span></span><br><span class="line">            <span class="comment">// 对[left, right]区间执行partition方法，得到pivot</span></span><br><span class="line">              <span class="comment">// 加入后续两行实现随机轴快排</span></span><br><span class="line">            <span class="comment">// int randomIndex = new Random().nextInt(right - left) + left + 1; // 在[left + 1, right]范围内的随机值</span></span><br><span class="line">            <span class="comment">// swap(arr, left, randomIndex); // arr[left]与它之后的某个数交换</span></span><br><span class="line">              <span class="comment">// 加入下行实现三数取中快排</span></span><br><span class="line">            median3(arr, left, right);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            <span class="comment">// 当前pivot的左区间存在则将该区间right，left界入栈</span></span><br><span class="line">            <span class="keyword">if</span>(pivot &gt; left) &#123;</span><br><span class="line">                stack.push(pivot - <span class="number">1</span>);</span><br><span class="line">                stack.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前pivot的右区间存在则将该区间right，left界入栈</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt; pivot) &#123;</span><br><span class="line">                stack.push(right);</span><br><span class="line">                stack.push(pivot + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(logn)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>将输入数组建立为一个 <strong>大顶堆</strong>，之后反复取出堆顶并对剩余元素重建大顶堆，将依次取出的堆顶逆序排列，即可将原数组从小到大排列完成排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    heapify(arr, arr.length - <span class="number">1</span>); <span class="comment">// 构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// i &gt; 0即可，无需写成i &gt;= 0，当n - 1个元素排序时，最后一个元素也已排序</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i); <span class="comment">// 交换堆顶和当前未排序部分最后一个元素</span></span><br><span class="line">        <span class="comment">// 此时除当前堆顶元素外都是保持堆序的，只需要对该堆顶调用一次下滤操作</span></span><br><span class="line">        siftDown(arr, <span class="number">0</span>, i - <span class="number">1</span>); <span class="comment">// i - 1是未排序部分最后一个元素下标，确保下滤不会超过此范围</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> endIdx)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hole</span> <span class="operator">=</span> (endIdx - <span class="number">1</span>) / <span class="number">2</span>; hole &gt;= <span class="number">0</span>; hole--) &#123; <span class="comment">// (endIdx - 1) / 2伪最后一个非叶子节点下标</span></span><br><span class="line">        siftDown(arr, hole, endIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> hole, <span class="type">int</span> endIdx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[hole]; <span class="comment">// target是要下滤的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= endIdx) &#123;</span><br><span class="line">        <span class="comment">// 满足第一个条件child &lt; endIdx表示hole有右孩子，不满足则hole无右孩子，跳过</span></span><br><span class="line">        <span class="comment">// 第二个条件arr[child + 1] &gt; arr[child]只在第一个条件成立前提下进行判断（因此不必担心arr[child + 1]越界），</span></span><br><span class="line">        <span class="comment">// 若满足，表示hole有右孩子且右孩子更大，令child为右孩子下标。</span></span><br><span class="line">        <span class="comment">// 因此此if过后使得child是hole的孩子中较大的那个</span></span><br><span class="line">        <span class="keyword">if</span> (child &lt; endIdx &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若child大于target，则child上移到当前hole，hole下滤到child位置 </span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &gt; target) &#123;</span><br><span class="line">            arr[hole] = arr[child];</span><br><span class="line">            hole = child;</span><br><span class="line">            child = hole * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 当然也可以写成child = child * 2 + 1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 若无需交换hole与child，说明hole已经满足堆序(无需/无法再下滤)，退出while</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[hole] = target; <span class="comment">// 将target填入hole中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><blockquote><h4 id="计数排序的特征"><a href="#计数排序的特征" class="headerlink" title="计数排序的特征"></a><strong>计数排序的特征</strong></h4><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><p> 算法的步骤如下：</p><ul><li>（1）找出待排序的数组中最大和最小的元素</li><li>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><h4 id="不稳定计数排序"><a href="#不稳定计数排序" class="headerlink" title="不稳定计数排序"></a>不稳定计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSortUnstable(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArr[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countArr.length; i++) &#123; <span class="comment">// 遍历countArr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countArr[i]; j++) &#123; <span class="comment">// countArr[i]可能有多个相同数字</span></span><br><span class="line">            arr[index] = i + min; <span class="comment">// 复用了原输入数组arr</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="稳定计数排序"><a href="#稳定计数排序" class="headerlink" title="稳定计数排序"></a>稳定计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>]; <span class="comment">// arr最多有max-min+1种数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        countArr[arr[i] - min]++; <span class="comment">// arr[i]的值出现一次，则countArr[arr[i]-min]加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; countArr.length; i++) &#123; <span class="comment">// 变形</span></span><br><span class="line">        countArr[i] += countArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 根据sortedArr, nums, countArr三者关系完成sortedArr的输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sortedArr[countArr[arr[i] - min] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        countArr[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n+k)</strong></p><p><strong>空间复杂度:O(n+k)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><blockquote><p>非比较排序，「基」指的是数的位，例如十进制数 123，共有百十个位，共 3 个位。基数排序 按数字的位进行循环，每一轮操作都是对当前位（基数）的计数排序，使得输出到 arr 后所有数字在截止到当前位上（即去掉未考察的位后）是排序状态，考察完最大位后完成排序。具体过程如下：</p><ul><li>遍历待排序数组 arr ，找到最大值，计算其位数，例如 arr 中最大数为 123 ，则 maxDigitLen = 3 。</li><li>数组的数字为 n 进制，就创建大小为 n 的计数数组 countArr ，也可以称为 n 个桶。</li><li>开始「位」的 for 循环，循环次数等于 maxDigitLen ，每一轮对 当前所有数字的当前位 执行一次 计数排序。</li><li>每次计数排序结束后将结果写回 arr 。</li><li>for循环结束后返回排序结果 arr。</li></ul><h4 id="以计数排序为基础"><a href="#以计数排序为基础" class="headerlink" title="以计数排序为基础"></a>以计数排序为基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.abs(arr[<span class="number">0</span>]); <span class="comment">// 找到arr中绝对值最大者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigitLen</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">10</span>; <span class="comment">// 最大位数 &amp; 基（几进制就是几）</span></span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLen++;</span><br><span class="line">        max /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在接下来的for中，每一轮都对当前位(基数)执行一次计数排序</span></span><br><span class="line">    <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigitLen; i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">19</span>]; <span class="comment">// 处理负数优化</span></span><br><span class="line">        <span class="comment">// 根据每一个数字当前位的数字，累计相应位置的计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 此步处理要注意，当base大于10时，例如base=100时，1234%100=34</span></span><br><span class="line">            <span class="comment">// 还需要再除以(base/10)，得到的3，然后再+9（考虑负数）才是本次的bucketIdx</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>;</span><br><span class="line">            countArr[bucketIdx]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// countArr变形，得到每个下标所代表的arr中的数的当前位在arr中的最大位置（从1开始）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; countArr.length; j++) &#123;</span><br><span class="line">            countArr[j] += countArr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序输出保持稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">thisBase</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>;</span><br><span class="line">            <span class="comment">// countArr[thisBase]得到的从1开始计算的位置，转成下标要-1</span></span><br><span class="line">            sortedArr[countArr[thisBase] - <span class="number">1</span>] = arr[j]; </span><br><span class="line">            countArr[thisBase]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成当前位的计数排序后将排序结果拷贝回原数组</span></span><br><span class="line">        arr = Arrays.copyOf(sortedArr, sortedArr.length);</span><br><span class="line">        <span class="comment">// base进一位，准备下一轮对下一位的计数排序</span></span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="不以计数排序为基础"><a href="#不以计数排序为基础" class="headerlink" title="不以计数排序为基础"></a>不以计数排序为基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 找到arr中绝对值最大者</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.abs(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigitLen</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">10</span>; <span class="comment">// 最大位数 &amp; 基</span></span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLen++;</span><br><span class="line">        max /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arr.length + 1的作用是令每个桶的第0位保存该桶的元素个数。</span></span><br><span class="line">    <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">19</span>][arr.length + <span class="number">1</span>]; <span class="comment">// 处理负数优化</span></span><br><span class="line">    <span class="comment">// 在每一位上将数组中所有具有该位的数字装入对应桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigitLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 此步处理要注意，当base大于10时，例如base=100时，1234%100=34</span></span><br><span class="line">            <span class="comment">// 还需要再除以(base/10)，得到的3才是本次的bucketIndex</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>; <span class="comment">// +9使其可以处理负数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentBucketQuantity</span> <span class="operator">=</span> buckets[bucketIdx][<span class="number">0</span>];</span><br><span class="line">            buckets[bucketIdx][currentBucketQuantity + <span class="number">1</span>] = arr[j];</span><br><span class="line">            buckets[bucketIdx][<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前所有桶的数按桶序，桶内按低到高输出为本轮排序结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= buckets[j][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">                arr[arrIdx++] = buckets[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一轮过后将桶计数归零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) bucket[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        base *= <span class="number">10</span>; <span class="comment">// 调整base</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(d(n+k))</strong></p><p><strong>空间复杂度:O(n+k)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote><p>桶排序将原数组划分到称为 「桶」 的多个区间中，然后对每个桶单独进行排序，之后再按桶序和桶内序输出结果。适合于分布较均匀的数据，具体做法如下。</p><ul><li><p>根据数据规模按照 一定的方法 将待排序数组arr划分为多个区间，每个区间称作一个桶。</p></li><li><p>每个桶可以是数组，也可以是泛型容器，用于保存arr中落在该桶范围内的数。</p></li><li><p>对每一个桶都单独排序，需要 以适当的排序 方法支持，例如插入排序，快速排序等。</p></li><li><p>所有桶完成排序后，按桶序，桶内序依次输出所有元素，得到arr的排序结果。</p><p><strong>稳定性：取决于桶内排序方法的稳定性。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用泛型List存储所有桶，每个桶是一个ArrayList&lt;Integer&gt;，并初始化所有桶。</span></span><br><span class="line">    <span class="comment">// arr.length/3表示设置数组大小三分之一数量的桶</span></span><br><span class="line">    List&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr.length / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历arr，根据元素值将所有元素装入对应值区间的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// (arr[i] - min)/D为arr[i]元素应该装入的桶的下标，间隔D = (max-min)/(arr.length-1)</span></span><br><span class="line">        <span class="comment">// 虽可写成(arr[i] - min)*(arr.length-1)/(max-min)的形式，但当输入数组取值范围较大且元素较多时</span></span><br><span class="line">        <span class="comment">// (arr[i] - min)*(arr.length-1)可能会超过int上限，因此先做除法求出double类型的D</span></span><br><span class="line">        <span class="comment">// 再做一次除法求出bucketIndex，可以避免计算精度不够高带来的问题</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">interval</span> <span class="operator">=</span> (<span class="type">double</span>)(max - min) / (<span class="type">double</span>)(arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (<span class="type">int</span>) ((arr[i] - min) / interval);</span><br><span class="line">        buckets.get(bucketIdx).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序(调用库函数，从小到大)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.size(); i++) &#123;</span><br><span class="line">        Collections.sort(buckets.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sortedItem : bucket) &#123;</span><br><span class="line">            arr[index] = sortedItem; <span class="comment">// 复用输入数组arr</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 下图展示了十大排序的名字和大致用法 &lt;/p&gt;
&lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;img src=&quot;https://pic.leetcode-cn.com/1652691519-SVKUkM-image.png</summary>
      
    
    
    
    <category term="算法" scheme="https://gwtt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试， 排序" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C-%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux面试(1)</title>
    <link href="https://gwtt.github.io/2022/08/18/Linux%E9%9D%A2%E8%AF%95(1)/"/>
    <id>https://gwtt.github.io/2022/08/18/Linux%E9%9D%A2%E8%AF%95(1)/</id>
    <published>2022-08-18T14:23:13.000Z</published>
    <updated>2022-09-01T04:53:20.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-在Linux系统中如何统计某个字符串出现的次数"><a href="#1-在Linux系统中如何统计某个字符串出现的次数" class="headerlink" title="1.在Linux系统中如何统计某个字符串出现的次数"></a>1.在Linux系统中如何统计某个字符串出现的次数</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -o targetStr filename | wc -l（单个字符串）</span><br><span class="line">&quot;targetStr&quot;可以不加引号</span><br><span class="line">grep -o targetStr_1\|targetStr_2\|targetStr_3…… filename | wc -l</span><br><span class="line">&quot;targetStr_1&quot;这些必须加引号</span><br><span class="line">但是上面的方法是不准确的，因为wc -l只是显示行数，如果一行字符串多次出现，那么结果不准确</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-Linux查看日志的几种命令"><a href="#2-Linux查看日志的几种命令" class="headerlink" title="2.Linux查看日志的几种命令"></a>2.Linux查看日志的几种命令</h3><blockquote><h3 id="1-tail-查看实时变化的日志-比较吃内存"><a href="#1-tail-查看实时变化的日志-比较吃内存" class="headerlink" title="1. tail 查看实时变化的日志(比较吃内存)"></a>1. tail 查看实时变化的日志(<strong>比较吃内存</strong>)</h3><p>退出tail命令：Ctrl+c</p><table><thead><tr><th>-f</th><th>循坏读取</th></tr></thead><tbody><tr><td>-q</td><td>不显示处理信息</td></tr><tr><td>-v</td><td>显示详细的处理信息</td></tr><tr><td>-c</td><td>&lt;数目&gt; 显示的字节数</td></tr><tr><td>-n</td><td>显示行数 （相当于nl命令）</td></tr><tr><td>-pid=PID</td><td>与-f合用,表示在进程ID,PID死掉之后结束.</td></tr><tr><td>-q,-quiet,-slient</td><td>从不输出给出文件名的首部</td></tr><tr><td>-s, –sleep-interval=S</td><td>与-f合用,表示在每次反复的间隔休眠S秒</td></tr></tbody></table><table><thead><tr><th>用法</th><th>作用</th></tr></thead><tbody><tr><td>1. tail -f filename</td><td>默认最后10行,相当于增加参数 -n 10</td></tr><tr><td>2. tail -n 20 filename</td><td>显示filename最后20行</td></tr><tr><td>3. tail -n +5 filename</td><td>从第5行开始显示文件</td></tr></tbody></table><h3 id="2-cat命令"><a href="#2-cat命令" class="headerlink" title="2. cat命令"></a>2. cat命令</h3><p>cat命令搜索关键字附近的日志</p><p>常用用法：</p><p>查看log.log前200行</p><p><code>cat  log.log | head -n 200</code></p><p>查看test.log倒数200行</p><p><code>cat  test.log | tail -n 200</code></p><p>查看test.log中包含http的所有行</p><p><code>cat  test.log | grep &quot;http&quot;</code></p><p>查看test.log中包含http的所有行，并显示前后行</p><p><code>cat -n test.log | grep -C 5 “http”         (匹配字串那行以及前后5行)</code></p><p><code>cat -n test.log | grep -B 5 “http”         (匹配字串那行以及前5行)</code></p><p><code>cat -n test.log | grep -A 5 “http”         (匹配字串那行以及后5行)</code></p><h3 id="3-grep命令"><a href="#3-grep命令" class="headerlink" title="3. grep命令"></a>3. grep命令</h3><p>grep命令，文本搜索命令，可以使用正则表达式搜索文本<br>用法示例：</p><p>查看test.log中包含http的所有行(-i忽略大小写）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&quot;http&quot;</span> ./test.log</span><br></pre></td></tr></table></figure><h3 id="4-sed命令"><a href="#4-sed命令" class="headerlink" title="4. sed命令"></a>4. sed命令</h3><p>SED 查看某时间段日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/2022-06-02 13:10:30/,/2022-06-02 13:10:40/p&#x27;</span> test.log</span><br></pre></td></tr></table></figure><p>某时间端日志输出到指定文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/2022-06-02 13:10:30/,/2022-06-02 13:10:40/p&#x27;</span> test.log &gt; test20220602.log</span><br></pre></td></tr></table></figure><p>当然还可以使用vi文本编辑命令，less或者more命令进行查看</p><p>正向查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/关键字 按n键把光标移动到下一个符合条件的地方</span><br></pre></td></tr></table></figure><p>反向查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?关键字  按shift+n 键,把光标移动到下一个符合条件的</span><br></pre></td></tr></table></figure><p>日志文件本身还是一个文件，检索命令，编辑命令，查找命令都是可以进行操作的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-在Linux系统中如何统计某个字符串出现的次数&quot;&gt;&lt;a href=&quot;#1-在Linux系统中如何统计某个字符串出现的次数&quot; class=&quot;headerlink&quot; title=&quot;1.在Linux系统中如何统计某个字符串出现的次数&quot;&gt;&lt;/a&gt;1.在Linux系统中</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Linux" scheme="https://gwtt.github.io/tags/Linux/"/>
    
    <category term="指令" scheme="https://gwtt.github.io/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="https://gwtt.github.io/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>https://gwtt.github.io/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</id>
    <published>2022-08-18T13:46:07.000Z</published>
    <updated>2022-08-23T10:54:44.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流顾名思义就是限制流量，在软件系统中就是限制流量进入软件系统。</p><h1 id="为什么要限流？"><a href="#为什么要限流？" class="headerlink" title="为什么要限流？"></a>为什么要限流？</h1><p>在实际的生活场景中，当一个 web 服务部署到生产环境，也就是我们所说的公网。这个时候就会受到互联网上所有人的访问请求，比如像百度。每天都会有很多人访问 <code>www.baidu.com</code> ，如果有些人不怀好意的拼命的访问这个网站，那么整个系统就会因为这个人的恶作剧，从而浪费了很多不必要的带宽和系统资源。</p><h1 id="限流实现"><a href="#限流实现" class="headerlink" title="限流实现"></a>限流实现</h1><p>因为我们现在的软件系统都是微服务形式的，一个 HTTP 请求可能要经过后端十几个软件服务，最后才能得到结果返回给用户。如果我们对一些请求进行限制，比如只允许某一个 IP 在 10 秒钟内访问 20 次，如果超出了这 20 次，直接最前端就返回 429 状态码。这样就保护了后端十几个服务，避免为这些恶意请求消耗系统资源。</p><h2 id="常见的几种限流算法。"><a href="#常见的几种限流算法。" class="headerlink" title="常见的几种限流算法。"></a>常见的几种限流算法。</h2><p>有想法就会有实现，当前最常见的几种限流算法有<br><strong>固定窗口计数器算法</strong> 、<strong>滑动窗口计数器算法</strong>、<strong>漏桶算法</strong>、令牌桶算法。<br>其中固定窗口计数器算法和滑动窗口计数器算法比较相似，漏桶算法和令牌桶算法比较类似。<br>以下我们用只允许一个 ip 在 10 秒钟内只能访问 20 次这个限流需求来解释这些限流算法</p><h2 id="固定窗口算法"><a href="#固定窗口算法" class="headerlink" title="固定窗口算法"></a>固定窗口算法</h2><p>固定窗口算法就是设置一个固定的时间期限，当第一条请求到来的时候就开始计时同时计数，当接下来的 10 秒中内每来一条请求计数器就＋1。当计数器值到 20 后，接下来的所有请求都拒绝。十秒钟过后重置计数器。<br>但是此算法存在一个缺陷：<br>假设以下一种场景，攻击者在知道限流窗口是 10s 的情况下，先发送一条消息，让限流算法开启计数，此时计数器为 1，然后等到第 9.5 秒的时候持续发送请求攻击，这样 9.5-10 这个时间窗口里面会被允许经过 19 条消息，过了 10 秒后计数器归零，又马上接收了 20 条请求，这样，在 9.5-10.5 这个时间窗口总共接收了 39 条消息，限流值直接放大了一倍(原本是希望最大一秒钟只有 10 条的并发量)</p><p><img src="/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/2754881-20220318110617103-964302552.png" alt="img"></p><h2 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p>滑动窗口算法就解决了上面固定窗口算法的缺陷。所谓的滑动窗口就是在原有的固定窗口上新增了一个和固定窗口大小一样的窗口，此窗口可以滑动如下图。<br><img src="/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/2754881-20220318111108896-294281716.png" alt="img"></p><p>当第1条消息来到的时候，10秒的窗口期就生成，此时滑动窗口和第1个窗口重叠。接下来在第9.5秒的时候开始发动请求攻击，在第10秒的那一刻，滑动窗口。所含钙的窗口里面的计数器的值已经达到20，接下来我们假设又过了0.5秒，此时滑动窗口来到10.5秒。这时候滑动窗口涵盖了两个窗口。此时如何计算滑动窗口中计数器的值呢？我们可以假设前面的窗口所过来的流量是按照时间均匀分布的（虽然实际上并不是）。那么这个时候我们就可以计算出一个权重。就是滑动窗口涵盖第1个窗口时间的百分比：9.5/10=0.95。那么我们就假设当前这个窗口中所占有的数据为20*0.95=19。因此接下来我们只能允许通过一条数据。同时我们也可以计算出，10-10.5秒这个区间内算出来的值肯定小于1，因此这个区间内过来的请求全部会拒绝。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法的思想类似于小时候的那道数学题，一个水缸一个水龙头放水，一个出水口出水，进水口就是攻击者的请求，放水口就是限流算法允许通过的请求的速率，当水缸满出来了，则将请求拒绝，水缸里的水就是攻击者的请求被缓存起来。<br><img src="/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/2754881-20220318111636851-1034925225.png" alt="img"></p><p>接下来还是拿上面的例子：假设水缸容量是20，放水速率是每秒2个，当攻击者突然一秒钟打过来30个请求，如果是窗口计数器算法(不管是固定还是滑动窗口)会直接一下子允许20个请求通过剩下10个拒绝，但是接下来剩余窗口时间内不允许有新的请求进来。而漏桶算法则是会缓存这20个请求剩下10个拒绝，然后以每秒2个请求的速率往下游传递。此算法不允许突发流量，永远保证下游的速率一致。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法则是在漏桶算法上进行了修改。它的思想是假设桶内有很多令牌，同时以固定速率生成令牌放到桶内，如果桶内令牌满则丢弃。当请求过来的时候只要能拿到令牌就能通行。<br>以上面例子为例：桶内存在20个令牌，当同时以每秒2个的速度生成令牌。当一次来30条请求，则由于桶内存在20个令牌，因此前20个请求都会被放行，剩下的10个请求都会被拒绝，接下来如果继续有请求过来的话，就会以每秒2个请求的速率放行，当一段时间没有请求后，桶内令牌又会存满。<br><img src="/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/2754881-20220318111459982-1036389654.png" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总共介绍了四种常见的算到，</p><ul><li>固定窗口算法实现简单，但是有缺点就是会超出限流阈值两倍的请求</li><li>滑动窗口可以解决固定窗口超出限流阈值的问题，到时他的计算权重并不是准确的，而是按照时间线将请求平均在时间线上</li><li>漏桶算法不允许一定的突发流量，这有时候可能在特定场景造成请求超时。</li><li>令牌桶允许突发流量</li></ul><p>代码演示实现可以查看:<a href="https://blog.csdn.net/yangbindxj/article/details/124396314">(39条消息) 5种限流算法，7种限流方式，挡住突发流量_文晓武的博客-CSDN博客_限流算法</a></p><p>转自:<a href="https://www.cnblogs.com/geeko/p/16020359.html">几种常见的限流算法 - zhqqqy - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;限流&quot;&gt;&lt;a href=&quot;#限流&quot; class=&quot;headerlink&quot; title=&quot;限流&quot;&gt;&lt;/a&gt;限流&lt;/h1&gt;&lt;p&gt;限流顾名思义就是限制流量，在软件系统中就是限制流量进入软件系统。&lt;/p&gt;
&lt;h1 id=&quot;为什么要限流？&quot;&gt;&lt;a href=&quot;#为什么要限流</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="计算机网络" scheme="https://gwtt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>泰拉瑞亚服务器搭建</title>
    <link href="https://gwtt.github.io/2022/08/10/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://gwtt.github.io/2022/08/10/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</id>
    <published>2022-08-10T07:58:02.000Z</published>
    <updated>2022-08-10T08:01:37.107Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">一、设置swap，防止内存不足</span><br><span class="line">首先查看</span><br><span class="line">free –m</span><br><span class="line">可以看到swap分区是0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、删除原有的分区</span><br><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、新建分区</span><br><span class="line">dd if=/dev/zero of=/root/swapfile bs=1M count=2048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、格式化交换分区</span><br><span class="line">mkswap /root/swapfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、启动新建的swap交换分区</span><br><span class="line">swapon /root/swapfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5、添加开机启动</span><br><span class="line">进入目录</span><br><span class="line">vi /etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按（英文下状态小写的）i进入编辑模式，到达文件底部添加内容</span><br><span class="line">/root/swapfile swap swap defaults 0 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">完毕后依次按键盘 Esc-键盘shift+:+输入wq保存/退出编辑好的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6、使用命令重启服务器</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">……等待重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7、检查</span><br><span class="line">输入命令free –m</span><br><span class="line">看Swap有了数值，表示成功添加。</span><br><span class="line"></span><br><span class="line">8、进入管理员权限</span><br><span class="line">sudo su root</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">二、安装工具</span><br><span class="line">1、下载工具</span><br><span class="line"></span><br><span class="line">yum romove wget</span><br><span class="line"></span><br><span class="line">yum install -y wget</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、解压工具</span><br><span class="line">yum install -y unzip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、压缩工具</span><br><span class="line">yum install –y zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、远程管理工具</span><br><span class="line">yum install -y screen</span><br><span class="line">看到Complete!表示完成</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">三、创建目录</span><br><span class="line">1、创建父目录</span><br><span class="line">mkdir /opt/terraria</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、创建2个子目录,和存档目录</span><br><span class="line">mkdir /opt/terraria/bin keyword zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、查看目录是否创建成功</span><br><span class="line">ls /opt/terraria/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、进入zip文件夹</span><br><span class="line">cd /opt/terraria/zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5、下载泰拉瑞亚服务器包（最新版本去官网寻找）</span><br><span class="line">wget https://terraria.org/api/download/pc-dedicated-server/terraria-server-1436.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6、查看是否下载好terraria-server-1436.zip</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7、解压服务器包到bin文件夹</span><br><span class="line">unzip terraria-server-1436.zip -d ../bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8、新建服务器的配置文件</span><br><span class="line">vim ../server-config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按（英文状态小写的）i进入编辑模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">world=/opt/terraria/keyword/存档名.wld</span><br><span class="line">worldname=世界的名字</span><br><span class="line">difficulty=0</span><br><span class="line">autocreate=2</span><br><span class="line">maxplayers=4</span><br><span class="line">password=设定一个密码</span><br><span class="line">worldpath=/opt/terraria/keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line">autocreate是地图大小1&lt;2&lt;3</span><br><span class="line">difficulty是难度0为普通,1为专家</span><br><span class="line">maxplayers 最大人数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按esc-shift+:- wq保存退出</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">四、启动准备</span><br><span class="line">1、放行7777端口</span><br><span class="line">启动防火墙：systemctl start firewalld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">firewall-cmd --permanent --add-port=7777/tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、给文件添加最高权限</span><br><span class="line">chmod 777 /opt/terraria/bin/1432/Linux/TerrariaServer.bin.x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、进入启动目录</span><br><span class="line">cd /opt/terraria/bin/1432/Linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、启动服务器使用自定义的配置文件</span><br><span class="line">./TerrariaServer.bin.x86_64 -config /opt/terraria/server-config</span><br><span class="line">等待加载……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、已经创建成功此时还差一步</span><br><span class="line">先退出</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编辑之前的配置文件</span><br><span class="line">vim /opt/terraria/server-config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按（英文状态小写的）i进入编辑模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分别给worldname=xx 每段前加#号</span><br><span class="line">difficulty=xx</span><br><span class="line">autocreate=xx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按esc-shift+:- wq保存退出</span><br><span class="line">目的是让注释代码让其失效，不然每次重开服务器都会生成新世界</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">五、创建新会话来运行服务器</span><br><span class="line">1、移动到服务器目录</span><br><span class="line">cd /opt/terraria/1432/Linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、创建新的screen会话，用于运行服务器</span><br><span class="line">screen -S terrariaServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、启动服务器使用自定义的配置文件</span><br><span class="line">./TerrariaServer.bin.x86_64 -config /opt/terraria/server-config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建好后,使用Ctrl+A+D退出会话，不会被关闭</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">停止服务器输入</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重新连接screen会话</span><br><span class="line">screen -R terrariaServer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="兴趣" scheme="https://gwtt.github.io/categories/%E5%85%B4%E8%B6%A3/"/>
    
    
    <category term="Linux" scheme="https://gwtt.github.io/tags/Linux/"/>
    
    <category term="游戏" scheme="https://gwtt.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap为什么线程不安全</title>
    <link href="https://gwtt.github.io/2022/08/08/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"/>
    <id>https://gwtt.github.io/2022/08/08/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/</id>
    <published>2022-08-08T11:50:18.000Z</published>
    <updated>2022-08-17T11:58:05.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h4><p>数据结构上：数组+(链表和红黑树)</p><h4 id="HashMap线程不安全问题"><a href="#HashMap线程不安全问题" class="headerlink" title="HashMap线程不安全问题"></a>HashMap线程不安全问题</h4><blockquote><p>HashMap 是线程不安全的，原因就在于 HashMap 的 <strong>rehash</strong>。<strong>rehash</strong> 是 HashMap 扩容过程种的一个步骤。 HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。 这时候，HashMap 需要扩展它的长度，也就是进行 Resize。 影响发生 Resize 的因素有两个：</p><p>1.<strong>Capacity</strong></p><p>HashMap 的当前长度。上一期曾经说过，HashMap 的长度是 2 的幂。</p><p>2.<strong>LoadFactor</strong></p><p>HashMap 负载因子，默认值为 0.75f。</p><p>衡量 HashMap 是否进行 Resize 的 条件如下：</p><p>HashMap.Size  &gt;= Capacity * LoadFactor</p><p>HashMap 的扩容主要分为两步：</p><ol><li><p>扩容</p><p>创建一个新的 Entry 空数组，长度是原数组的 2 倍</p></li><li><p>ReHash</p><p>遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组。为什么要重新 Hash 呢？因为长度扩大以后，Hash 的规则也随之改变。</p><p>让我们回顾一下 Hash 公式：</p><p>index = HashCode（Key） &amp; （Length - 1）**(计算哈希索引)**</p><p>当原数组长度为 8 时，Hash 运算是和 111B 做与运算；新数组长度为 16，Hash 运算是和 1111B 做与运算。Hash 结果显然不同。</p><p>ReHash 的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上过程单线程下不会出现问题，但是当两个线程同时触发resize的时候就有可能出现问题</p><p>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/171705_8KHj_1860759.png" alt="img"></p><p>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/171730_nKJe_1860759.png" alt="img"></p><p>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure><p>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：</p><p>e = Entry3</p><p>next = Entry2</p><p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174539_nVJj_1860759.png" alt="img"></p><p>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。线程B刚才的状态是：</p><p>e = Entry3</p><p>next = Entry2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br></pre></td></tr></table></figure><p>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：</p><p>e = Entry2</p><p>next = Entry2</p><p>整体情况如图所示：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174637_jMIL_1860759.png" alt="img"></p><p>接着是新一轮循环，又执行到红框内的代码行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure><p>e = Entry2</p><p>next = Entry3</p><p>整体情况如图所示：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174707_4fJ8_1860759.png" alt="img"></p><p>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>整体情况如图所示：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174732_ZDEZ_1860759.png" alt="img"></p><p>第三次循环开始，又执行到红框的代码：</p><p>e = Entry3</p><p>next = Entry3.next = null</p><p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[i];</span><br></pre></td></tr></table></figure><p>newTable[i] = Entry2</p><p>e = Entry3</p><p>Entry2.next = Entry3</p><p>Entry3.next = Entry2</p><p>链表出现了环形！</p><p>整体情况如图所示：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174818_kap6_1860759.png" alt="img"></p><p>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！**(此问题在JDK8中已经解决，上图过程看看就好)**</p><p>主要的问题是，两个线程在同一个数组索引下标添加元素时，比如A添加key2,B添加key3,会可能导致key2或者key3丢失。</p></li></ol></blockquote><h3 id="ConCurrentHashMap安全吗，是怎么保证安全的？"><a href="#ConCurrentHashMap安全吗，是怎么保证安全的？" class="headerlink" title="ConCurrentHashMap安全吗，是怎么保证安全的？"></a>ConCurrentHashMap安全吗，是怎么保证安全的？</h3><blockquote><p>目前有如下一些方式可以获得线程安全的HashMap：</p><ul><li><em>Collections.synchronizedMap</em></li><li>HashTable</li><li>ConcurrentHashMap</li></ul><p>其中，前两种方式由于全局锁的问题，存在很严重的性能问题。所以，著名的并发编程大师Doug Lea在JDK1.5的java.util.concurrent包下面添加了一大堆并发工具。其中就包含ConcurrentHashMap这个线程安全的HashMap。</p><p>ConcurrentHashMap在JDK7和JDK8中的实现方式上有较大的不同。首先我们先来大概回顾一下ConcurrentHashMap在JDK7中的原理是怎样的。</p><h4 id="1-分段锁技术-JDK7"><a href="#1-分段锁技术-JDK7" class="headerlink" title="1.分段锁技术(JDK7)"></a>1.分段锁技术(JDK7)</h4><blockquote><p>针对HashTable会锁整个hash表的问题，ConcurrentHashMap提出了分段锁的解决方案。</p><p>分段锁的思想就是：<strong>锁的时候不锁整个hash表，而是只锁一部分</strong>。</p><p>如何实现呢？这就用到了ConcurrentHashMap中最关键的Segment。</p><p>ConcurrentHashMap中维护着一个Segment数组，每个Segment可以看做是一个HashMap。</p><p>而Segment本身继承了ReentrantLock，它本身就是一个锁。</p><p>在Segment中通过HashEntry数组来维护其内部的hash表。</p><p>每个HashEntry就代表了map中的一个K-V，用HashEntry可以组成一个链表结构，通过next字段引用到其下一个元素。</p><p>上述内容在源码中的表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Segment是ConcurrentHashMap的静态内部类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="comment">     * subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="comment">     * simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略 ...</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The per-segment table. Elements are accessed via</span></span><br><span class="line"><span class="comment">         * entryAt/setEntryAt providing volatile semantics.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">        <span class="comment">// ... 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ConcurrentHashMap list entry. Note that this is never exported</span></span><br><span class="line"><span class="comment">     * out as a user-visible Map.Entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// ... 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-f53c2717e40e288ba87738bc45822dd0_1440w.jpg" alt="img"></p><p>由上图可见，只要我们的hash值足够分散，那么每次put的时候就会put到不同的segment中去。 而segment自己本身就是一个锁，put的时候，当前segment会将自己锁住，此时其他线程无法操作这个segment， 但不会影响到其他segment的操作。这个就是锁分段带来的好处。</p></blockquote><h4 id="2-线程安全的put"><a href="#2-线程安全的put" class="headerlink" title="2.线程安全的put"></a>2.线程安全的put</h4><p>ConcurrentHashMap的put方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key的hash定位出一个segment，如果指定index的segment还没初始化，则调用ensureSegment方法初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 调用segment的put方法</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用segment的put方法，将元素put到HashEntry数组中，这里的注释中只给出锁相关的说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为segment本身就是一个锁</span></span><br><span class="line">    <span class="comment">// 这里调用tryLock尝试获取锁</span></span><br><span class="line">    <span class="comment">// 如果获取成功，那么其他线程都无法再修改这个segment</span></span><br><span class="line">    <span class="comment">// 如果获取失败，会调用scanAndLockForPut方法根据key和hash尝试找到这个node，如果不存在，则创建一个node并返回，如果存在则返回null</span></span><br><span class="line">    <span class="comment">// 查看scanAndLockForPut源码会发现他在查找的过程中会尝试获取锁，在多核CPU环境下，会尝试64次tryLock()，如果64次还没获取到，会直接调用lock()</span></span><br><span class="line">    <span class="comment">// 也就是说这一步一定会获取到锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-线程安全的扩容-Rehash"><a href="#3-线程安全的扩容-Rehash" class="headerlink" title="3.线程安全的扩容(Rehash)"></a>3.线程安全的扩容(Rehash)</h4><p>HashMap的线程安全问题大部分出在扩容(rehash)的过程中。</p><p>ConcurrentHashMap的扩容<strong>只针对每个segment</strong>中的HashEntry数组进行扩容。</p><p>由上述put的源码可知，ConcurrentHashMap在rehash的时候是有锁的，所以在rehash的过程中，其他线程无法对segment的hash表做操作，这就保证了线程安全。</p><h3 id="1-JDK8中ConcurrentHashMap的初始化"><a href="#1-JDK8中ConcurrentHashMap的初始化" class="headerlink" title="1.JDK8中ConcurrentHashMap的初始化"></a>1.JDK8中ConcurrentHashMap的初始化</h3><p>以无参数构造函数为例，来看一下ConcurrentHashMap类初始化的时候会做些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>首先会执行静态代码块和初始化类变量。 主要会初始化以下这些类变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">这里用到了Unsafe类，其中objectFieldOffset方法用于获取指定Field(例如sizeCtl)在内存中的偏移量。<span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SIZECTL;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> BASECOUNT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLSBUSY;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLVALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">        TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">        BASECOUNT = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">        CELLSBUSY = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">        Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">            (ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">        <span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> U.arrayIndexScale(ak);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;这里用到了Unsafe类，其中objectFieldOffset方法用于获取指定Field(例如sizeCtl)在内存中的偏移量。</span><br></pre></td></tr></table></figure><p>这里用到了Unsafe类，其中objectFieldOffset方法用于获取指定Field(例如sizeCtl)在内存中的偏移量。</p><h3 id="2-内部数据结构"><a href="#2-内部数据结构" class="headerlink" title="2.内部数据结构"></a>2.内部数据结构</h3><p>先来从源码角度看一下JDK8中是怎么定义的存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment"> * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * hash表，在第一次put数据的时候才初始化，他的大小总是2的倍数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来存储一个键值对</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Key-value entry.  This class is never exported out as a</span></span><br><span class="line"><span class="comment"> * user-mutable Map.Entry (i.e., one supporting setValue; see</span></span><br><span class="line"><span class="comment"> * MapEntry below), but can be used for read-only traversals used</span></span><br><span class="line"><span class="comment"> * in bulk tasks.  Subclasses of Node with a negative hash field</span></span><br><span class="line"><span class="comment"> * are special, and contain null keys and values (but are never</span></span><br><span class="line"><span class="comment"> * exported).  Otherwise, keys and vals are never null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，JDK8与JDK7的实现由较大的不同，JDK8中不在使用Segment的概念，他更像HashMap的实现方式。</p><p><img src="https://pic1.zhimg.com/80/v2-53355a611b890d50b91f857222ac3e7c_1440w.jpg" alt="img"></p><h3 id="3-线程安全的hash表初始化"><a href="#3-线程安全的hash表初始化" class="headerlink" title="3.线程安全的hash表初始化"></a>3.线程安全的hash表初始化</h3><p>由上文可知ConcurrentHashMap是用table这个成员变量来持有hash表的。</p><p>table的初始化采用了延迟初始化策略，他会在第一次执行put的时候初始化table。</p><p>put方法源码如下（省略了暂时不相关的代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The value can be retrieved by calling the &#123;<span class="doctag">@code</span> get&#125; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果table是空，初始化之</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initTable源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// sizeCtl的默认值是0，所以最先走到这的线程会进入到下面的else if判断中</span></span><br><span class="line">        <span class="comment">// #2</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 尝试原子性的将指定对象(this)的内存偏移量为SIZECTL的int变量值从sc更新为-1</span></span><br><span class="line">        <span class="comment">// 也就是将成员变量sizeCtl的值改为-1</span></span><br><span class="line">        <span class="comment">// #3</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双重检查，原因会在下文分析</span></span><br><span class="line">                <span class="comment">// #4</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY; <span class="comment">// 默认初始容量为16</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// #5</span></span><br><span class="line">                    table = tab = nt; <span class="comment">// 创建hash表，并赋值给成员变量table</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// #6</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量sizeCtl在ConcurrentHashMap中的其中一个作用相当于HashMap中的threshold，当hash表中元素个数超过sizeCtl时，触发扩容； 他的另一个作用类似于一个标识，例如，当他等于-1的时候，说明已经有某一线程在执行hash表的初始化了，一个小于-1的值表示某一线程正在对hash表执行resize。</p><p>这个方法首先判断sizeCtl是否小于0，如果小于0，直接将当前线程变为就绪状态的线程。</p><p>当sizeCtl大于等于0时，当前线程会尝试通过CAS的方式将sizeCtl的值修改为-1。修改失败的线程会进入下一轮循环，判断sizeCtl&lt;0了，被yield住；修改成功的线程会继续执行下面的初始化代码。</p><p>在new Node[]之前，要再检查一遍table是否为空，这里做双重检查的原因在于，如果另一个线程执行完#1代码后挂起，此时另一个初始化的线程执行完了#6的代码，此时sizeCtl是一个大于0的值，那么再切回这个线程执行的时候，是有可能重复初始化的。关于这个问题会在下图的并发场景中说明。</p><p>然后初始化hash表，并重新计算sizeCtl的值，最终返回初始化好的hash表。</p><h3 id="4-线程安全的put"><a href="#4-线程安全的put" class="headerlink" title="4 .线程安全的put"></a>4 .线程安全的put</h3><p>put操作可分为以下两类 <em>当前hash表对应当前key的index上没有元素时</em> 当前hash表对应当前key的index上已经存在元素时(hash碰撞)</p><h3 id="4-1-hash表上没有元素时"><a href="#4-1-hash表上没有元素时" class="headerlink" title="4.1 hash表上没有元素时"></a>4.1 hash表上没有元素时</h3><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                 <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tabAt方法通过Unsafe.getObjectVolatile()的方式获取数组对应index上的元素，getObjectVolatile作用于对应的内存偏移量上，是具备volatile内存语义的。</p><p>如果获取的是空，尝试用cas的方式在数组的指定index上创建一个新的Node。</p><h3 id="4-2-hash碰撞时"><a href="#4-2-hash碰撞时" class="headerlink" title="4.2 hash碰撞时"></a>4.2 hash碰撞时</h3><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 锁f是在4.1中通过tabAt方法获取的</span></span><br><span class="line">    <span class="comment">// 也就是说，当发生hash碰撞时，会以链表的头结点作为锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="comment">// 这个检查的原因在于：</span></span><br><span class="line">        <span class="comment">// tab引用的是成员变量table，table在发生了rehash之后，原来index上的Node可能会变</span></span><br><span class="line">        <span class="comment">// 这里就是为了确保在put的过程中，没有收到rehash的影响，指定index上的Node仍然是f</span></span><br><span class="line">        <span class="comment">// 如果不是f，那这个锁就没有意义了</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">            <span class="comment">// 确保put没有发生在扩容的过程中，fh=-1时表示正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                binCount = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                    K ek;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == key ||</span><br><span class="line">                         (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                        oldVal = e.val;</span><br><span class="line">                        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                            e.val = value;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Node&lt;K,V&gt; pred = e;</span><br><span class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 在链表后面追加元素</span></span><br><span class="line">                        pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                  value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p;</span><br><span class="line">                binCount = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                               value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldVal = p.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        p.val = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果链表长度超过8个，将链表转换为红黑树，与HashMap相同，相对于JDK7来说，优化了查找效率</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">            treeifyBin(tab, i);</span><br><span class="line">        <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于JDK7中segment的概念，JDK8中直接用链表的头节点做为锁。 JDK7中，HashMap在多线程并发put的情况下可能会形成环形链表，ConcurrentHashMap通过这个锁的方式，使同一时间只有有一个线程对某一链表执行put，解决了并发问题。</p><h3 id="5-线程安全的扩容"><a href="#5-线程安全的扩容" class="headerlink" title="5 线程安全的扩容"></a>5 线程安全的扩容</h3><p>put方法的最后一步是统计hash表中元素的个数，如果超过sizeCtl的值，触发扩容。</p><p>扩容的代码略长，可大致看一下里面的中文注释，再参考下面的分析。 其实我们主要的目的是弄明白ConcurrentHashMap是如何解决HashMap的并发问题的。 带着这个问题来看源码就好。关于HashMap存在的问题，参考本文一开始说的笔者的另一篇文章即可。</p><p>其实HashMap的并发问题多半是由于put和扩容并发导致的。</p><p>这里我们就来看一下ConcurrentHashMap是如何解决的。</p><p>扩容涉及的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment"> * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment"> * 业务中使用的hash表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment"> * 扩容时才使用的hash表，扩容完成后赋值给table，并将nextTable重置为null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds to count, and if table is too small and not already</span></span><br><span class="line"><span class="comment"> * resizing, initiates transfer. If already resizing, helps</span></span><br><span class="line"><span class="comment"> * perform transfer if work is available.  Rechecks occupancy</span></span><br><span class="line"><span class="comment"> * after a transfer to see if another resize is already needed</span></span><br><span class="line"><span class="comment"> * because resizings are lagging additions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the count to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> check if &lt;0, don&#x27;t check resize, if &lt;= 1 only check if uncontended</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    <span class="comment">// ----- 计算键值对的个数 start -----</span></span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----- 计算键值对的个数 end -----</span></span><br><span class="line">    <span class="comment">// ----- 判断是否需要扩容 start -----</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 当上面计算出来的键值对个数超出sizeCtl时，触发扩容，调用核心方法transfer</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果有已经在执行的扩容操作，nextTable是正在扩容中的新的hash表</span></span><br><span class="line">                <span class="comment">// 如果并发扩容，transfer直接使用正在扩容的新hash表，保证了不会出现hash表覆盖的情况</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新sizeCtl的值，更新成功后为负数，扩容开始</span></span><br><span class="line">            <span class="comment">// 此时没有并发扩容的情况，transfer中会new一个新的hash表来扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----- 判断是否需要扩容 end -----</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment"> * above for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 初始化新的hash表，大小为之前的2倍，并赋值给成员变量nextTable</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">// 扩容完成时，将成员变量nextTable置为null，并将table替换为rehash后的nextTable</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 接下来是遍历每个链表，对每个链表的元素进行rehash</span></span><br><span class="line">            <span class="comment">// 仍然用头结点作为锁，所以在扩容的时候，无法对这个链表执行put操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// setTabAt方法调用了Unsafe.putObjectVolatile来完成hash表元素的替换，具备volatile内存语义</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述代码，对ConcurrentHashMap是如何解决HashMap并发问题这一疑问进行简要说明。</p><ul><li>首先new一个新的hash表(nextTable)出来，大小是原来的2倍。后面的rehash都是针对这个新的hash表操作，不涉及原hash表(table)。</li><li>然后会对原hash表(table)中的每个链表进行rehash，此时会尝试获取头节点的锁。这一步就保证了在rehash的过程中不能对这个链表执行put操作。</li><li>通过sizeCtl控制，使扩容过程中不会new出多个新hash表来。</li><li>最后，将所有键值对重新rehash到新表(nextTable)中后，用nextTable将table替换。这就避免了HashMap中get和扩容并发时，可能get到null的问题。</li><li>在整个过程中，共享变量的存储和读取全部通过volatile或CAS的方式，保证了线程安全。</li></ul></blockquote><p>[ ]转载:<a href="https://my.oschina.net/muziH/blog/1596801">HashMap原理及线程不安全详解 - 木子H的个人空间 - OSCHINA - 中文开源技术交流社区</a></p><p>[]参考:<a href="https://zhuanlan.zhihu.com/p/84390205">Java8中ConcurrentHashMap是如何保证线程安全的 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;HashMap原理&quot;&gt;&lt;a href=&quot;#HashMap原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap原理&quot;&gt;&lt;/a&gt;HashMap原理&lt;/h4&gt;&lt;p&gt;数据结构上：数组+(链表和红黑树)&lt;/p&gt;
&lt;h4 id=&quot;HashMap线程不安全</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>自动拆箱和装箱原理</title>
    <link href="https://gwtt.github.io/2022/08/08/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%E5%8E%9F%E7%90%86/"/>
    <id>https://gwtt.github.io/2022/08/08/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%E5%8E%9F%E7%90%86/</id>
    <published>2022-08-08T11:22:37.000Z</published>
    <updated>2022-08-08T11:49:38.353Z</updated>
    
    <content type="html"><![CDATA[<p>自动装箱和自动拆箱是两个相反的过程，自动装箱即将基本数据类型转换为对应的封装类，自动拆箱即将封装类转换为对应的基本数据类型。此外，<strong>装箱的过程会增加内存的消耗，影响性能，因为这个过程会创建对应的对象。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210112100512319.png?x-oss-process=image#pic_center/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQyNzEyOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integerNum</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 进行自动装箱，得到的是封装类</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">intNum</span> <span class="operator">=</span> integerNum; <span class="comment">// 进行自动拆箱，得到基本数据类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code>javap -c Main.class</code> 查看生成的字节码文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Main.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">club</span>.wadreamer.test.Main &#123;</span><br><span class="line">  <span class="keyword">public</span> club.wadreamer.test.Main();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: aload_1</span><br><span class="line">       <span class="number">7</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/lang/Integer.intValue:()I</span></span><br><span class="line">      <span class="number">10</span>: istore_2</span><br><span class="line">      <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Integer#valueOf()</code> 和 <code>Integer#intValue()</code> 的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"><span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上述字节码可以得出如下结论：</p><ul><li>在进行自动装箱时，Java 虚拟机会自动调用 Integer#valueOf()。</li><li>在进行自动拆箱时，Java 虚拟机会自动调用 Integer#intValue()。</li><li>其他数据类型的自动装箱和自动拆箱的过程和 Integer 类似，都是调用类似 xxxValue()、valueOf() 等方法。</li></ul><h4 id="其他案例分析"><a href="#其他案例分析" class="headerlink" title="其他案例分析"></a>其他案例分析</h4><h5 id="1-空指针异常"><a href="#1-空指针异常" class="headerlink" title="1.空指针异常"></a>1.空指针异常</h5><blockquote><p>包装类为空，拆箱时异常</p></blockquote><h5 id="2-equals和-问题"><a href="#2-equals和-问题" class="headerlink" title="2.equals和==问题"></a>2.equals和==问题</h5><blockquote><p>两个包装类用==，比较的是地址</p><p>两个包装类用equals，比较的是值</p><p>一个包装类和一个基本数据类型用equals，比较的是值</p><p>一个包装类和一个基本数据类型用==，比较的是值（会自动拆包）</p><p>两个基本数据类型用==比较的是值</p></blockquote><h5 id="3-拆箱的缓存机制"><a href="#3-拆箱的缓存机制" class="headerlink" title="3.拆箱的缓存机制"></a>3.拆箱的缓存机制</h5><blockquote><p><strong>对于 Integer</strong>，在 [-128, 127] 之间只有固定的 256 个值，所以为了避免多次创建对象，事先创建好一个大小为 256 的 Integer 数组 cache，所以如果值在这个范围内，就可以直接返回我们事先创建好的对象即可。</p><p><strong>对于 Double 类型来说</strong>，我们就不能这样做，因为它在这个范围内个数是无限的。 总结一句就是：在某个范围内的整型数值的个数是有限的，而浮点数却不是。所以在 Double 里面的做法很直接，就是直接创建一个对象，所以每次创建的对象都不一样。</p><p>对于 Boolean 类型来说，在内部已经提前创建好两个对象，因为它只有两种情况，这样也是为了避免重复创建太多的对象。因此，每次执行 Boolean#valueOf() 返回的都是相同的对象。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><ul><li>存在拆箱操作时一定要特别注意封装类对象是否为 null。</li><li>包装类和基本数据类型在进行== 运算和算数运算时，会进行自动拆箱。</li><li>equals() 会进行<strong>自动装箱操作</strong>，且需要先判断封装类的类型是否相同，再进一步判断内容是否相同。（==是优先比较基本数据类型，是<strong>拆箱操作</strong>）</li><li>Integer、Short、Byte、Character、Long 这几个类的 valueOf() 的实现是类似的，均在存在 [-128, 127] 的缓存。</li><li>Double、Float 的 valueOf() 的实现是类似的，每次都返回不同的对象。</li><li>Boolean 预先创建了两个对象，Boolean#valueOf() 每次返回的都是相同的对象。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自动装箱和自动拆箱是两个相反的过程，自动装箱即将基本数据类型转换为对应的封装类，自动拆箱即将封装类转换为对应的基本数据类型。此外，&lt;strong&gt;装箱的过程会增加内存的消耗，影响性能，因为这个过程会创建对应的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>八锁问题</title>
    <link href="https://gwtt.github.io/2022/07/10/%E5%85%AB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>https://gwtt.github.io/2022/07/10/%E5%85%AB%E9%94%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-10T12:28:04.572Z</published>
    <updated>2022-07-10T12:31:59.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八锁问题"><a href="#八锁问题" class="headerlink" title="八锁问题"></a>八锁问题</h1><ol><li>new发短信后 睡眠100毫秒，发短信、发邮件的打印顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0101</span> <span class="variable">test0101</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0101</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0101.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0101.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0101</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendMessage</span><br><span class="line">sendEmail</span><br><span class="line">因为<span class="keyword">synchronized</span>关键字 是对该资源类的对象上锁，因此哪个线程先拿到对象锁，就先执行</span><br></pre></td></tr></table></figure><p> 2.发短信线程中执行时睡眠4秒，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0201</span> <span class="variable">test0201</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0201</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0201.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0201.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0201</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendMessage</span><br><span class="line">sendEmail</span><br><span class="line">原理同上。还是上面的线程先拿到 资源类 锁对象</span><br></pre></td></tr></table></figure><p>3.打电话线程，发短信、打电话的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0301</span> <span class="variable">test0301</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0301</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0301.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0301.call();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0301</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">call</span><br><span class="line">sendMessage</span><br><span class="line"><span class="title function_">call</span><span class="params">()</span>为普通方法,不受同步方法的影响,不受锁的影响</span><br></pre></td></tr></table></figure><p>4.两个资源，发短信、发邮件的打印顺序(先邮件后短信)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0401</span> <span class="variable">test0401</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0401</span>();</span><br><span class="line">        <span class="type">Test0401</span> <span class="variable">test0402</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0401</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0401.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0402.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0401</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendEmail</span><br><span class="line">sendMessage</span><br><span class="line">区别于问题<span class="number">1</span>，该情况是 两个资源类对象分别开启两个线程，因此锁对象 并无互相干扰，因为线程延时的原因，打电话 先输出</span><br></pre></td></tr></table></figure><p>5.两个同步方法变静态、一个资源，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0501</span> <span class="variable">test0401</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0501</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0401.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0401.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0501</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendMessage</span><br><span class="line">sendEmail</span><br><span class="line">加上<span class="keyword">static</span>关键字之后，两个方法都变为静态方法。</span><br></pre></td></tr></table></figure><p>6.两个静态同步方法、两个资源，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0601</span> <span class="variable">test0601</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0601</span>();</span><br><span class="line">        <span class="type">Test0601</span> <span class="variable">test0602</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0601</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0601.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0602.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0601</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendMessage</span><br><span class="line">sendEmail</span><br><span class="line">原理同<span class="number">5</span>，<span class="keyword">synchronized</span> 加 静态方法 锁的是 Class</span><br></pre></td></tr></table></figure><p>7.一个静态同步方法、一个普通同步方法、一个资源，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0701</span> <span class="variable">test0701</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0701</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0701.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0701.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0701</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendEmail</span><br><span class="line">sendMessage</span><br><span class="line"><span class="keyword">synchronized</span> 锁的是 类实例即对象 、<span class="keyword">synchronized</span> 加 静态方法 锁的是 Class</span><br></pre></td></tr></table></figure><p>8.一个静态同步方法、一个普通同步方法、两个资源，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0801</span> <span class="variable">test0801</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0801</span>();</span><br><span class="line">        <span class="type">Test0801</span> <span class="variable">test0802</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0801</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0801.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0802.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0801</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendEmail</span><br><span class="line">sendMessage</span><br><span class="line">原理同<span class="number">7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;八锁问题&quot;&gt;&lt;a href=&quot;#八锁问题&quot; class=&quot;headerlink&quot; title=&quot;八锁问题&quot;&gt;&lt;/a&gt;八锁问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;new发短信后 睡眠100毫秒，发短信、发邮件的打印顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="java基础" scheme="https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Juc" scheme="https://gwtt.github.io/tags/Juc/"/>
    
  </entry>
  
</feed>
