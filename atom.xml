<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>滚~韬的博客</title>
  
  <subtitle>滚~</subtitle>
  <link href="https://gwtt.github.io/atom.xml" rel="self"/>
  
  <link href="https://gwtt.github.io/"/>
  <updated>2022-08-23T16:03:13.801Z</updated>
  <id>https://gwtt.github.io/</id>
  
  <author>
    <name>滚~韬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈股票dp问题</title>
    <link href="https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/"/>
    <id>https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-23T09:40:23.000Z</published>
    <updated>2022-08-23T16:03:13.801Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在力扣算题时，遇到股票题，觉得很有意思，于是写下自己的总结</p><h3 id="1-第一个股票问题（一次买卖）"><a href="#1-第一个股票问题（一次买卖）" class="headerlink" title="1.第一个股票问题（一次买卖）"></a>1.第一个股票问题（一次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823215745512.png" alt="image-20220823215745512"></p><blockquote><p> 首先是最简单的题目，只有一次购买，一次卖出</p><p>思路还是挺清晰的，还是DP思想：</p><ol><li>记录【今天之前买入的最小值】</li><li>计算【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】</li><li>比较【每天的最大获利】，取最大值即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当然因为我们只是用二维数组保存了两个状态，有股票和没股票，所以可以简化一下</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> prices.length;</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>,dp1 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp0 = Math.max(dp0,dp1 + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp1 = Math.max(dp1,-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回没股票的时候</span></span><br><span class="line">            <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，没股票可以从昨天的有股票卖出，或者昨天的没股票得出（当然我们要尽量去获取最大值，毕竟利润最大），有股票可以是<strong>买今天的，或者昨天的有股票得到。</strong></p></blockquote><h3 id="2-第二个股票问题（多次买卖）"><a href="#2-第二个股票问题（多次买卖）" class="headerlink" title="2.第二个股票问题（多次买卖）"></a>2.第二个股票问题（多次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823222025568.png" alt="image-20220823222025568"></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将dp[i-<span class="number">1</span>][<span class="number">0</span>] 和dp[i-<span class="number">1</span>][<span class="number">1</span>] 存放在两个变量中，通过它们计算出 dp[i][<span class="number">0</span>] 和 dp[i][<span class="number">1</span>] 并存回对应的变量，以便于第 i+<span class="number">1</span> 天的状态转移即可。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>,dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp0 = Math.max(dp0,dp1 + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp1 = Math.max(dp1,dp0 - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回没股票的时候</span></span><br><span class="line">            <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比第一题，<strong>这题多了一个条件，可以多次买卖。</strong></p><p>总之，没股票可以从昨天的有股票卖出，或者昨天的没股票得出（当然我们要尽量去获取最大值，毕竟利润最大），有股票可以是<strong>从之前没股票的状态买今天的（之前的是不能的，只能是买一次），或者昨天的有股票得到。</strong></p></blockquote><h3 id="3-第三个股票问题（两次买卖）"><a href="#3-第三个股票问题（两次买卖）" class="headerlink" title="3.第三个股票问题（两次买卖）"></a>3.第三个股票问题（两次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823230742789.png" alt="image-20220823230742789"></p><blockquote><p>相比第二问，加了条只能买卖两次的设定，这使得我们必须要记录下数次交易中的两次最大值，所以我们必须新加状态进行购买次数的限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">一天结束时，可能有持股、可能未持股、可能卖出过<span class="number">1</span>次、可能卖出过<span class="number">2</span>次、也可能未卖出过</span><br><span class="line"></span><br><span class="line">所以定义状态转移数组dp[天数][当前是否持股][卖出的次数]</span><br><span class="line"></span><br><span class="line">具体一天结束时的<span class="number">6</span>种状态：</span><br><span class="line"></span><br><span class="line">未持股，未卖出过股票：说明从未进行过买卖，利润为<span class="number">0</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">未持股，卖出过<span class="number">1</span>次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>]=max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">未持股，卖出过<span class="number">2</span>次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">2</span>]=max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>]=max(dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">持股，卖出过<span class="number">1</span>次股票：可能是今天买的，也可能是之前买的（昨天也持股）</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>]=max(dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">持股，卖出过<span class="number">2</span>次股票：最多交易<span class="number">2</span>次，这种情况不存在</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">2</span>]=<span class="type">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfitDP</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值Integer.MIN_VALUE-1=Integer.MAX_VALUE</span></span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//持有昨天的股票，或者昨天没买，今天买了</span></span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">2</span>] = MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.max(<span class="number">0</span>, Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大神版</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一天考虑四个变量:</span></span><br><span class="line"><span class="comment">        fstBuy: 在该天第一次买入股票可获得的最大收益 </span></span><br><span class="line"><span class="comment">        fstSell: 在该天第一次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secBuy: 在该天第二次买入股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secSell: 在该天第二次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        分别对四个变量进行相应的更新, 最后secSell就是最大</span></span><br><span class="line"><span class="comment">        收益值(secSell &gt;= fstSell)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fstBuy</span> <span class="operator">=</span> Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">secBuy</span> <span class="operator">=</span> Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p : prices) &#123;</span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上也是考察的是对于状态的分析变化，需要我们理清昨天和今天的状态关系</p></blockquote><h3 id="4-第四个股票问题（k次买卖）"><a href="#4-第四个股票问题（k次买卖）" class="headerlink" title="4.第四个股票问题（k次买卖）"></a>4.第四个股票问题（k次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823233637735.png" alt="image-20220823233637735"></p><blockquote><p>其实套路跟第三题一模一样，只是要求我们发现创建dp数组的规律</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>][k+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值,防止数据溢出</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>][i] = dp[<span class="number">0</span>][<span class="number">1</span>][i] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>][i] = dp[<span class="number">0</span>][<span class="number">1</span>][i] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;l&lt;=k;l++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j==<span class="number">0</span>&amp;&amp;l==<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=<span class="number">0</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>&amp;&amp;l==k)&#123;</span><br><span class="line">                            dp[i][j][l]=MIN_VALUE;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][l-<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][l]);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>][l]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][l]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">                max=Math.max(max,dp[prices.length-<span class="number">1</span>][<span class="number">0</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-第二个股票问题加上冷冻期"><a href="#5-第二个股票问题加上冷冻期" class="headerlink" title="5.第二个股票问题加上冷冻期"></a>5.第二个股票问题加上冷冻期</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823234119843.png" alt="image-20220823234119843"></p><blockquote><p>题目中定义的“冷冻期”=卖出的那一天的后一天，题目设置冷冻期的意思是，<strong>如果昨天卖出了，今天不可买入</strong>，那么关键在于哪一天卖出，只要在今天想买入的时候判断一下前一天是不是刚卖出，即可，所以关键的一天其实是卖出的那一天，而不是卖出的后一天</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//0代表不持股且当天没卖出</span></span><br><span class="line">        <span class="comment">//1代表持股</span></span><br><span class="line">        <span class="comment">//2代表不持股且当天卖出</span></span><br><span class="line">        <span class="type">int</span> [][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//从[1]...[n-1]</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">0</span>],dp[n-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者在力扣算题时，遇到股票题，觉得很有意思，于是写下自己的总结&lt;/p&gt;
&lt;h3 id=&quot;1-第一个股票问题（一次买卖）&quot;&gt;&lt;a href=&quot;#1-第一个股票问题（一次买卖）&quot; class=&quot;headerlink&quot; title=&quot;1.第一个股票问题（一次买卖）&quot;&gt;&lt;/a&gt;1.</summary>
      
    
    
    
    <category term="算法" scheme="https://gwtt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试， 动态规划" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>浅谈垃圾回收器</title>
    <link href="https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2022-08-23T02:57:34.000Z</published>
    <updated>2022-08-23T10:37:44.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h1><p>如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直至垃圾回收结束！</p><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251706505-16612506422341.jpeg" alt="img"></p><p>CMS的全称：Concurrent Mark Sweep，翻译过来是<strong>并发标记清除</strong></p><p>用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是<strong>并发</strong>：在GC线程工作的时候，用户线程<strong>不会完全停止</strong>，用户线程在<strong>部分场景下</strong>与GC线程一起并发执行。</p><p>但是，要理解的是，无论是什么垃圾收集器，Stop The World是一定无法避免的！</p><p>CMS只是在<strong>部分</strong>的GC场景下可以让GC线程与用户线程并发执行</p><p>CMS的设计目标是为了避免<strong>老年代 GC</strong>出现<strong>长时间</strong>的卡顿（Stop The World）</p><h2 id="CMS的工作流程"><a href="#CMS的工作流程" class="headerlink" title="CMS的工作流程"></a>CMS的工作流程</h2><p>CMS可以简单分为5个步骤：初始标记、并发标记、（并发预清理）、重新标记以及并发清除</p><p>从步骤就不难看出，CMS主要是实现了<strong>标记清除</strong>垃圾回收算法</p><h2 id="初始标记的过程"><a href="#初始标记的过程" class="headerlink" title="初始标记的过程"></a>初始标记的过程</h2><p><strong>初始标记</strong>会标记GCRoots<strong>直接关联</strong>的对象以及<strong>年轻代</strong>指向<strong>老年代</strong>的对象</p><p><strong>初始标记</strong>这个过程是会发生Stop The World的。但这个阶段的速度算是很快的，因为没有<strong>向下追溯</strong>（只标记一层）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251706562.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251706562.jpeg" alt="img"></a></p><h2 id="并发标记的过程"><a href="#并发标记的过程" class="headerlink" title="并发标记的过程"></a>并发标记的过程</h2><p>在<strong>初始标记</strong>完了之后，就进入了<strong>并发标记</strong>阶段啦</p><p><strong>并发标记</strong>这个过程是不会停止用户线程的（不会发生 Stop The World）。这一阶段主要是从GC Roots向下<strong>追溯</strong>，标记所有可达的对象。</p><p><strong>并发标记</strong>在GC的角度而言，是比较耗费时间的（需要追溯）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707207.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707207.jpeg" alt="img"></a></p><p><strong>并发标记</strong>这个阶段完成之后，就到了<strong>并发预处理</strong>阶段啦</p><p><strong>并发预处理</strong>这个阶段主要想干的事情：希望能减少下一个阶段<strong>重新标记</strong>所消耗的时间</p><p>因为下一个阶段<strong>重新标记</strong>是需要Stop The World的</p><p><strong>并发标记</strong>这个阶段由于用户线程是没有被挂起的，所以对象是有可能发生变化的</p><p>可能有些对象，从新生代晋升到了老年代。可能有些对象，直接分配到了老年代（大对象）。可能老年代或者新生代的对象引用发生了变化…</p><h2 id="跨代引用的问题"><a href="#跨代引用的问题" class="headerlink" title="跨代引用的问题"></a>跨代引用的问题</h2><p>针对老年代的对象，其实还是可以借助类card table的存储（将老年代对象发生变化所对应的卡页标记为dirty）</p><p>所以<strong>并发预处理</strong>这个阶段会扫描可能由于<strong>并发标记</strong>时导致老年代发生变化的对象，会再扫描一遍标记为dirty的卡页</p><p>对于新生代的对象，我们还是得遍历新生代来看看在<strong>并发标记</strong>过程中有没有对象引用了老年代..</p><p>不过JVM里给我们提供了很多<strong>参数</strong>，有可能在这个过程中会触发一次 minor GC（触发了minor GC 是意味着就可以更少地遍历新生代的对象）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707070.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707070.jpeg" alt="img"></a></p><h2 id="重新标记的过程"><a href="#重新标记的过程" class="headerlink" title="重新标记的过程"></a>重新标记的过程</h2><p><strong>并发预处理</strong>这个阶段阶段结束后，就到了<strong>重新标记</strong>阶段</p><p><strong>重新标记</strong>阶段会Stop The World，这个过程的停顿时间其实很大程度上取决于上面<strong>并发预处理</strong>阶段（可以发现，这是一个追赶的过程：一边在标记存活对象，一边用户线程在执行产生垃圾）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707172.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707172.jpeg" alt="img"></a></p><h2 id="并发清除的过程"><a href="#并发清除的过程" class="headerlink" title="并发清除的过程"></a>并发清除的过程</h2><p>最后就是<strong>并发清除</strong>阶段，不会Stop The World</p><p>一边用户线程在执行，一边GC线程在回收不可达的对象</p><p>这个过程，还是有可能用户线程在不断产生垃圾，但只能留到下一次GC 进行处理了，产生的这些垃圾被叫做“浮动垃圾”</p><p>完了以后会重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207252308270.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207252308270.jpeg" alt="img"></a></p><h2 id="CMS的缺点"><a href="#CMS的缺点" class="headerlink" title="CMS的缺点"></a>CMS的缺点</h2><ol><li>空间需要预留：CMS垃圾收集器可以一边回收垃圾，一边处理用户线程，那需要在这个过程中保证有充足的内存空间供用户使用。如果CMS运行过程中预留的空间不够用了，会报错（Concurrent Mode Failure），这时会启动 Serial Old垃圾收集器进行老年代的垃圾回收，会导致停顿的时间很长。显然啦，空间预留多少，肯定是有参数配置的。</li><li><strong>浮动垃圾</strong>：由于垃圾回收和用户线程是同时进行的，在进行标记或者清除的同时，用户的线程还会去改变对象的引用，使得原来某些对象不是垃圾，但是当 CMS 进行清理的时候变成了垃圾，CMS 收集器无法收集，只能等到下一次 GC。CMS 收集器无法处理<strong>浮动垃圾</strong>（Floating Garbage），可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。如果在应用中老年代增长不是太快，可以适当调高参数 - XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。</li><li>内存碎片问题：CMS本质上是实现了<strong>标记清除算法</strong>的收集器（从过程就可以看得出），这会意味着会产生内存碎片。由于碎片太多，又可能会导致内存空间不足所触发full GC，CMS一般会在触发full GC这个过程对碎片进行整理。整理涉及到<strong>移动</strong>/<strong>标记</strong>，那这个过程肯定会Stop The World的，如果内存足够大（意味着可能装载的对象足够多），那这个过程卡顿也是需要一定的时间的。</li></ol><h2 id="补充面试题"><a href="#补充面试题" class="headerlink" title="补充面试题:"></a>补充面试题:</h2><h3 id="1-CMS的过程？"><a href="#1-CMS的过程？" class="headerlink" title="1.CMS的过程？"></a>1.CMS的过程？</h3><blockquote><p>初始标记、并发标记、（并发预清理）、重新标记以及并发清除</p></blockquote><h3 id="2-怎么标记垃圾的？"><a href="#2-怎么标记垃圾的？" class="headerlink" title="2,怎么标记垃圾的？"></a>2,怎么标记垃圾的？</h3><blockquote><p>使用三色标记法</p></blockquote><h3 id="3-什么是三色标记法"><a href="#3-什么是三色标记法" class="headerlink" title="3.什么是三色标记法"></a>3.什么是三色标记法</h3><blockquote><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Nzk4NTU2,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>　三色标记法，是把内存中的对象，标记为3种颜色，分布是：黑、灰、白。(<strong>上文图中的红色仅供参考</strong>)</p><ul><li><p>黑：表示该对象已经扫描到，并且它可触达的对象也已经扫描到；</p></li><li><p>灰：表示该对象已经扫描到，但是它能触发的对象至少还有一个没有扫描到；</p></li><li><p>白：表示该节点没有被扫描到；</p></li></ul></blockquote><h3 id="4-CMS和G1的区别"><a href="#4-CMS和G1的区别" class="headerlink" title="4.CMS和G1的区别"></a>4.CMS和G1的区别</h3><blockquote><ul><li>G1和CMS都分为4个阶段,前三个阶段基本相同都为初始标记,并发标记,再次标记,区别在于最后清除阶段CMS是并发的,G1不是并发的,因此CMS最终会产生浮动垃圾,只能等待下次gc才能清除</li><li>G1可以管理整个堆,而CMS只能作用于老年代,并且CMS在老年代使用的是标记清除算法,会产生内存碎片,而G1使用标记整理算法,不会产生内存碎片</li><li>G1相比于CMS最大的区别是G1将内存划分为大小相等的Region,可以选择垃圾对象多的Region而不是整个堆从而减少STW,同时使用Region可以更精确控制收集,我们可以手动明确一个垃圾回收的最大时间</li></ul></blockquote><h3 id="5-CMS什么时候会STW？为什么要STW（咋瓦鲁多）"><a href="#5-CMS什么时候会STW？为什么要STW（咋瓦鲁多）" class="headerlink" title="5.CMS什么时候会STW？为什么要STW（咋瓦鲁多）?"></a>5.CMS什么时候会STW？为什么要STW（咋瓦鲁多）?</h3><blockquote><p><strong>初始标记和重新标记的时候</strong></p><p>因为初始标记标记的是GC Root，而GC Root容易变动，比如栈帧中的本地变量表。所以需要STW。</p><p>因为在重新标记之前是并发标记，在并发标记的期间会出现漏标和多标的对象，所以为了修正这部分对象，需要在重新标记期间STW。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMS垃圾回收器&quot;&gt;&lt;a href=&quot;#CMS垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;CMS垃圾回收器&quot;&gt;&lt;/a&gt;CMS垃圾回收器&lt;/h1&gt;&lt;p&gt;如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Jvm" scheme="https://gwtt.github.io/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法</title>
    <link href="https://gwtt.github.io/2022/08/20/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://gwtt.github.io/2022/08/20/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-08-20T06:28:34.000Z</published>
    <updated>2022-08-20T09:36:46.178Z</updated>
    
    <content type="html"><![CDATA[<p> 下图展示了十大排序的名字和大致用法 </p><h3 id><a href="#" class="headerlink" title></a><img src="https://pic.leetcode-cn.com/1652691519-SVKUkM-image.png" alt="image.png"></h3><blockquote><p>说到排序，首先要用到就是交换数字，接下来谈谈三次交换方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: 利用临时数tmp</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二: 利用加减运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapCal</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>; <span class="comment">// 若无法保证swapCal被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span></span><br><span class="line">    arr[i] = arr[i] + arr[j]; <span class="comment">// a = a + b</span></span><br><span class="line">    arr[j] = arr[i] - arr[j]; <span class="comment">// b = a - b</span></span><br><span class="line">    arr[i] = arr[i] - arr[j]; <span class="comment">// a = a - b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三: 利用异或运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapXOR</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>; <span class="comment">// 若无法保证swapXOR被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// a = a ^ b，也可写成 arr[i] ^= arr[j];</span></span><br><span class="line">    arr[j] = arr[i] ^ arr[j]; <span class="comment">// b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a， 也可写成 arr[j] ^= arr[i];</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// a = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b， 也可写成 arr[i] ^= arr[j];</span></span><br><span class="line">&#125;</span><br><span class="line">方法一: 利用一个临时数 tmp 来交换 arr[i] ，arr[j] 。</span><br><span class="line">方法二: 利用 arr[i] 和和 arr[j] 的加减运算避免临时数 tmp 的开销，但由于涉及到加减法可能导致数字 「提前溢出」 。</span><br><span class="line">方法三: 利用位运算中的 异或 运算，能够避免 tmp 的开销且不会导致数字溢出。</span><br></pre></td></tr></table></figure></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>从第一位开始向后依次比较，如果前者大则交换（实际根据大小方向），循环arr.length-1次</p><h4 id="最笨的形式"><a href="#最笨的形式" class="headerlink" title="最笨的形式"></a>最笨的形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="提前结束优化"><a href="#提前结束优化" class="headerlink" title="提前结束优化"></a>提前结束优化</h5><p>当某一轮比较均未发生交换，说明排序已完成，可设置一个布尔值记录一轮排序是否有发生交换，若无则提前退出循环结束程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1轮次执行，当前 n - 1 个元素排好后，最后一个元素无需执行，故i &lt; arr.length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 本轮执行是否有交换的标志，若无则false，若有则true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 若左大于右则交换，并将swapped置为true</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无交换，表示当前数组已完全排序，退出大循环</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="冒泡界优化"><a href="#冒泡界优化" class="headerlink" title="冒泡界优化"></a>冒泡界优化</h5><p>记录前一轮交换的最终位置，说明该位置之后的元素为已排序状态，下一轮的交换只需执行到该处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastSwappedIdx</span> <span class="operator">=</span> arr.length - <span class="number">1</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">swappedIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// lastSwappedIdx表示前一轮交换的最终位置，即下标为lastSwappedIdx是未排序部分中的最后一个数的下标，</span></span><br><span class="line">    <span class="comment">// 因此for中的界是i &lt; lastSwappedIdx而不需要写成i &lt;= lastSwappedIdx</span></span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123; <span class="comment">// 当swapped = false时，排序完成</span></span><br><span class="line">        <span class="comment">// 本轮执行是否有交换的标志，若无则true，若有则false</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lastSwappedIdx; i++) &#123;</span><br><span class="line">            <span class="comment">// 若左大于右则交换，并将swapped置为true</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                swappedIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastSwappedIdx = swappedIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n^2)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>每一轮循环选一个最小（或者最大）的数放到第i位，循环arr.length-1次</p><h4 id="单元选择排序"><a href="#单元选择排序" class="headerlink" title="单元选择排序"></a>单元选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1 轮次执行,当前 n - 1 个元素排好后，最后一个元素无需执行，故 i &lt; arr.length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 找到本轮执行中最小的元素，将最小值下标赋值给min</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])  minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若本轮第一个数字不是最小值，则交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双元选择排序"><a href="#双元选择排序" class="headerlink" title="双元选择排序"></a>双元选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectSortDouble(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">// 每轮确定两个数字，因此界也会动态变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span> - i; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i, maxIdx = i;</span><br><span class="line">        <span class="comment">// 找到本轮执行中最小和最大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) minIdx = j;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[maxIdx]) maxIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若本轮最大值等于最小值，说明未排序部分所有元素相等，无需再排序</span></span><br><span class="line">        <span class="keyword">if</span>(minIdx == maxIdx) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 若本轮第一个数字不是最小值，则交换位置（将最小值与本轮第一个数字交换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) swap(arr, i, minIdx);</span><br><span class="line">        <span class="comment">// 在交换i和minIdx时，有可能出现i即maxIdx的情况，此时需要修改maxIdx为minIdx</span></span><br><span class="line">        <span class="keyword">if</span>(maxIdx == i) maxIdx = minIdx;</span><br><span class="line">        <span class="comment">// 若本轮最后一个数字不是最大值，则交换位置（将最大值与本轮最后一个数字交换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (maxIdx != n - <span class="number">1</span> - i) swap(arr, n - <span class="number">1</span> - i, maxIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间:O(n^2)</strong></p><p><strong>空间:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>对于待排序数组，从第2个元素开始(称作插入对象元素)，比较它与之前的元素(称作比较对象元素)，当插入对象元素小于比较对象元素时，继续往前比较，直到不小于(≥)比较对象，此时将插入对象元素插入到该次比较对象元素之后。重复这个插入过程直到最后一个元素作为插入对象元素完成插入操作。</p><h4 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// N-1轮次执行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; arr[j]) arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = target; <span class="comment">// 若发生移动，此时的插入对象数字≥j位置的数字，故插入位置为j + 1，若未移动也成立，无需判断</span></span><br><span class="line">        <span class="comment">// if(j != i - 1) arr[j + 1] = target; // 也可以用这种写法，表示发生移动才插入，否则不必插入(赋值)，但不判断效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="折半插入优化-利用二分来减少中间比较次数"><a href="#折半插入优化-利用二分来减少中间比较次数" class="headerlink" title="折半插入优化(利用二分来减少中间比较次数)"></a>折半插入优化(利用二分来减少中间比较次数)</h4><p>注意到插入排序的每一轮向前插入都使得该元素在完成插入后，从第一个元素到该元素是排序状态（指这部分的相对排序状态，在它们中间后续可能还会插入其他数字），利用这一点，对一个新的插入对象向前执行折半插入，能够显著减少比较的次数。另一种优化是增量递减插入排序，也叫希尔排序，将在希尔排序章节中介绍。</p><p>折半插入的关键在于找到插入位置，折半过程代码如下。这实际上是二分查找「模版一」中的「小于等于」情形。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSortBinary(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1 轮次执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 若当前插入对象大于等于前一个对象，无需插入</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &lt;= arr[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">// 折半查找 (二分查找「模版一」)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// while结束后，target要插入的位置为low或high + 1 (low = high + 1)</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[center] &lt;= target) low = center + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = center - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; low; j--) &#123; <span class="comment">// 移动</span></span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = target; <span class="comment">// 插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间:O(n^2)</strong></p><p><strong>空间:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="Shell增量"><a href="#Shell增量" class="headerlink" title="Shell增量"></a>Shell增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序：采用Shell增量 N / 2^k</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortShell(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// gap 初始为 n/2，缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; n; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Hibbard增量"><a href="#Hibbard增量" class="headerlink" title="Hibbard增量"></a>Hibbard增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序： 采用Hibbard增量 &#123;1, 3, 7, 15,...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortHibbard(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n / <span class="number">2</span>) gap = gap * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 初始化gap (Hibbard增量序列)</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// 缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; arr.length; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Knuth增量"><a href="#Knuth增量" class="headerlink" title="Knuth增量"></a>Knuth增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序： 采用Knuth增量 &#123;1, 4, 13, 40,...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortKnuth(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n / <span class="number">3</span>) gap = gap * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 初始化gap (Knuth增量序列)</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123; <span class="comment">// 缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; arr.length; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单插入排序和希尔排序比较</p><p><img src="https://pic.leetcode-cn.com/1653024423-RVrPou-image.png" alt="image.png"></p></blockquote><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序是 <strong>分治思想</strong> 的应用，即将原待排数组 <strong>递归或迭代地</strong> 分为左右两半，直到数组长度为1，然后对左右数组进行合并(merge)，在合并中完成排序。</p><p><strong>自顶向下</strong>(top-down)：从输入数组出发，不断二分该数组，直到数组长度为1，再执行合并。适合用 递归 实现。</p><p><strong>自底向上</strong>(bottom-up)：从输入数组的单个元素出发，一一合并，二二合并，四四合并直到数组有序。适合用 迭代 实现。</p><h4 id="自顶向下非原地归并"><a href="#自顶向下非原地归并" class="headerlink" title="自顶向下非原地归并"></a>自顶向下非原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, tmpArr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, tmpArr, left, center);</span><br><span class="line">        mergeSort(arr, tmpArr, center + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tmpArr, left, center, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原地合并方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> leftPos, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightPos</span> <span class="operator">=</span> leftEnd + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">startIdx</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpPos</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="keyword">while</span> (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[leftPos] &lt;= arr[rightPos]) &#123;</span><br><span class="line">            tmpArr[tmpPos++] = arr[leftPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmpArr[tmpPos++] = arr[rightPos++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后若左数组还有剩余，则将其添加到tmpArr剩余空间</span></span><br><span class="line">    <span class="keyword">while</span> (leftPos &lt;= leftEnd) &#123;</span><br><span class="line">        tmpArr[tmpPos++] = arr[leftPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后若右数组还有剩余，则将其添加到tmpArr剩余空间</span></span><br><span class="line">    <span class="keyword">while</span> (rightPos &lt;= rightEnd) &#123;</span><br><span class="line">        tmpArr[tmpPos++] = arr[rightPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容易遗漏的步骤，将tmpArr拷回arr中</span></span><br><span class="line">    <span class="comment">// 从小区间排序到大区间排序，大区间包含原来的小区间，需要从arr再对应比较排序到tmpArr中，</span></span><br><span class="line">    <span class="comment">// 所以arr也需要动态更新为排序状态，即随时将tmpArr拷回到arr中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt;= rightEnd; i++) &#123;</span><br><span class="line">        arr[i] = tmpArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自顶向下原地归并"><a href="#自顶向下原地归并" class="headerlink" title="自顶向下原地归并"></a>自顶向下原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, center);</span><br><span class="line">        mergeSort(arr, center + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, center, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地归并（手摇算法）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> leftPos, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftPos, j = leftEnd + <span class="number">1</span>; <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt;= arr[j]) i++; <span class="comment">// #2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j; <span class="comment">// #3</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= rightEnd &amp;&amp; arr[j] &lt; arr[i]) j++; <span class="comment">// #4 注意是 arr[j] &lt; arr[i]，即找到j使得arr[j] 为第一个大于等于 arr[i]值</span></span><br><span class="line">        exchange(arr, i, index - <span class="number">1</span>, j - <span class="number">1</span>); <span class="comment">// #5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三次翻转实现交换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    reverse(arr, left, leftEnd);</span><br><span class="line">    reverse(arr, leftEnd + <span class="number">1</span>, rightEnd);</span><br><span class="line">    reverse(arr, left, rightEnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        swap(arr, start, end);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自底向上非原地归并"><a href="#自底向上非原地归并" class="headerlink" title="自底向上非原地归并"></a>自底向上非原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSortBU(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="comment">// 间隔，注意不能写成gap &lt; arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; arr.length; gap *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - gap; left += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="comment">// 调用非原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;</span></span><br><span class="line">            merge(arr, tmpArr, left, left + gap - <span class="number">1</span>, Math.min(left + <span class="number">2</span> * gap - <span class="number">1</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自底向上原地归并"><a href="#自底向上原地归并" class="headerlink" title="自底向上原地归并"></a>自底向上原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSortBUInPlace(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 间隔，注意不能写成gap &lt; arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; arr.length; gap *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - gap; left += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="comment">// 调用原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;</span></span><br><span class="line">            merge(arr, left, left + gap - <span class="number">1</span>, Math.min(left + <span class="number">2</span> * gap - <span class="number">1</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p><strong>与归并排序一样，快速排序也是一种利用 分治思想 的排序方法，确定 主轴及分区 是快速排序的核心操作。首先在数组中确定一个主轴元素(下标记为 pivot)，然后将数组分为两部分，小于主轴的放在（确定最终位置的）主轴左侧，大于等于主轴的放在主轴右侧。递归地对主轴左右两侧数组执行这个过程，每次递归都传入待排序数组 arr 和本次要处理的部分的左右界，只处理这个范围内的序列。当所有递归都到达基准情形时，排序完成。因为是原地交换，递归过程中 arr总是在动态排序，递归过程无需返回，为尾递归形式。</strong></p><h4 id="递归快排"><a href="#递归快排" class="headerlink" title="递归快排"></a>递归快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三数取中快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortMedian3(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    quickSortMedian3(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortMedian3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; right) &#123; </span><br><span class="line">        <span class="comment">// 执行median3将左，中，右三数中值放到left位置上</span></span><br><span class="line">        median3(arr, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortMedian3(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortMedian3(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将left, center, right下标三个数中，大小居中者放到left下标处</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">median3</span><span class="params">(<span class="type">int</span>[]arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[c]) swap(arr, l, c); <span class="comment">// 左中，大者居中</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[r]) swap(arr, c, r); <span class="comment">// 中右，大者居右，此时最大者居右</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[l]) swap(arr, l, c); <span class="comment">// 左中，大者居左，此时中者居左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机主轴快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortRandom(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSortRandom(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortRandom</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 取区间内随机下标，注意Random().nextInt(int x)方法的使用（含0不含x）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left) + left + <span class="number">1</span>; <span class="comment">// 在[left + 1, right]范围内的随机值</span></span><br><span class="line">        <span class="comment">// 交换随机取得的下标元素与当前起始元素</span></span><br><span class="line">        swap(arr, left, randomIndex); <span class="comment">// arr[left]与它之后的某个数交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortRandom(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortRandom(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素快排(首位为主轴)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortSimple(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    quickSortSimple(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortSimple</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 若left == right，表示此时arr只有一个元素，即为基准情形，完成递归(准确说是完成递进)</span></span><br><span class="line">    <span class="comment">// (尾递归，“回归”过程中不做任何事情）</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortSimple(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortSimple(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//　partition方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left, index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意此时right是坐标，要执行到最后一个元素，所以是&lt;=</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, index, i);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个小于主轴元素的元素下标是index - 1</span></span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="非递归快排-迭代快排"><a href="#非递归快排-迭代快排" class="headerlink" title="非递归快排 (迭代快排)"></a><strong>非递归快排 (迭代快排)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortStack(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 用于保存区间左右边界的栈，按right到left的顺序将初始区间界入栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 判断栈是否空，不空则弹出一对left，right界</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop(), right = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123; <span class="comment">// 执行partition的前提是left小于right</span></span><br><span class="line">            <span class="comment">// 对[left, right]区间执行partition方法，得到pivot</span></span><br><span class="line">              <span class="comment">// 加入后续两行实现随机轴快排</span></span><br><span class="line">            <span class="comment">// int randomIndex = new Random().nextInt(right - left) + left + 1; // 在[left + 1, right]范围内的随机值</span></span><br><span class="line">            <span class="comment">// swap(arr, left, randomIndex); // arr[left]与它之后的某个数交换</span></span><br><span class="line">              <span class="comment">// 加入下行实现三数取中快排</span></span><br><span class="line">            median3(arr, left, right);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            <span class="comment">// 当前pivot的左区间存在则将该区间right，left界入栈</span></span><br><span class="line">            <span class="keyword">if</span>(pivot &gt; left) &#123;</span><br><span class="line">                stack.push(pivot - <span class="number">1</span>);</span><br><span class="line">                stack.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前pivot的右区间存在则将该区间right，left界入栈</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt; pivot) &#123;</span><br><span class="line">                stack.push(right);</span><br><span class="line">                stack.push(pivot + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(logn)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>将输入数组建立为一个 <strong>大顶堆</strong>，之后反复取出堆顶并对剩余元素重建大顶堆，将依次取出的堆顶逆序排列，即可将原数组从小到大排列完成排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    heapify(arr, arr.length - <span class="number">1</span>); <span class="comment">// 构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// i &gt; 0即可，无需写成i &gt;= 0，当n - 1个元素排序时，最后一个元素也已排序</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i); <span class="comment">// 交换堆顶和当前未排序部分最后一个元素</span></span><br><span class="line">        <span class="comment">// 此时除当前堆顶元素外都是保持堆序的，只需要对该堆顶调用一次下滤操作</span></span><br><span class="line">        siftDown(arr, <span class="number">0</span>, i - <span class="number">1</span>); <span class="comment">// i - 1是未排序部分最后一个元素下标，确保下滤不会超过此范围</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> endIdx)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hole</span> <span class="operator">=</span> (endIdx - <span class="number">1</span>) / <span class="number">2</span>; hole &gt;= <span class="number">0</span>; hole--) &#123; <span class="comment">// (endIdx - 1) / 2伪最后一个非叶子节点下标</span></span><br><span class="line">        siftDown(arr, hole, endIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> hole, <span class="type">int</span> endIdx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[hole]; <span class="comment">// target是要下滤的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= endIdx) &#123;</span><br><span class="line">        <span class="comment">// 满足第一个条件child &lt; endIdx表示hole有右孩子，不满足则hole无右孩子，跳过</span></span><br><span class="line">        <span class="comment">// 第二个条件arr[child + 1] &gt; arr[child]只在第一个条件成立前提下进行判断（因此不必担心arr[child + 1]越界），</span></span><br><span class="line">        <span class="comment">// 若满足，表示hole有右孩子且右孩子更大，令child为右孩子下标。</span></span><br><span class="line">        <span class="comment">// 因此此if过后使得child是hole的孩子中较大的那个</span></span><br><span class="line">        <span class="keyword">if</span> (child &lt; endIdx &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若child大于target，则child上移到当前hole，hole下滤到child位置 </span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &gt; target) &#123;</span><br><span class="line">            arr[hole] = arr[child];</span><br><span class="line">            hole = child;</span><br><span class="line">            child = hole * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 当然也可以写成child = child * 2 + 1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 若无需交换hole与child，说明hole已经满足堆序(无需/无法再下滤)，退出while</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[hole] = target; <span class="comment">// 将target填入hole中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><blockquote><h4 id="计数排序的特征"><a href="#计数排序的特征" class="headerlink" title="计数排序的特征"></a><strong>计数排序的特征</strong></h4><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><p> 算法的步骤如下：</p><ul><li>（1）找出待排序的数组中最大和最小的元素</li><li>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><h4 id="不稳定计数排序"><a href="#不稳定计数排序" class="headerlink" title="不稳定计数排序"></a>不稳定计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSortUnstable(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArr[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countArr.length; i++) &#123; <span class="comment">// 遍历countArr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countArr[i]; j++) &#123; <span class="comment">// countArr[i]可能有多个相同数字</span></span><br><span class="line">            arr[index] = i + min; <span class="comment">// 复用了原输入数组arr</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="稳定计数排序"><a href="#稳定计数排序" class="headerlink" title="稳定计数排序"></a>稳定计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>]; <span class="comment">// arr最多有max-min+1种数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        countArr[arr[i] - min]++; <span class="comment">// arr[i]的值出现一次，则countArr[arr[i]-min]加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; countArr.length; i++) &#123; <span class="comment">// 变形</span></span><br><span class="line">        countArr[i] += countArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 根据sortedArr, nums, countArr三者关系完成sortedArr的输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sortedArr[countArr[arr[i] - min] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        countArr[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n+k)</strong></p><p><strong>空间复杂度:O(n+k)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><blockquote><p>非比较排序，「基」指的是数的位，例如十进制数 123，共有百十个位，共 3 个位。基数排序 按数字的位进行循环，每一轮操作都是对当前位（基数）的计数排序，使得输出到 arr 后所有数字在截止到当前位上（即去掉未考察的位后）是排序状态，考察完最大位后完成排序。具体过程如下：</p><ul><li>遍历待排序数组 arr ，找到最大值，计算其位数，例如 arr 中最大数为 123 ，则 maxDigitLen = 3 。</li><li>数组的数字为 n 进制，就创建大小为 n 的计数数组 countArr ，也可以称为 n 个桶。</li><li>开始「位」的 for 循环，循环次数等于 maxDigitLen ，每一轮对 当前所有数字的当前位 执行一次 计数排序。</li><li>每次计数排序结束后将结果写回 arr 。</li><li>for循环结束后返回排序结果 arr。</li></ul><h4 id="以计数排序为基础"><a href="#以计数排序为基础" class="headerlink" title="以计数排序为基础"></a>以计数排序为基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.abs(arr[<span class="number">0</span>]); <span class="comment">// 找到arr中绝对值最大者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigitLen</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">10</span>; <span class="comment">// 最大位数 &amp; 基（几进制就是几）</span></span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLen++;</span><br><span class="line">        max /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在接下来的for中，每一轮都对当前位(基数)执行一次计数排序</span></span><br><span class="line">    <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigitLen; i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">19</span>]; <span class="comment">// 处理负数优化</span></span><br><span class="line">        <span class="comment">// 根据每一个数字当前位的数字，累计相应位置的计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 此步处理要注意，当base大于10时，例如base=100时，1234%100=34</span></span><br><span class="line">            <span class="comment">// 还需要再除以(base/10)，得到的3，然后再+9（考虑负数）才是本次的bucketIdx</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>;</span><br><span class="line">            countArr[bucketIdx]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// countArr变形，得到每个下标所代表的arr中的数的当前位在arr中的最大位置（从1开始）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; countArr.length; j++) &#123;</span><br><span class="line">            countArr[j] += countArr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序输出保持稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">thisBase</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>;</span><br><span class="line">            <span class="comment">// countArr[thisBase]得到的从1开始计算的位置，转成下标要-1</span></span><br><span class="line">            sortedArr[countArr[thisBase] - <span class="number">1</span>] = arr[j]; </span><br><span class="line">            countArr[thisBase]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成当前位的计数排序后将排序结果拷贝回原数组</span></span><br><span class="line">        arr = Arrays.copyOf(sortedArr, sortedArr.length);</span><br><span class="line">        <span class="comment">// base进一位，准备下一轮对下一位的计数排序</span></span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="不以计数排序为基础"><a href="#不以计数排序为基础" class="headerlink" title="不以计数排序为基础"></a>不以计数排序为基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 找到arr中绝对值最大者</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.abs(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigitLen</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">10</span>; <span class="comment">// 最大位数 &amp; 基</span></span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLen++;</span><br><span class="line">        max /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arr.length + 1的作用是令每个桶的第0位保存该桶的元素个数。</span></span><br><span class="line">    <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">19</span>][arr.length + <span class="number">1</span>]; <span class="comment">// 处理负数优化</span></span><br><span class="line">    <span class="comment">// 在每一位上将数组中所有具有该位的数字装入对应桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigitLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 此步处理要注意，当base大于10时，例如base=100时，1234%100=34</span></span><br><span class="line">            <span class="comment">// 还需要再除以(base/10)，得到的3才是本次的bucketIndex</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>; <span class="comment">// +9使其可以处理负数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentBucketQuantity</span> <span class="operator">=</span> buckets[bucketIdx][<span class="number">0</span>];</span><br><span class="line">            buckets[bucketIdx][currentBucketQuantity + <span class="number">1</span>] = arr[j];</span><br><span class="line">            buckets[bucketIdx][<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前所有桶的数按桶序，桶内按低到高输出为本轮排序结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= buckets[j][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">                arr[arrIdx++] = buckets[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一轮过后将桶计数归零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) bucket[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        base *= <span class="number">10</span>; <span class="comment">// 调整base</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(d(n+k))</strong></p><p><strong>空间复杂度:O(n+k)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote><p>桶排序将原数组划分到称为 「桶」 的多个区间中，然后对每个桶单独进行排序，之后再按桶序和桶内序输出结果。适合于分布较均匀的数据，具体做法如下。</p><ul><li><p>根据数据规模按照 一定的方法 将待排序数组arr划分为多个区间，每个区间称作一个桶。</p></li><li><p>每个桶可以是数组，也可以是泛型容器，用于保存arr中落在该桶范围内的数。</p></li><li><p>对每一个桶都单独排序，需要 以适当的排序 方法支持，例如插入排序，快速排序等。</p></li><li><p>所有桶完成排序后，按桶序，桶内序依次输出所有元素，得到arr的排序结果。</p><p><strong>稳定性：取决于桶内排序方法的稳定性。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用泛型List存储所有桶，每个桶是一个ArrayList&lt;Integer&gt;，并初始化所有桶。</span></span><br><span class="line">    <span class="comment">// arr.length/3表示设置数组大小三分之一数量的桶</span></span><br><span class="line">    List&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr.length / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历arr，根据元素值将所有元素装入对应值区间的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// (arr[i] - min)/D为arr[i]元素应该装入的桶的下标，间隔D = (max-min)/(arr.length-1)</span></span><br><span class="line">        <span class="comment">// 虽可写成(arr[i] - min)*(arr.length-1)/(max-min)的形式，但当输入数组取值范围较大且元素较多时</span></span><br><span class="line">        <span class="comment">// (arr[i] - min)*(arr.length-1)可能会超过int上限，因此先做除法求出double类型的D</span></span><br><span class="line">        <span class="comment">// 再做一次除法求出bucketIndex，可以避免计算精度不够高带来的问题</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">interval</span> <span class="operator">=</span> (<span class="type">double</span>)(max - min) / (<span class="type">double</span>)(arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (<span class="type">int</span>) ((arr[i] - min) / interval);</span><br><span class="line">        buckets.get(bucketIdx).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序(调用库函数，从小到大)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.size(); i++) &#123;</span><br><span class="line">        Collections.sort(buckets.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sortedItem : bucket) &#123;</span><br><span class="line">            arr[index] = sortedItem; <span class="comment">// 复用输入数组arr</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 下图展示了十大排序的名字和大致用法 &lt;/p&gt;
&lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;img src=&quot;https://pic.leetcode-cn.com/1652691519-SVKUkM-image.png</summary>
      
    
    
    
    <category term="算法" scheme="https://gwtt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试， 排序" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C-%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux面试(1)</title>
    <link href="https://gwtt.github.io/2022/08/18/Linux%E9%9D%A2%E8%AF%95(1)/"/>
    <id>https://gwtt.github.io/2022/08/18/Linux%E9%9D%A2%E8%AF%95(1)/</id>
    <published>2022-08-18T14:23:13.000Z</published>
    <updated>2022-08-19T10:15:34.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-在Linux系统中如何统计某个字符串出现的次数"><a href="#1-在Linux系统中如何统计某个字符串出现的次数" class="headerlink" title="1.在Linux系统中如何统计某个字符串出现的次数"></a>1.在Linux系统中如何统计某个字符串出现的次数</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -o targetStr filename | wc -l（单个字符串）</span><br><span class="line">&quot;targetStr&quot;可以不加引号</span><br><span class="line">grep -o targetStr_1\|targetStr_2\|targetStr_3…… filename | wc -l</span><br><span class="line">&quot;targetStr_1&quot;这些必须加引号</span><br><span class="line">但是上面的方法是不准确的，因为wc -l只是显示行数，如果一行字符串多次出现，那么结果不准确</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-在Linux系统中如何统计某个字符串出现的次数&quot;&gt;&lt;a href=&quot;#1-在Linux系统中如何统计某个字符串出现的次数&quot; class=&quot;headerlink&quot; title=&quot;1.在Linux系统中如何统计某个字符串出现的次数&quot;&gt;&lt;/a&gt;1.在Linux系统中</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Linux" scheme="https://gwtt.github.io/tags/Linux/"/>
    
    <category term="面试， 指令" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C-%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="https://gwtt.github.io/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>https://gwtt.github.io/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</id>
    <published>2022-08-18T13:46:07.000Z</published>
    <updated>2022-08-23T10:54:44.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流顾名思义就是限制流量，在软件系统中就是限制流量进入软件系统。</p><h1 id="为什么要限流？"><a href="#为什么要限流？" class="headerlink" title="为什么要限流？"></a>为什么要限流？</h1><p>在实际的生活场景中，当一个 web 服务部署到生产环境，也就是我们所说的公网。这个时候就会受到互联网上所有人的访问请求，比如像百度。每天都会有很多人访问 <code>www.baidu.com</code> ，如果有些人不怀好意的拼命的访问这个网站，那么整个系统就会因为这个人的恶作剧，从而浪费了很多不必要的带宽和系统资源。</p><h1 id="限流实现"><a href="#限流实现" class="headerlink" title="限流实现"></a>限流实现</h1><p>因为我们现在的软件系统都是微服务形式的，一个 HTTP 请求可能要经过后端十几个软件服务，最后才能得到结果返回给用户。如果我们对一些请求进行限制，比如只允许某一个 IP 在 10 秒钟内访问 20 次，如果超出了这 20 次，直接最前端就返回 429 状态码。这样就保护了后端十几个服务，避免为这些恶意请求消耗系统资源。</p><h2 id="常见的几种限流算法。"><a href="#常见的几种限流算法。" class="headerlink" title="常见的几种限流算法。"></a>常见的几种限流算法。</h2><p>有想法就会有实现，当前最常见的几种限流算法有<br><strong>固定窗口计数器算法</strong> 、<strong>滑动窗口计数器算法</strong>、<strong>漏桶算法</strong>、令牌桶算法。<br>其中固定窗口计数器算法和滑动窗口计数器算法比较相似，漏桶算法和令牌桶算法比较类似。<br>以下我们用只允许一个 ip 在 10 秒钟内只能访问 20 次这个限流需求来解释这些限流算法</p><h2 id="固定窗口算法"><a href="#固定窗口算法" class="headerlink" title="固定窗口算法"></a>固定窗口算法</h2><p>固定窗口算法就是设置一个固定的时间期限，当第一条请求到来的时候就开始计时同时计数，当接下来的 10 秒中内每来一条请求计数器就＋1。当计数器值到 20 后，接下来的所有请求都拒绝。十秒钟过后重置计数器。<br>但是此算法存在一个缺陷：<br>假设以下一种场景，攻击者在知道限流窗口是 10s 的情况下，先发送一条消息，让限流算法开启计数，此时计数器为 1，然后等到第 9.5 秒的时候持续发送请求攻击，这样 9.5-10 这个时间窗口里面会被允许经过 19 条消息，过了 10 秒后计数器归零，又马上接收了 20 条请求，这样，在 9.5-10.5 这个时间窗口总共接收了 39 条消息，限流值直接放大了一倍(原本是希望最大一秒钟只有 10 条的并发量)</p><p><img src="/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/2754881-20220318110617103-964302552.png" alt="img"></p><h2 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p>滑动窗口算法就解决了上面固定窗口算法的缺陷。所谓的滑动窗口就是在原有的固定窗口上新增了一个和固定窗口大小一样的窗口，此窗口可以滑动如下图。<br><img src="/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/2754881-20220318111108896-294281716.png" alt="img"></p><p>当第1条消息来到的时候，10秒的窗口期就生成，此时滑动窗口和第1个窗口重叠。接下来在第9.5秒的时候开始发动请求攻击，在第10秒的那一刻，滑动窗口。所含钙的窗口里面的计数器的值已经达到20，接下来我们假设又过了0.5秒，此时滑动窗口来到10.5秒。这时候滑动窗口涵盖了两个窗口。此时如何计算滑动窗口中计数器的值呢？我们可以假设前面的窗口所过来的流量是按照时间均匀分布的（虽然实际上并不是）。那么这个时候我们就可以计算出一个权重。就是滑动窗口涵盖第1个窗口时间的百分比：9.5/10=0.95。那么我们就假设当前这个窗口中所占有的数据为20*0.95=19。因此接下来我们只能允许通过一条数据。同时我们也可以计算出，10-10.5秒这个区间内算出来的值肯定小于1，因此这个区间内过来的请求全部会拒绝。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法的思想类似于小时候的那道数学题，一个水缸一个水龙头放水，一个出水口出水，进水口就是攻击者的请求，放水口就是限流算法允许通过的请求的速率，当水缸满出来了，则将请求拒绝，水缸里的水就是攻击者的请求被缓存起来。<br><img src="/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/2754881-20220318111636851-1034925225.png" alt="img"></p><p>接下来还是拿上面的例子：假设水缸容量是20，放水速率是每秒2个，当攻击者突然一秒钟打过来30个请求，如果是窗口计数器算法(不管是固定还是滑动窗口)会直接一下子允许20个请求通过剩下10个拒绝，但是接下来剩余窗口时间内不允许有新的请求进来。而漏桶算法则是会缓存这20个请求剩下10个拒绝，然后以每秒2个请求的速率往下游传递。此算法不允许突发流量，永远保证下游的速率一致。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法则是在漏桶算法上进行了修改。它的思想是假设桶内有很多令牌，同时以固定速率生成令牌放到桶内，如果桶内令牌满则丢弃。当请求过来的时候只要能拿到令牌就能通行。<br>以上面例子为例：桶内存在20个令牌，当同时以每秒2个的速度生成令牌。当一次来30条请求，则由于桶内存在20个令牌，因此前20个请求都会被放行，剩下的10个请求都会被拒绝，接下来如果继续有请求过来的话，就会以每秒2个请求的速率放行，当一段时间没有请求后，桶内令牌又会存满。<br><img src="/2022/08/18/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/2754881-20220318111459982-1036389654.png" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总共介绍了四种常见的算到，</p><ul><li>固定窗口算法实现简单，但是有缺点就是会超出限流阈值两倍的请求</li><li>滑动窗口可以解决固定窗口超出限流阈值的问题，到时他的计算权重并不是准确的，而是按照时间线将请求平均在时间线上</li><li>漏桶算法不允许一定的突发流量，这有时候可能在特定场景造成请求超时。</li><li>令牌桶允许突发流量</li></ul><p>代码演示实现可以查看:<a href="https://blog.csdn.net/yangbindxj/article/details/124396314">(39条消息) 5种限流算法，7种限流方式，挡住突发流量_文晓武的博客-CSDN博客_限流算法</a></p><p>转自:<a href="https://www.cnblogs.com/geeko/p/16020359.html">几种常见的限流算法 - zhqqqy - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;限流&quot;&gt;&lt;a href=&quot;#限流&quot; class=&quot;headerlink&quot; title=&quot;限流&quot;&gt;&lt;/a&gt;限流&lt;/h1&gt;&lt;p&gt;限流顾名思义就是限制流量，在软件系统中就是限制流量进入软件系统。&lt;/p&gt;
&lt;h1 id=&quot;为什么要限流？&quot;&gt;&lt;a href=&quot;#为什么要限流</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="计算机网络" scheme="https://gwtt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>gitlab自动部署</title>
    <link href="https://gwtt.github.io/2022/08/16/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://gwtt.github.io/2022/08/16/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2022-08-16T13:32:18.000Z</published>
    <updated>2022-08-16T13:37:59.672Z</updated>
    
    <content type="html"><![CDATA[<p>接下来是我负责健康打卡的自动部署的yaml配置文件，对此进行分析。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">MAVEN_CLI_OPTS:</span> <span class="string">&quot;--batch-mode --errors --fail-at-end --show-version -s .m2/settings.xml&quot;</span></span><br><span class="line">  <span class="attr">MAVEN_OPTS:</span> <span class="string">&quot;-Dmaven.repo.local=.m2/repository&quot;</span></span><br><span class="line">  <span class="attr">PACKAGE_NAME:</span> <span class="string">&quot;healthReport.war&quot;</span></span><br><span class="line">  <span class="attr">PACKAGE_BACK_NAME:</span> <span class="string">&quot;healthReportBack.war&quot;</span></span><br><span class="line">  <span class="attr">PROD_ENV_1:</span> <span class="string">&quot;180.209.97.83&quot;</span></span><br><span class="line">  <span class="attr">PROD_ENV_2:</span> <span class="string">&quot;180.209.97.84&quot;</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">maven:3.6-openjdk-11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">verify</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build-back</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">$&#123;CI_COMMIT_REF_SLUG&#125;</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.m2/repository</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">target/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">verify:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">verify</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mvn $MAVEN_CLI_OPTS -Dmaven.test.skip=true verify&#x27;</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">java11runner92</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build-back:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mvn $MAVEN_CLI_OPTS clean package -Dmaven.test.skip=true -Pback&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mv target/$PACKAGE_NAME target/$PACKAGE_BACK_NAME&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al target&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">java11runner92</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mvn $MAVEN_CLI_OPTS package -Dmaven.test.skip=true -Pprod&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al target&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">java11runner92</span></span><br><span class="line">  <span class="comment"># artifacts:</span></span><br><span class="line">  <span class="comment">#   paths:</span></span><br><span class="line">  <span class="comment">#     - target/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-prod:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;echo &quot;$SSH_PRIVATE_KEY&quot; &gt;&gt; ./id_rsa &amp;&amp; chmod 600 ./id_rsa&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh/&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;echo -e &quot;Host *\n\tStrictHostKeyChecking no\n\n&quot; &gt; ~/.ssh/config&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al target&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;/bin/cp -rf /opt/tomcat/webapps/$PACKAGE_NAME \&quot;/opt/tomcat/webapps/$PACKAGE_NAME.$(date +\&quot;%y%m%d\&quot;)\&quot;&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;scp -i ./id_rsa -r target/$PACKAGE_NAME root@$PROD_ENV_1:/opt/tomcat/webapps/$PACKAGE_NAME&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_2 &quot;/bin/cp -rf /opt/tomcat/webapps/$PACKAGE_NAME \&quot;/opt/tomcat/webapps/$PACKAGE_NAME.$(date +\&quot;%y%m%d\&quot;)\&quot;&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;scp -i ./id_rsa -r target/$PACKAGE_NAME root@$PROD_ENV_2:/opt/tomcat/webapps/$PACKAGE_NAME&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;/bin/cp -rf /opt/tomcat/webapps/$PACKAGE_BACK_NAME \&quot;/opt/tomcat/webapps/$PACKAGE_BACK_NAME.$(date +\&quot;%y%m%d\&quot;)\&quot;&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;scp -i ./id_rsa -r target/$PACKAGE_BACK_NAME root@$PROD_ENV_1:/opt/tomcat/webapps/$PACKAGE_BACK_NAME&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_2 &quot;/bin/cp -rf /opt/tomcat/webapps/$PACKAGE_BACK_NAME \&quot;/opt/tomcat/webapps/$PACKAGE_BACK_NAME.$(date +\&quot;%y%m%d\&quot;)\&quot;&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;scp -i ./id_rsa -r target/$PACKAGE_BACK_NAME root@$PROD_ENV_2:/opt/tomcat/webapps/$PACKAGE_BACK_NAME&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">java11runner92</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接下来是我负责健康打卡的自动部署的yaml配置文件，对此进行分析。&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="运维" scheme="https://gwtt.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>泰拉瑞亚服务器搭建</title>
    <link href="https://gwtt.github.io/2022/08/10/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://gwtt.github.io/2022/08/10/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</id>
    <published>2022-08-10T07:58:02.000Z</published>
    <updated>2022-08-10T08:01:37.107Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">一、设置swap，防止内存不足</span><br><span class="line">首先查看</span><br><span class="line">free –m</span><br><span class="line">可以看到swap分区是0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、删除原有的分区</span><br><span class="line">swapoff -a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、新建分区</span><br><span class="line">dd if=/dev/zero of=/root/swapfile bs=1M count=2048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、格式化交换分区</span><br><span class="line">mkswap /root/swapfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、启动新建的swap交换分区</span><br><span class="line">swapon /root/swapfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5、添加开机启动</span><br><span class="line">进入目录</span><br><span class="line">vi /etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按（英文下状态小写的）i进入编辑模式，到达文件底部添加内容</span><br><span class="line">/root/swapfile swap swap defaults 0 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">完毕后依次按键盘 Esc-键盘shift+:+输入wq保存/退出编辑好的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6、使用命令重启服务器</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">……等待重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7、检查</span><br><span class="line">输入命令free –m</span><br><span class="line">看Swap有了数值，表示成功添加。</span><br><span class="line"></span><br><span class="line">8、进入管理员权限</span><br><span class="line">sudo su root</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">二、安装工具</span><br><span class="line">1、下载工具</span><br><span class="line"></span><br><span class="line">yum romove wget</span><br><span class="line"></span><br><span class="line">yum install -y wget</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、解压工具</span><br><span class="line">yum install -y unzip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、压缩工具</span><br><span class="line">yum install –y zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、远程管理工具</span><br><span class="line">yum install -y screen</span><br><span class="line">看到Complete!表示完成</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">三、创建目录</span><br><span class="line">1、创建父目录</span><br><span class="line">mkdir /opt/terraria</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、创建2个子目录,和存档目录</span><br><span class="line">mkdir /opt/terraria/bin keyword zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、查看目录是否创建成功</span><br><span class="line">ls /opt/terraria/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、进入zip文件夹</span><br><span class="line">cd /opt/terraria/zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5、下载泰拉瑞亚服务器包（最新版本去官网寻找）</span><br><span class="line">wget https://terraria.org/api/download/pc-dedicated-server/terraria-server-1436.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6、查看是否下载好terraria-server-1436.zip</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7、解压服务器包到bin文件夹</span><br><span class="line">unzip terraria-server-1436.zip -d ../bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8、新建服务器的配置文件</span><br><span class="line">vim ../server-config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按（英文状态小写的）i进入编辑模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">world=/opt/terraria/keyword/存档名.wld</span><br><span class="line">worldname=世界的名字</span><br><span class="line">difficulty=0</span><br><span class="line">autocreate=2</span><br><span class="line">maxplayers=4</span><br><span class="line">password=设定一个密码</span><br><span class="line">worldpath=/opt/terraria/keyword</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line">autocreate是地图大小1&lt;2&lt;3</span><br><span class="line">difficulty是难度0为普通,1为专家</span><br><span class="line">maxplayers 最大人数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按esc-shift+:- wq保存退出</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">四、启动准备</span><br><span class="line">1、放行7777端口</span><br><span class="line">启动防火墙：systemctl start firewalld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">firewall-cmd --permanent --add-port=7777/tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、给文件添加最高权限</span><br><span class="line">chmod 777 /opt/terraria/bin/1432/Linux/TerrariaServer.bin.x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、进入启动目录</span><br><span class="line">cd /opt/terraria/bin/1432/Linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、启动服务器使用自定义的配置文件</span><br><span class="line">./TerrariaServer.bin.x86_64 -config /opt/terraria/server-config</span><br><span class="line">等待加载……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、已经创建成功此时还差一步</span><br><span class="line">先退出</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编辑之前的配置文件</span><br><span class="line">vim /opt/terraria/server-config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按（英文状态小写的）i进入编辑模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分别给worldname=xx 每段前加#号</span><br><span class="line">difficulty=xx</span><br><span class="line">autocreate=xx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按esc-shift+:- wq保存退出</span><br><span class="line">目的是让注释代码让其失效，不然每次重开服务器都会生成新世界</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">五、创建新会话来运行服务器</span><br><span class="line">1、移动到服务器目录</span><br><span class="line">cd /opt/terraria/1432/Linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、创建新的screen会话，用于运行服务器</span><br><span class="line">screen -S terrariaServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、启动服务器使用自定义的配置文件</span><br><span class="line">./TerrariaServer.bin.x86_64 -config /opt/terraria/server-config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建好后,使用Ctrl+A+D退出会话，不会被关闭</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">停止服务器输入</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重新连接screen会话</span><br><span class="line">screen -R terrariaServer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="兴趣" scheme="https://gwtt.github.io/categories/%E5%85%B4%E8%B6%A3/"/>
    
    
    <category term="Linux" scheme="https://gwtt.github.io/tags/Linux/"/>
    
    <category term="游戏" scheme="https://gwtt.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap为什么线程不安全</title>
    <link href="https://gwtt.github.io/2022/08/08/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"/>
    <id>https://gwtt.github.io/2022/08/08/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/</id>
    <published>2022-08-08T11:50:18.000Z</published>
    <updated>2022-08-17T11:58:05.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h4><p>数据结构上：数组+(链表和红黑树)</p><h4 id="HashMap线程不安全问题"><a href="#HashMap线程不安全问题" class="headerlink" title="HashMap线程不安全问题"></a>HashMap线程不安全问题</h4><blockquote><p>HashMap 是线程不安全的，原因就在于 HashMap 的 <strong>rehash</strong>。<strong>rehash</strong> 是 HashMap 扩容过程种的一个步骤。 HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。 这时候，HashMap 需要扩展它的长度，也就是进行 Resize。 影响发生 Resize 的因素有两个：</p><p>1.<strong>Capacity</strong></p><p>HashMap 的当前长度。上一期曾经说过，HashMap 的长度是 2 的幂。</p><p>2.<strong>LoadFactor</strong></p><p>HashMap 负载因子，默认值为 0.75f。</p><p>衡量 HashMap 是否进行 Resize 的 条件如下：</p><p>HashMap.Size  &gt;= Capacity * LoadFactor</p><p>HashMap 的扩容主要分为两步：</p><ol><li><p>扩容</p><p>创建一个新的 Entry 空数组，长度是原数组的 2 倍</p></li><li><p>ReHash</p><p>遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组。为什么要重新 Hash 呢？因为长度扩大以后，Hash 的规则也随之改变。</p><p>让我们回顾一下 Hash 公式：</p><p>index = HashCode（Key） &amp; （Length - 1）**(计算哈希索引)**</p><p>当原数组长度为 8 时，Hash 运算是和 111B 做与运算；新数组长度为 16，Hash 运算是和 1111B 做与运算。Hash 结果显然不同。</p><p>ReHash 的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上过程单线程下不会出现问题，但是当两个线程同时触发resize的时候就有可能出现问题</p><p>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/171705_8KHj_1860759.png" alt="img"></p><p>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/171730_nKJe_1860759.png" alt="img"></p><p>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure><p>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：</p><p>e = Entry3</p><p>next = Entry2</p><p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174539_nVJj_1860759.png" alt="img"></p><p>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。线程B刚才的状态是：</p><p>e = Entry3</p><p>next = Entry2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br></pre></td></tr></table></figure><p>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：</p><p>e = Entry2</p><p>next = Entry2</p><p>整体情况如图所示：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174637_jMIL_1860759.png" alt="img"></p><p>接着是新一轮循环，又执行到红框内的代码行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure><p>e = Entry2</p><p>next = Entry3</p><p>整体情况如图所示：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174707_4fJ8_1860759.png" alt="img"></p><p>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>整体情况如图所示：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174732_ZDEZ_1860759.png" alt="img"></p><p>第三次循环开始，又执行到红框的代码：</p><p>e = Entry3</p><p>next = Entry3.next = null</p><p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[i];</span><br></pre></td></tr></table></figure><p>newTable[i] = Entry2</p><p>e = Entry3</p><p>Entry2.next = Entry3</p><p>Entry3.next = Entry2</p><p>链表出现了环形！</p><p>整体情况如图所示：</p><p><img src="https://static.oschina.net/uploads/space/2017/1229/174818_kap6_1860759.png" alt="img"></p><p>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！**(此问题在JDK8中已经解决，上图过程看看就好)**</p><p>主要的问题是，两个线程在同一个数组索引下标添加元素时，比如A添加key2,B添加key3,会可能导致key2或者key3丢失。</p></li></ol></blockquote><h3 id="ConCurrentHashMap安全吗，是怎么保证安全的？"><a href="#ConCurrentHashMap安全吗，是怎么保证安全的？" class="headerlink" title="ConCurrentHashMap安全吗，是怎么保证安全的？"></a>ConCurrentHashMap安全吗，是怎么保证安全的？</h3><blockquote><p>目前有如下一些方式可以获得线程安全的HashMap：</p><ul><li><em>Collections.synchronizedMap</em></li><li>HashTable</li><li>ConcurrentHashMap</li></ul><p>其中，前两种方式由于全局锁的问题，存在很严重的性能问题。所以，著名的并发编程大师Doug Lea在JDK1.5的java.util.concurrent包下面添加了一大堆并发工具。其中就包含ConcurrentHashMap这个线程安全的HashMap。</p><p>ConcurrentHashMap在JDK7和JDK8中的实现方式上有较大的不同。首先我们先来大概回顾一下ConcurrentHashMap在JDK7中的原理是怎样的。</p><h4 id="1-分段锁技术-JDK7"><a href="#1-分段锁技术-JDK7" class="headerlink" title="1.分段锁技术(JDK7)"></a>1.分段锁技术(JDK7)</h4><blockquote><p>针对HashTable会锁整个hash表的问题，ConcurrentHashMap提出了分段锁的解决方案。</p><p>分段锁的思想就是：<strong>锁的时候不锁整个hash表，而是只锁一部分</strong>。</p><p>如何实现呢？这就用到了ConcurrentHashMap中最关键的Segment。</p><p>ConcurrentHashMap中维护着一个Segment数组，每个Segment可以看做是一个HashMap。</p><p>而Segment本身继承了ReentrantLock，它本身就是一个锁。</p><p>在Segment中通过HashEntry数组来维护其内部的hash表。</p><p>每个HashEntry就代表了map中的一个K-V，用HashEntry可以组成一个链表结构，通过next字段引用到其下一个元素。</p><p>上述内容在源码中的表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Segment是ConcurrentHashMap的静态内部类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="comment">     * subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="comment">     * simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略 ...</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The per-segment table. Elements are accessed via</span></span><br><span class="line"><span class="comment">         * entryAt/setEntryAt providing volatile semantics.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">        <span class="comment">// ... 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ConcurrentHashMap list entry. Note that this is never exported</span></span><br><span class="line"><span class="comment">     * out as a user-visible Map.Entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// ... 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-f53c2717e40e288ba87738bc45822dd0_1440w.jpg" alt="img"></p><p>由上图可见，只要我们的hash值足够分散，那么每次put的时候就会put到不同的segment中去。 而segment自己本身就是一个锁，put的时候，当前segment会将自己锁住，此时其他线程无法操作这个segment， 但不会影响到其他segment的操作。这个就是锁分段带来的好处。</p></blockquote><h4 id="2-线程安全的put"><a href="#2-线程安全的put" class="headerlink" title="2.线程安全的put"></a>2.线程安全的put</h4><p>ConcurrentHashMap的put方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key的hash定位出一个segment，如果指定index的segment还没初始化，则调用ensureSegment方法初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 调用segment的put方法</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用segment的put方法，将元素put到HashEntry数组中，这里的注释中只给出锁相关的说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为segment本身就是一个锁</span></span><br><span class="line">    <span class="comment">// 这里调用tryLock尝试获取锁</span></span><br><span class="line">    <span class="comment">// 如果获取成功，那么其他线程都无法再修改这个segment</span></span><br><span class="line">    <span class="comment">// 如果获取失败，会调用scanAndLockForPut方法根据key和hash尝试找到这个node，如果不存在，则创建一个node并返回，如果存在则返回null</span></span><br><span class="line">    <span class="comment">// 查看scanAndLockForPut源码会发现他在查找的过程中会尝试获取锁，在多核CPU环境下，会尝试64次tryLock()，如果64次还没获取到，会直接调用lock()</span></span><br><span class="line">    <span class="comment">// 也就是说这一步一定会获取到锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-线程安全的扩容-Rehash"><a href="#3-线程安全的扩容-Rehash" class="headerlink" title="3.线程安全的扩容(Rehash)"></a>3.线程安全的扩容(Rehash)</h4><p>HashMap的线程安全问题大部分出在扩容(rehash)的过程中。</p><p>ConcurrentHashMap的扩容<strong>只针对每个segment</strong>中的HashEntry数组进行扩容。</p><p>由上述put的源码可知，ConcurrentHashMap在rehash的时候是有锁的，所以在rehash的过程中，其他线程无法对segment的hash表做操作，这就保证了线程安全。</p><h3 id="1-JDK8中ConcurrentHashMap的初始化"><a href="#1-JDK8中ConcurrentHashMap的初始化" class="headerlink" title="1.JDK8中ConcurrentHashMap的初始化"></a>1.JDK8中ConcurrentHashMap的初始化</h3><p>以无参数构造函数为例，来看一下ConcurrentHashMap类初始化的时候会做些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>首先会执行静态代码块和初始化类变量。 主要会初始化以下这些类变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">这里用到了Unsafe类，其中objectFieldOffset方法用于获取指定Field(例如sizeCtl)在内存中的偏移量。<span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SIZECTL;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> BASECOUNT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLSBUSY;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLVALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">        TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">        BASECOUNT = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">        CELLSBUSY = U.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">        Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">            (ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">        <span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> U.arrayIndexScale(ak);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;这里用到了Unsafe类，其中objectFieldOffset方法用于获取指定Field(例如sizeCtl)在内存中的偏移量。</span><br></pre></td></tr></table></figure><p>这里用到了Unsafe类，其中objectFieldOffset方法用于获取指定Field(例如sizeCtl)在内存中的偏移量。</p><h3 id="2-内部数据结构"><a href="#2-内部数据结构" class="headerlink" title="2.内部数据结构"></a>2.内部数据结构</h3><p>先来从源码角度看一下JDK8中是怎么定义的存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment"> * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * hash表，在第一次put数据的时候才初始化，他的大小总是2的倍数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来存储一个键值对</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Key-value entry.  This class is never exported out as a</span></span><br><span class="line"><span class="comment"> * user-mutable Map.Entry (i.e., one supporting setValue; see</span></span><br><span class="line"><span class="comment"> * MapEntry below), but can be used for read-only traversals used</span></span><br><span class="line"><span class="comment"> * in bulk tasks.  Subclasses of Node with a negative hash field</span></span><br><span class="line"><span class="comment"> * are special, and contain null keys and values (but are never</span></span><br><span class="line"><span class="comment"> * exported).  Otherwise, keys and vals are never null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，JDK8与JDK7的实现由较大的不同，JDK8中不在使用Segment的概念，他更像HashMap的实现方式。</p><p><img src="https://pic1.zhimg.com/80/v2-53355a611b890d50b91f857222ac3e7c_1440w.jpg" alt="img"></p><h3 id="3-线程安全的hash表初始化"><a href="#3-线程安全的hash表初始化" class="headerlink" title="3.线程安全的hash表初始化"></a>3.线程安全的hash表初始化</h3><p>由上文可知ConcurrentHashMap是用table这个成员变量来持有hash表的。</p><p>table的初始化采用了延迟初始化策略，他会在第一次执行put的时候初始化table。</p><p>put方法源码如下（省略了暂时不相关的代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The value can be retrieved by calling the &#123;<span class="doctag">@code</span> get&#125; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果table是空，初始化之</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initTable源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// sizeCtl的默认值是0，所以最先走到这的线程会进入到下面的else if判断中</span></span><br><span class="line">        <span class="comment">// #2</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 尝试原子性的将指定对象(this)的内存偏移量为SIZECTL的int变量值从sc更新为-1</span></span><br><span class="line">        <span class="comment">// 也就是将成员变量sizeCtl的值改为-1</span></span><br><span class="line">        <span class="comment">// #3</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双重检查，原因会在下文分析</span></span><br><span class="line">                <span class="comment">// #4</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY; <span class="comment">// 默认初始容量为16</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// #5</span></span><br><span class="line">                    table = tab = nt; <span class="comment">// 创建hash表，并赋值给成员变量table</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// #6</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量sizeCtl在ConcurrentHashMap中的其中一个作用相当于HashMap中的threshold，当hash表中元素个数超过sizeCtl时，触发扩容； 他的另一个作用类似于一个标识，例如，当他等于-1的时候，说明已经有某一线程在执行hash表的初始化了，一个小于-1的值表示某一线程正在对hash表执行resize。</p><p>这个方法首先判断sizeCtl是否小于0，如果小于0，直接将当前线程变为就绪状态的线程。</p><p>当sizeCtl大于等于0时，当前线程会尝试通过CAS的方式将sizeCtl的值修改为-1。修改失败的线程会进入下一轮循环，判断sizeCtl&lt;0了，被yield住；修改成功的线程会继续执行下面的初始化代码。</p><p>在new Node[]之前，要再检查一遍table是否为空，这里做双重检查的原因在于，如果另一个线程执行完#1代码后挂起，此时另一个初始化的线程执行完了#6的代码，此时sizeCtl是一个大于0的值，那么再切回这个线程执行的时候，是有可能重复初始化的。关于这个问题会在下图的并发场景中说明。</p><p>然后初始化hash表，并重新计算sizeCtl的值，最终返回初始化好的hash表。</p><h3 id="4-线程安全的put"><a href="#4-线程安全的put" class="headerlink" title="4 .线程安全的put"></a>4 .线程安全的put</h3><p>put操作可分为以下两类 <em>当前hash表对应当前key的index上没有元素时</em> 当前hash表对应当前key的index上已经存在元素时(hash碰撞)</p><h3 id="4-1-hash表上没有元素时"><a href="#4-1-hash表上没有元素时" class="headerlink" title="4.1 hash表上没有元素时"></a>4.1 hash表上没有元素时</h3><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                 <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tabAt方法通过Unsafe.getObjectVolatile()的方式获取数组对应index上的元素，getObjectVolatile作用于对应的内存偏移量上，是具备volatile内存语义的。</p><p>如果获取的是空，尝试用cas的方式在数组的指定index上创建一个新的Node。</p><h3 id="4-2-hash碰撞时"><a href="#4-2-hash碰撞时" class="headerlink" title="4.2 hash碰撞时"></a>4.2 hash碰撞时</h3><p>对应源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 锁f是在4.1中通过tabAt方法获取的</span></span><br><span class="line">    <span class="comment">// 也就是说，当发生hash碰撞时，会以链表的头结点作为锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="comment">// 这个检查的原因在于：</span></span><br><span class="line">        <span class="comment">// tab引用的是成员变量table，table在发生了rehash之后，原来index上的Node可能会变</span></span><br><span class="line">        <span class="comment">// 这里就是为了确保在put的过程中，没有收到rehash的影响，指定index上的Node仍然是f</span></span><br><span class="line">        <span class="comment">// 如果不是f，那这个锁就没有意义了</span></span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">            <span class="comment">// 确保put没有发生在扩容的过程中，fh=-1时表示正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                binCount = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                    K ek;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == key ||</span><br><span class="line">                         (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                        oldVal = e.val;</span><br><span class="line">                        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                            e.val = value;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Node&lt;K,V&gt; pred = e;</span><br><span class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 在链表后面追加元素</span></span><br><span class="line">                        pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                  value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p;</span><br><span class="line">                binCount = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                               value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldVal = p.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        p.val = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果链表长度超过8个，将链表转换为红黑树，与HashMap相同，相对于JDK7来说，优化了查找效率</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">            treeifyBin(tab, i);</span><br><span class="line">        <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> oldVal;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于JDK7中segment的概念，JDK8中直接用链表的头节点做为锁。 JDK7中，HashMap在多线程并发put的情况下可能会形成环形链表，ConcurrentHashMap通过这个锁的方式，使同一时间只有有一个线程对某一链表执行put，解决了并发问题。</p><h3 id="5-线程安全的扩容"><a href="#5-线程安全的扩容" class="headerlink" title="5 线程安全的扩容"></a>5 线程安全的扩容</h3><p>put方法的最后一步是统计hash表中元素的个数，如果超过sizeCtl的值，触发扩容。</p><p>扩容的代码略长，可大致看一下里面的中文注释，再参考下面的分析。 其实我们主要的目的是弄明白ConcurrentHashMap是如何解决HashMap的并发问题的。 带着这个问题来看源码就好。关于HashMap存在的问题，参考本文一开始说的笔者的另一篇文章即可。</p><p>其实HashMap的并发问题多半是由于put和扩容并发导致的。</p><p>这里我们就来看一下ConcurrentHashMap是如何解决的。</p><p>扩容涉及的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment"> * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment"> * 业务中使用的hash表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment"> * 扩容时才使用的hash表，扩容完成后赋值给table，并将nextTable重置为null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds to count, and if table is too small and not already</span></span><br><span class="line"><span class="comment"> * resizing, initiates transfer. If already resizing, helps</span></span><br><span class="line"><span class="comment"> * perform transfer if work is available.  Rechecks occupancy</span></span><br><span class="line"><span class="comment"> * after a transfer to see if another resize is already needed</span></span><br><span class="line"><span class="comment"> * because resizings are lagging additions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the count to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> check if &lt;0, don&#x27;t check resize, if &lt;= 1 only check if uncontended</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    <span class="comment">// ----- 计算键值对的个数 start -----</span></span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----- 计算键值对的个数 end -----</span></span><br><span class="line">    <span class="comment">// ----- 判断是否需要扩容 start -----</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 当上面计算出来的键值对个数超出sizeCtl时，触发扩容，调用核心方法transfer</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果有已经在执行的扩容操作，nextTable是正在扩容中的新的hash表</span></span><br><span class="line">                <span class="comment">// 如果并发扩容，transfer直接使用正在扩容的新hash表，保证了不会出现hash表覆盖的情况</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新sizeCtl的值，更新成功后为负数，扩容开始</span></span><br><span class="line">            <span class="comment">// 此时没有并发扩容的情况，transfer中会new一个新的hash表来扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----- 判断是否需要扩容 end -----</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment"> * above for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 初始化新的hash表，大小为之前的2倍，并赋值给成员变量nextTable</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">// 扩容完成时，将成员变量nextTable置为null，并将table替换为rehash后的nextTable</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 接下来是遍历每个链表，对每个链表的元素进行rehash</span></span><br><span class="line">            <span class="comment">// 仍然用头结点作为锁，所以在扩容的时候，无法对这个链表执行put操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// setTabAt方法调用了Unsafe.putObjectVolatile来完成hash表元素的替换，具备volatile内存语义</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述代码，对ConcurrentHashMap是如何解决HashMap并发问题这一疑问进行简要说明。</p><ul><li>首先new一个新的hash表(nextTable)出来，大小是原来的2倍。后面的rehash都是针对这个新的hash表操作，不涉及原hash表(table)。</li><li>然后会对原hash表(table)中的每个链表进行rehash，此时会尝试获取头节点的锁。这一步就保证了在rehash的过程中不能对这个链表执行put操作。</li><li>通过sizeCtl控制，使扩容过程中不会new出多个新hash表来。</li><li>最后，将所有键值对重新rehash到新表(nextTable)中后，用nextTable将table替换。这就避免了HashMap中get和扩容并发时，可能get到null的问题。</li><li>在整个过程中，共享变量的存储和读取全部通过volatile或CAS的方式，保证了线程安全。</li></ul></blockquote><p>[ ]转载:<a href="https://my.oschina.net/muziH/blog/1596801">HashMap原理及线程不安全详解 - 木子H的个人空间 - OSCHINA - 中文开源技术交流社区</a></p><p>[]参考:<a href="https://zhuanlan.zhihu.com/p/84390205">Java8中ConcurrentHashMap是如何保证线程安全的 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;HashMap原理&quot;&gt;&lt;a href=&quot;#HashMap原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap原理&quot;&gt;&lt;/a&gt;HashMap原理&lt;/h4&gt;&lt;p&gt;数据结构上：数组+(链表和红黑树)&lt;/p&gt;
&lt;h4 id=&quot;HashMap线程不安全</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>自动拆箱和装箱原理</title>
    <link href="https://gwtt.github.io/2022/08/08/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%E5%8E%9F%E7%90%86/"/>
    <id>https://gwtt.github.io/2022/08/08/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%E5%8E%9F%E7%90%86/</id>
    <published>2022-08-08T11:22:37.000Z</published>
    <updated>2022-08-08T11:49:38.353Z</updated>
    
    <content type="html"><![CDATA[<p>自动装箱和自动拆箱是两个相反的过程，自动装箱即将基本数据类型转换为对应的封装类，自动拆箱即将封装类转换为对应的基本数据类型。此外，<strong>装箱的过程会增加内存的消耗，影响性能，因为这个过程会创建对应的对象。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210112100512319.png?x-oss-process=image#pic_center/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQyNzEyOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integerNum</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 进行自动装箱，得到的是封装类</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">intNum</span> <span class="operator">=</span> integerNum; <span class="comment">// 进行自动拆箱，得到基本数据类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code>javap -c Main.class</code> 查看生成的字节码文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Main.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">club</span>.wadreamer.test.Main &#123;</span><br><span class="line">  <span class="keyword">public</span> club.wadreamer.test.Main();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: aload_1</span><br><span class="line">       <span class="number">7</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/lang/Integer.intValue:()I</span></span><br><span class="line">      <span class="number">10</span>: istore_2</span><br><span class="line">      <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Integer#valueOf()</code> 和 <code>Integer#intValue()</code> 的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"><span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上述字节码可以得出如下结论：</p><ul><li>在进行自动装箱时，Java 虚拟机会自动调用 Integer#valueOf()。</li><li>在进行自动拆箱时，Java 虚拟机会自动调用 Integer#intValue()。</li><li>其他数据类型的自动装箱和自动拆箱的过程和 Integer 类似，都是调用类似 xxxValue()、valueOf() 等方法。</li></ul><h4 id="其他案例分析"><a href="#其他案例分析" class="headerlink" title="其他案例分析"></a>其他案例分析</h4><h5 id="1-空指针异常"><a href="#1-空指针异常" class="headerlink" title="1.空指针异常"></a>1.空指针异常</h5><blockquote><p>包装类为空，拆箱时异常</p></blockquote><h5 id="2-equals和-问题"><a href="#2-equals和-问题" class="headerlink" title="2.equals和==问题"></a>2.equals和==问题</h5><blockquote><p>两个包装类用==，比较的是地址</p><p>两个包装类用equals，比较的是值</p><p>一个包装类和一个基本数据类型用equals，比较的是值</p><p>一个包装类和一个基本数据类型用==，比较的是值（会自动拆包）</p><p>两个基本数据类型用==比较的是值</p></blockquote><h5 id="3-拆箱的缓存机制"><a href="#3-拆箱的缓存机制" class="headerlink" title="3.拆箱的缓存机制"></a>3.拆箱的缓存机制</h5><blockquote><p><strong>对于 Integer</strong>，在 [-128, 127] 之间只有固定的 256 个值，所以为了避免多次创建对象，事先创建好一个大小为 256 的 Integer 数组 cache，所以如果值在这个范围内，就可以直接返回我们事先创建好的对象即可。</p><p><strong>对于 Double 类型来说</strong>，我们就不能这样做，因为它在这个范围内个数是无限的。 总结一句就是：在某个范围内的整型数值的个数是有限的，而浮点数却不是。所以在 Double 里面的做法很直接，就是直接创建一个对象，所以每次创建的对象都不一样。</p><p>对于 Boolean 类型来说，在内部已经提前创建好两个对象，因为它只有两种情况，这样也是为了避免重复创建太多的对象。因此，每次执行 Boolean#valueOf() 返回的都是相同的对象。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><ul><li>存在拆箱操作时一定要特别注意封装类对象是否为 null。</li><li>包装类和基本数据类型在进行== 运算和算数运算时，会进行自动拆箱。</li><li>equals() 会进行<strong>自动装箱操作</strong>，且需要先判断封装类的类型是否相同，再进一步判断内容是否相同。（==是优先比较基本数据类型，是<strong>拆箱操作</strong>）</li><li>Integer、Short、Byte、Character、Long 这几个类的 valueOf() 的实现是类似的，均在存在 [-128, 127] 的缓存。</li><li>Double、Float 的 valueOf() 的实现是类似的，每次都返回不同的对象。</li><li>Boolean 预先创建了两个对象，Boolean#valueOf() 每次返回的都是相同的对象。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自动装箱和自动拆箱是两个相反的过程，自动装箱即将基本数据类型转换为对应的封装类，自动拆箱即将封装类转换为对应的基本数据类型。此外，&lt;strong&gt;装箱的过程会增加内存的消耗，影响性能，因为这个过程会创建对应的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>八锁问题</title>
    <link href="https://gwtt.github.io/2022/07/10/%E5%85%AB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>https://gwtt.github.io/2022/07/10/%E5%85%AB%E9%94%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-10T12:28:04.572Z</published>
    <updated>2022-07-10T12:31:59.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八锁问题"><a href="#八锁问题" class="headerlink" title="八锁问题"></a>八锁问题</h1><ol><li>new发短信后 睡眠100毫秒，发短信、发邮件的打印顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0101</span> <span class="variable">test0101</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0101</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0101.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0101.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0101</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendMessage</span><br><span class="line">sendEmail</span><br><span class="line">因为<span class="keyword">synchronized</span>关键字 是对该资源类的对象上锁，因此哪个线程先拿到对象锁，就先执行</span><br></pre></td></tr></table></figure><p> 2.发短信线程中执行时睡眠4秒，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0201</span> <span class="variable">test0201</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0201</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0201.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0201.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0201</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendMessage</span><br><span class="line">sendEmail</span><br><span class="line">原理同上。还是上面的线程先拿到 资源类 锁对象</span><br></pre></td></tr></table></figure><p>3.打电话线程，发短信、打电话的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0301</span> <span class="variable">test0301</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0301</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0301.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0301.call();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0301</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">call</span><br><span class="line">sendMessage</span><br><span class="line"><span class="title function_">call</span><span class="params">()</span>为普通方法,不受同步方法的影响,不受锁的影响</span><br></pre></td></tr></table></figure><p>4.两个资源，发短信、发邮件的打印顺序(先邮件后短信)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0401</span> <span class="variable">test0401</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0401</span>();</span><br><span class="line">        <span class="type">Test0401</span> <span class="variable">test0402</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0401</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0401.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0402.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0401</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendEmail</span><br><span class="line">sendMessage</span><br><span class="line">区别于问题<span class="number">1</span>，该情况是 两个资源类对象分别开启两个线程，因此锁对象 并无互相干扰，因为线程延时的原因，打电话 先输出</span><br></pre></td></tr></table></figure><p>5.两个同步方法变静态、一个资源，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0501</span> <span class="variable">test0401</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0501</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0401.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0401.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0501</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendMessage</span><br><span class="line">sendEmail</span><br><span class="line">加上<span class="keyword">static</span>关键字之后，两个方法都变为静态方法。</span><br></pre></td></tr></table></figure><p>6.两个静态同步方法、两个资源，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0601</span> <span class="variable">test0601</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0601</span>();</span><br><span class="line">        <span class="type">Test0601</span> <span class="variable">test0602</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0601</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0601.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0602.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0601</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendMessage</span><br><span class="line">sendEmail</span><br><span class="line">原理同<span class="number">5</span>，<span class="keyword">synchronized</span> 加 静态方法 锁的是 Class</span><br></pre></td></tr></table></figure><p>7.一个静态同步方法、一个普通同步方法、一个资源，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0701</span> <span class="variable">test0701</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0701</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0701.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0701.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0701</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendEmail</span><br><span class="line">sendMessage</span><br><span class="line"><span class="keyword">synchronized</span> 锁的是 类实例即对象 、<span class="keyword">synchronized</span> 加 静态方法 锁的是 Class</span><br></pre></td></tr></table></figure><p>8.一个静态同步方法、一个普通同步方法、两个资源，发短信、发邮件的打印顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Test0801</span> <span class="variable">test0801</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0801</span>();</span><br><span class="line">        <span class="type">Test0801</span> <span class="variable">test0802</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test0801</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0801.sendMessage();</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test0802.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test0801</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">sendEmail</span><br><span class="line">sendMessage</span><br><span class="line">原理同<span class="number">7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;八锁问题&quot;&gt;&lt;a href=&quot;#八锁问题&quot; class=&quot;headerlink&quot; title=&quot;八锁问题&quot;&gt;&lt;/a&gt;八锁问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;new发短信后 睡眠100毫秒，发短信、发邮件的打印顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="java基础" scheme="https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Juc" scheme="https://gwtt.github.io/tags/Juc/"/>
    
  </entry>
  
  <entry>
    <title>lock锁和Synchronized锁</title>
    <link href="https://gwtt.github.io/2022/07/10/lock%E9%94%81%E5%92%8CSynchronized%E9%94%81/"/>
    <id>https://gwtt.github.io/2022/07/10/lock%E9%94%81%E5%92%8CSynchronized%E9%94%81/</id>
    <published>2022-07-10T08:30:15.327Z</published>
    <updated>2022-07-10T08:57:27.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lock锁和Synchronized锁"><a href="#lock锁和Synchronized锁" class="headerlink" title="lock锁和Synchronized锁"></a>lock锁和Synchronized锁</h1><blockquote><h3 id="synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种"><a href="#synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种" class="headerlink" title="synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种"></a>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种</h3><h3 id="一个线程访问一个对象中的synchronized-this-同步代码块时，其他试图访问该对象的线程将被阻塞-："><a href="#一个线程访问一个对象中的synchronized-this-同步代码块时，其他试图访问该对象的线程将被阻塞-：" class="headerlink" title="(一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞)："></a>(一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞)：</h3><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 　</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li><li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+(number++));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">结果:</span><br><span class="line">aa:<span class="number">0</span></span><br><span class="line">aa:<span class="number">1</span></span><br><span class="line">aa:<span class="number">2</span></span><br><span class="line">aa:<span class="number">3</span></span><br><span class="line">aa:<span class="number">4</span></span><br><span class="line">bb:<span class="number">5</span></span><br><span class="line">bb:<span class="number">6</span></span><br><span class="line">bb:<span class="number">7</span></span><br><span class="line">bb:<span class="number">8</span></span><br><span class="line">bb:<span class="number">9</span></span><br><span class="line">cc:<span class="number">10</span></span><br><span class="line">cc:<span class="number">11</span></span><br><span class="line">cc:<span class="number">12</span></span><br><span class="line">cc:<span class="number">13</span></span><br><span class="line">cc:<span class="number">14</span></span><br></pre></td></tr></table></figure><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><blockquote><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p>　　1）Lock不是Java语言内置的，synchronized是Java语言的<strong>关键字</strong>，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p><p>　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p><p><strong>synchronized 的局限性 与 Lock 的优点</strong>　</p><p>　　如果一个代码块被synchronized关键字修饰，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待直至占有锁的线程释放锁。事实上，占有锁的线程释放锁一般会是以下三种情况之一：</p><p>　　1：占有锁的线程执行完了该代码块，然后释放对锁的占有；</p><p>　　2：占有锁线程执行发生异常，此时JVM会让线程自动释放锁；</p><p>　　3：占有锁线程进入 WAITING 状态从而释放锁，例如在该线程中调用wait()方法等。</p><p>　　试考虑以下三种情况：　</p><p>Case 1 ：</p><p>　　<strong>在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间 (解决方案：tryLock(long time, TimeUnit unit)) 或者 能够响应中断 (解决方案：lockInterruptibly())），这种情况可以通过 Lock 解决。</strong></p><p>Case 2 ：</p><p>　　<strong>我们知道，当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程都只是进行读操作时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。同样地，Lock也可以解决这种情况 (解决方案：ReentrantReadWriteLock) 。</strong></p><p>Case 3 ：</p><p>　　<strong>我们可以通过Lock得知线程有没有成功获取到锁 (解决方案：ReentrantLock) ，但这个是synchronized无法办到的。</strong></p><p><strong>上面提到的三种情形，我们都可以通过Lock来解决，但 synchronized 关键字却无能为力。事实上，Lock 是 java.util.concurrent.locks包 下的接口，Lock 实现提供了比 synchronized 关键字 更广泛的锁操作，它能以更优雅的方式处理线程同步问题。也就是说，Lock提供了比synchronized更多的功能。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+(number++));</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;,<span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">结果:</span><br><span class="line">aa:<span class="number">0</span></span><br><span class="line">aa:<span class="number">1</span></span><br><span class="line">aa:<span class="number">2</span></span><br><span class="line">aa:<span class="number">3</span></span><br><span class="line">aa:<span class="number">4</span></span><br><span class="line">cc:<span class="number">5</span></span><br><span class="line">cc:<span class="number">6</span></span><br><span class="line">cc:<span class="number">7</span></span><br><span class="line">cc:<span class="number">8</span></span><br><span class="line">cc:<span class="number">9</span></span><br><span class="line">bb:<span class="number">10</span></span><br><span class="line">bb:<span class="number">11</span></span><br><span class="line">bb:<span class="number">12</span></span><br><span class="line">bb:<span class="number">13</span></span><br><span class="line">bb:<span class="number">14</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>lock没有主动用unlock()去释放锁,会造成死锁现象,因此用lock需要在finally块中释放锁.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前线程未被中断，则获取锁，可以响应中断  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回绑定到此 Lock 实例的新 Condition 实例  </span></span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在调用时锁为空闲状态才获取该锁，可以响应中断  </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁  </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lock锁和Synchronized锁&quot;&gt;&lt;a href=&quot;#lock锁和Synchronized锁&quot; class=&quot;headerlink&quot; title=&quot;lock锁和Synchronized锁&quot;&gt;&lt;/a&gt;lock锁和Synchronized锁&lt;/h1&gt;&lt;bloc</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="java基础" scheme="https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="方法句柄， JVM" scheme="https://gwtt.github.io/tags/%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84%EF%BC%8C-JVM/"/>
    
  </entry>
  
  <entry>
    <title>java7新特性之方法句柄</title>
    <link href="https://gwtt.github.io/2022/07/10/%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84/"/>
    <id>https://gwtt.github.io/2022/07/10/%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84/</id>
    <published>2022-07-10T06:02:29.913Z</published>
    <updated>2022-07-10T08:30:08.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法句柄"><a href="#方法句柄" class="headerlink" title="方法句柄"></a>方法句柄</h1><p>JDK6之前我们会使用java反射来实现动态方法调用，多数框架用反射的比较多，例如mybatis、spring等。在JDK7中，新增了java.lang.invoke.MethodHandle（方法句柄），称之为“现代化反射”。其实反射和java.lang.invoke.MethodHandle都是间接调用方法的途径，但java.lang.invoke.MethodHandle比反射更简洁，用反射功能会写一大堆冗余代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">race</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">race</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Horse.race()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"><span class="comment">// 利用接口抽象方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Horse</span>();</span><br><span class="line">    animal.race();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Horse</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Horse</span>();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> object.getClass().getMethod(<span class="string">&quot;race&quot;</span>);</span><br><span class="line">    method.invoke(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MethodType用来描述方法的返回值类型以及入参类型。<br>MehodHandle包含一个指向Method对象（方法在jvm内部的对等体）的指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,&quot;</span> + s + <span class="string">&quot;MethodHandle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> getToStringMH();</span><br><span class="line">        System.out.println((String) mh.invokeExact(main, <span class="string">&quot;ss&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodHandle <span class="title function_">getToStringMH</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">mt</span> <span class="operator">=</span> MethodType.methodType(String.class, String.class);  <span class="comment">//获取方法类型 参数为:1.返回值类型,2方法中参数类型</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mh = MethodHandles.lookup().findVirtual(Main.class, <span class="string">&quot;toString&quot;</span>, mt);  <span class="comment">//查找方法句柄</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法句柄是一个强类型的，能够被直接执行的引用。该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上等价于目标字段的 getter 或者 setter 方法。</p><p>方法句柄的类型（MethodType）是由所指向方法的参数类型以及返回类型组成的。它是用来确认方法句柄是否适配的唯一关键。当使用方法句柄时，我们其实并不关心方法句柄所指向方法的类名或者方法名。</p><p><strong>MethodHandle 的创建方式：</strong></p><p>方式一、通过反射创建 MethodHandle（不符合初衷）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">race</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodHandles.Lookup <span class="title function_">lookup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Main.class.getDeclaredMethod(<span class="string">&quot;race&quot;</span>);</span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> Main.lookup().unreflect(method);</span><br><span class="line">        methodHandle.invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出: hello</span><br></pre></td></tr></table></figure><p>方式二、根据 MethodType 创建 MethodHandle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">race</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;race&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodHandles.Lookup <span class="title function_">lookup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> Main.lookup();</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> lookup.findStatic(Main.class, <span class="string">&quot;race&quot;</span>, methodType);</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">methodHandle2</span> <span class="operator">=</span> lookup.findVirtual(Main.class, <span class="string">&quot;say&quot;</span>, methodType);</span><br><span class="line">        methodHandle.invoke();</span><br><span class="line">        methodHandle2.invoke(<span class="keyword">new</span> <span class="title class_">Main</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出:</span><br><span class="line">race</span><br><span class="line">say</span><br></pre></td></tr></table></figure><p>小结一下：</p><p>1、<strong>方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于 Lookup 对象的创建位置。</strong></p><p>2、如果 JDK 版本大于8，那么可以在其他类中，也能够通过该 Lookup 对象对类私有属性进行赋值、取值操作。</p><h4 id="外类中操控私有字段"><a href="#外类中操控私有字段" class="headerlink" title="外类中操控私有字段"></a>外类中操控私有字段</h4><p>因为权限问题，外类中创建的 Lookup 对象无法操控私有字段，那么有什么替代方案呢？</p><ul><li>通过操控get和set方法</li><li>反射</li></ul><p>关于invoke和invokeExtract方法的区别：</p><blockquote><p>invokeExtract要求更加精确，<br>如下 methodHandle2.invokeExact(test1,5.1,new Integer(1));可以执行，<br>methodHandle2.invokeExact(test1,5.1,1);会报错，因为要将1转换为integer，所以不合要求。这个方法要求不能有任何类型转换，也就是参数严格一致。<br>invoke相对要轻松很多。</p></blockquote><p>关键概念</p><blockquote><p>Lookup<br>MethodHandle 的创建工厂，通过它可以创建MethodHandle，值得注意的是检查工作是在创建时处理的，而不是在调用时处理。</p><p>MethodType<br>顾名思义，就是代表方法的签名。一个方法的返回值类型是什么，有几个参数，每个参数的类型什么？</p><p>MethodHandle<br>方法句柄，通过它我们就可以动态访问类型信息了。</p></blockquote><p>如何使用</p><blockquote><p>当理解了上面几个关键概念后使用起来就比较简单了，总的来说只需要4步：</p><p>创建Lookup<br>创建MethodType<br>基于Lookup与MethodType获得MethodHandle<br>调用MethodHandle</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方法句柄&quot;&gt;&lt;a href=&quot;#方法句柄&quot; class=&quot;headerlink&quot; title=&quot;方法句柄&quot;&gt;&lt;/a&gt;方法句柄&lt;/h1&gt;&lt;p&gt;JDK6之前我们会使用java反射来实现动态方法调用，多数框架用反射的比较多，例如mybatis、spring等。在JDK7</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="java基础" scheme="https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="方法句柄， JVM" scheme="https://gwtt.github.io/tags/%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84%EF%BC%8C-JVM/"/>
    
  </entry>
  
  <entry>
    <title>Git面试</title>
    <link href="https://gwtt.github.io/2022/07/02/Git%E9%9D%A2%E8%AF%95/"/>
    <id>https://gwtt.github.io/2022/07/02/Git%E9%9D%A2%E8%AF%95/</id>
    <published>2022-07-02T09:55:45.230Z</published>
    <updated>2022-08-16T13:37:10.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="1-什么是git"><a href="#1-什么是git" class="headerlink" title="1.什么是git?"></a>1.什么是git?</h3><blockquote><p>git是一个常用的分布式版本管理工具。</p></blockquote><h3 id="2-git常用的命令"><a href="#2-git常用的命令" class="headerlink" title="2.git常用的命令"></a>2.git常用的命令</h3><blockquote><ul><li>git add 添加文件到暂存区</li><li>git commit 提交文件到本地仓库</li><li>git pull 从远程仓库拉取项目到本地</li><li>git push 将本地仓库的新的改变推送到远程仓库</li><li>git clone 将远程仓库复制到本地</li><li>git fetch 抓取</li><li>git merge 合并</li></ul></blockquote><h3 id="3-git-pull、git-merge、git-fetch三个命令的区别？"><a href="#3-git-pull、git-merge、git-fetch三个命令的区别？" class="headerlink" title="3.git pull、git merge、git fetch三个命令的区别？"></a>3.<code>git pull</code>、<code>git merge</code>、<code>git fetch</code>三个命令的区别？</h3><blockquote><p>git clone：是在本地没有版本库的情况下，从远程仓库克隆一份到本地，是一个本地版本库从无到有的过程</p><p>git pull：是在本地仓库已经存在的情况下，将远程最新的commits抓取并合并到本地版本库的过程</p><p>git fetch： 从远程版本库抓取最新的commits，不会进行合并</p><p>git merge：合并</p><p>所以git pull = git fetch + git merge</p></blockquote><h3 id="4-push之前一定要进行哪个操作？"><a href="#4-push之前一定要进行哪个操作？" class="headerlink" title="4.push之前一定要进行哪个操作？"></a>4.push之前一定要进行哪个操作？</h3><blockquote><p>push之前一定要进行本地更新操作。使用<code>git pull</code>命令或者使用<code>git fetch</code>和<code>git merge</code>的命令组合。这时候，可能会出现版本冲突，如果出现的话，需要解决完冲突再进行代码push。</p></blockquote><h3 id="5-如何解决版本冲突"><a href="#5-如何解决版本冲突" class="headerlink" title="5.如何解决版本冲突"></a>5.如何解决版本冲突</h3><blockquote><p>版本冲突多出现在合并操作(合并远程仓库代码或者合并分支代码)中。如果出现版本冲突，需要具体分析出现冲突的代码区，手动进行代码合并，然后再进行提交。</p></blockquote><h3 id="6-别人在远程推送的新分支怎么合并在自己上面"><a href="#6-别人在远程推送的新分支怎么合并在自己上面" class="headerlink" title="6.别人在远程推送的新分支怎么合并在自己上面"></a>6.别人在远程推送的新分支怎么合并在自己上面</h3><blockquote><p>假设别人分支是A，我是B</p><p>git checkout B;//到自己分区</p><p>git merge A;//合并分支</p><p>git push;//提交</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h2&gt;&lt;h3 id=&quot;1-什么是git&quot;&gt;&lt;a href=&quot;#1-什么是git&quot; class=&quot;headerlink&quot; title=&quot;1.什么是</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Git" scheme="https://gwtt.github.io/tags/Git/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Springboot面试(2)</title>
    <link href="https://gwtt.github.io/2022/07/02/Springboot%E9%9D%A2%E8%AF%95(2)/"/>
    <id>https://gwtt.github.io/2022/07/02/Springboot%E9%9D%A2%E8%AF%95(2)/</id>
    <published>2022-07-02T09:31:37.501Z</published>
    <updated>2022-07-02T10:22:35.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="springboot-2"><a href="#springboot-2" class="headerlink" title="springboot(2)"></a>springboot(2)</h2><h3 id="1-Spring-boot的核心配置文件是什么"><a href="#1-Spring-boot的核心配置文件是什么" class="headerlink" title="1.Spring boot的核心配置文件是什么"></a>1.Spring boot的核心配置文件是什么</h3><blockquote><p>Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。</p><p>bootstrap 配置文件是系统级别的，用来加载外部配置，如配置中心的配置信息，也可以用来定义系统不会变化的属性.bootstatp 文件的加载先于application文件<br>application 配置文件是应用级别的，是当前应用的配置文件</p></blockquote><h3 id="2-如何使用jwt进行登录校验"><a href="#2-如何使用jwt进行登录校验" class="headerlink" title="2.如何使用jwt进行登录校验"></a>2.如何使用jwt进行登录校验</h3><blockquote><p>（1）<strong>客户端登录成功后（必须是在登陆成功才行，与session一样的前提条件）</strong>，服务器会根据用户名和签名以及其他信息加密生成唯一的token串，用来区分他们，不需要存入服务端的缓存中，但会把这个token返回给相应的主机，</p><p>（2）主机收到token后会存入cookie或者localStorage中，以后主机的每一次发送其他类型的请求的操作都会携带这个token，</p><p>（3）服务器会将客户端发来的这个token和服务端从数据库查询出来的并且重新计算得到的用户信息进行对比，如果匹配，则<strong>认证成功</strong>，如果用户请求的资源需要相应的权限，则校验token中的payload中存储的权限等相关信息，如果有权限则返回给对应主机所需要的资源（<strong>即做到了权限鉴权</strong>），否则拒绝</p><p><code>用的依赖是java-jwt，用的包是auth0.jwt</code></p></blockquote><h3 id="3-生成的token在服务端有哪些存储方案"><a href="#3-生成的token在服务端有哪些存储方案" class="headerlink" title="3.生成的token在服务端有哪些存储方案"></a>3.生成的token在服务端有哪些存储方案</h3><blockquote><p>（1）保存在redis，最常用，也是分布式下的验证token的解决方案，</p><p>（2）数据库存储，性能比redis稍差，速度稍慢</p><p>（3）不做保存，下次验证的时候直接用jwt.decode验证(服务端为express)，存储的压力给到了客户端，但是每次从客户端传到服务器端的数据量会稍微大一些</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;springboot-2&quot;&gt;&lt;a href=&quot;#springboot-2&quot; class=&quot;headerlink&quot; title=&quot;springboot(2)&quot;&gt;&lt;/a&gt;springboot(2)&lt;/h2&gt;&lt;h3 id=&quot;1-Spring-boot的核心配置文件是什么</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Springboot" scheme="https://gwtt.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Juc面试(2)</title>
    <link href="https://gwtt.github.io/2022/07/02/Juc%E9%9D%A2%E8%AF%95(2)/"/>
    <id>https://gwtt.github.io/2022/07/02/Juc%E9%9D%A2%E8%AF%95(2)/</id>
    <published>2022-07-02T07:35:00.409Z</published>
    <updated>2022-08-01T05:28:43.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="juc-2"><a href="#juc-2" class="headerlink" title="juc(2)"></a>juc(2)</h2><h3 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1.线程的生命周期"></a>1.线程的生命周期</h3><blockquote><p>线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。</p><ul><li>新建：就是刚使用new方法，new出来的线程；</li><li>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li><li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</li><li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li><li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;</li></ul><p><img src="/2022/07/02/Juc%E9%9D%A2%E8%AF%95(2)/1223046-20190722214114154-276488899.png" alt="img"></p><hr><p>那么处于Running状态的线程能发生哪些状态转变？</p><ul><li><p>被转换成Terminated状态，比如调用 stop() 方法;</p></li><li><p>被转换成Blocked状态，比如调用了sleep, wait 方法被加入 waitSet 中；</p></li><li><p>被转换成Blocked状态，如进行 IO 阻塞操作，如查询数据库进入阻塞状态；</p></li><li><p>被转换成Blocked状态，比如获取某个锁的释放，而被加入该锁的阻塞队列中；</p></li><li><p>该线程的时间片用完，CPU 再次调度，进入Runnable状态；</p></li><li><p>线程主动调用 yield 方法，让出 CPU 资源，进入Runnable状态</p></li></ul><p>Blocked状态的线程能够发生哪些状态改变？</p><ul><li><p>被转换成Terminated状态，比如调用 stop() 方法，或者是 JVM 意外 Crash;</p></li><li><p>被转换成Runnable状态，阻塞时间结束，比如读取到了数据库的数据后；</p></li><li><p>完成了指定时间的休眠，进入到Runnable状态；</p></li><li><p>正在wait中的线程，被其他线程调用notify/notifyAll方法唤醒，进入到Runnable状态；</p></li><li><p>线程获取到了想要的锁资源，进入Runnable状态；</p></li><li><p>线程在阻塞状态下被打断，如其他线程调用了interrupt方法，进入到Runnable状态；</p></li></ul><p>哪些情况进入终止状态</p><ul><li><p>线程正常运行结束，生命周期结束；</p></li><li><p>线程运行过程中出现意外错误；</p></li><li><p>JVM 异常结束，所有的线程生命周期均被结束。</p></li></ul></blockquote><h3 id="2-死锁问题"><a href="#2-死锁问题" class="headerlink" title="2.死锁问题"></a>2.死锁问题</h3><blockquote><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>死锁就是有两个或者多个进程由于竞争资源而造成阻塞的现象，如果无外力作用，这种局面就会一直持续下去</p><h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><p>死锁产生必须满足四个必要条件：</p><p>1、互斥条件：指在一段时间内某资源只能由一个进程占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只有一副钥匙</span><br></pre></td></tr></table></figure><p>2、请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，且对自己已获得的其它资源保持不放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拿着红钥匙的人在没有归还红钥匙的情况下，又索要蓝钥匙</span><br></pre></td></tr></table></figure><p>3、不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要人不主动归还钥匙，就可以一直占着钥匙</span><br></pre></td></tr></table></figure><p>4、环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链。即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拿着红钥匙的人在等待蓝钥匙，而拿着蓝钥匙的人又在等待红钥匙</span><br></pre></td></tr></table></figure><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><ul><li><strong>资源一次性分配</strong>：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li><li>每个进程提出申请资源前必须释放已占有的一切资源（破坏保持条件）</li><li><strong>可剥夺资源</strong>：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li><strong>资源有序分配法</strong>：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><p><strong>编程中的最佳实践：</strong></p><ul><li>使用 Lock 的 tryLock(long timeout, TimeUnit unit)的方法，设置超时时间，超时可以退出防止死锁</li><li>尽量使用并发工具类代替加锁</li><li>尽量降低锁的使用粒度</li><li>尽量减少同步的代码块</li></ul><h4 id="死锁检测工具（了解）"><a href="#死锁检测工具（了解）" class="headerlink" title="死锁检测工具（了解）"></a>死锁检测工具（了解）</h4><p>1、<strong>Jstack命令</strong></p><p>jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。</p><p>2、<strong>JConsole工具</strong></p><p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。</p></blockquote><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><blockquote><h4 id="单例模式含义"><a href="#单例模式含义" class="headerlink" title="单例模式含义"></a>单例模式含义</h4><p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p><p>单例模式主要解决的问题是一个全局使用的类，不会被频繁的创建和销毁，从而提升代码的整体性能。</p><h4 id="如何创建单例模式"><a href="#如何创建单例模式" class="headerlink" title="如何创建单例模式"></a>如何创建单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">饿汉式</span><br><span class="line">优点：简单，线程安全</span><br><span class="line">缺点：不管有没有使用都会占据空间</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例模式有一个特点，不允许外部直接创建对象，私有构造不让外部实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">懒汉式</span><br><span class="line">优点: 简单</span><br><span class="line">缺点: 线程不安全，要加锁才能解决</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>()</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">加锁后的</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>()</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">枚举（推荐）</span><br><span class="line">优点：线程安全，防止反射和反序列化</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的"><a href="#在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的" class="headerlink" title="在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的"></a>在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的</h4><p>结论:有写操作的话都是线程不安全的</p><p><strong>静态变量即类变量</strong>，只初始化一次，位于方法区，为所有对象共享，共享一份内存，一旦静态变量被修改，其他对象均对修改可见，故线程非安全。</p><p><strong>全局变量即实例成员变量</strong>。如果线程只是读取变量的值，而不会改变变量的值，则无论是单例还是非单例都是线程安全的；如果有修改变量值的操作，则单例模式因为只有一个对象实例singleton存在，多线程同时操作时是不安全的，而非单例模式下多线程操作是安全的。</p></blockquote><h3 id="4-怎么解决高并发问题"><a href="#4-怎么解决高并发问题" class="headerlink" title="4.怎么解决高并发问题"></a>4.怎么解决高并发问题</h3><blockquote><p>1.优化代码</p><p>2.设置单独的图片服务器，减少访问请求服务器压力</p><p>3.使用缓存</p><p>4.使用数据库集群</p><p>5.DB优化（索引优化，字段类型恰当）</p><p>6.实现负载均衡</p><p>7.限流</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;juc-2&quot;&gt;&lt;a href=&quot;#juc-2&quot; class=&quot;headerlink&quot; title=&quot;juc(2)&quot;&gt;&lt;/a&gt;juc(2)&lt;/h2&gt;&lt;h3 id=&quot;1-线程的生命周期&quot;&gt;&lt;a href=&quot;#1-线程的生命周期&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="juc" scheme="https://gwtt.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>Java面试基础（2）</title>
    <link href="https://gwtt.github.io/2022/07/02/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(2)/"/>
    <id>https://gwtt.github.io/2022/07/02/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(2)/</id>
    <published>2022-07-02T06:37:00.000Z</published>
    <updated>2022-07-09T14:38:29.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java基础-2"><a href="#java基础-2" class="headerlink" title="java基础(2)"></a>java基础(2)</h2><h3 id="1-java你用过的jdk版本"><a href="#1-java你用过的jdk版本" class="headerlink" title="1..java你用过的jdk版本"></a>1..java你用过的jdk版本</h3><blockquote><p>jdk1.8或者jdk11</p><p>关键问:</p><h3 id="你知道jdk1-8相较于1-7有什么新特性吗"><a href="#你知道jdk1-8相较于1-7有什么新特性吗" class="headerlink" title="你知道jdk1.8相较于1.7有什么新特性吗"></a>你知道jdk1.8相较于1.7有什么新特性吗</h3><ul><li>新增<strong>Lambda表达式</strong> ：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li>新增<strong>Stream API</strong>:对容器功能加强，可以对容器进行高效操作</li><li>新增<strong>方法引用</strong>:通过方法的名字来指向一个方法，用::</li><li>新增<strong>Optional类</strong>:解决空指针异常</li><li>新增default:接口可以有具体方法</li><li>新增<strong>日期API</strong></li></ul><p>(接下来可能会问Lambda表达式和StreamAPI)</p><h3 id="你知道jdk11有什么新特性吗"><a href="#你知道jdk11有什么新特性吗" class="headerlink" title="你知道jdk11有什么新特性吗"></a>你知道jdk11有什么新特性吗</h3><ul><li>新增本地类型推断:用var直接定义变量，编译器能自动推断类型</li><li>Optianal类增强，可以转换成流使用</li><li>字符类增加一些功能API</li></ul></blockquote><h3 id="2-用过final关键字吗？它有什么作用"><a href="#2-用过final关键字吗？它有什么作用" class="headerlink" title="2.用过final关键字吗？它有什么作用"></a>2.用过final关键字吗？它有什么作用</h3><blockquote><p> final关键字表示不可变，它可以修饰在类、方法、成员变量中。</p><ol><li>如果修饰在类上，则表示该类不允许被继承</li><li>修饰在方法上，表示该方法无法被重写</li><li>修饰在变量上，表示该变量无法被修改，而且JVM会隐性定义为一个常量。(但是可以通过反射去破坏，但是<strong>反射无法修改被final和static同时修饰的变量</strong>)</li></ol><p> 另外，<code>final</code>修饰的关键字，还可以避免因为指令重排序带来的可见性问题，原因是，final遵循两个重排序规则</p><ol><li>构造函数内，对一个 final 变量的写入，与随后把这个被构造对象的引用赋值给一个变量，这两个操作之间不可重排序。</li><li>首次读一个包含 final 变量的对象，与随后首次读这个 final 变量，这两个操作之间不可以重排序。</li></ol></blockquote><h3 id="3-反射知道吗-通过反射可以获取到一些什么东西"><a href="#3-反射知道吗-通过反射可以获取到一些什么东西" class="headerlink" title="3.反射知道吗 通过反射可以获取到一些什么东西"></a>3.反射知道吗 通过反射可以获取到一些什么东西</h3><blockquote><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><p><strong>① 通过反射获取类中的属性和属性值</strong></p><p><strong>② 通过反射获取反射类中的构造方法</strong></p><p><strong>③ 通过反射获取反射类的父类（超类）和接口</strong></p><p><strong>④通过反射获取反射类的方法</strong></p></blockquote><h3 id="4-序列化ID有什么作用？怎么生成的？"><a href="#4-序列化ID有什么作用？怎么生成的？" class="headerlink" title="4.序列化ID有什么作用？怎么生成的？"></a>4.序列化ID有什么作用？怎么生成的？</h3><blockquote><p>作用:验证版本一致性</p><p>反序列化时，程序会比较磁盘中的序列化版本号ID是否与当前类结构生成的版本号ID一致，如果一致，则反序列化成功</p><p>下图就是反序列化异常情况</p><p><img src="/2022/07/02/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(2)/image-20220709221426112.png" alt="image-20220709221426112"></p><p>生成方式：</p><p>首先，相关的类要实现Serializable接口</p><ul><li><p>手动生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">好处就是即使在原来类上加字段，也不会发生上图的反序列化失败，老版本兼容</span><br></pre></td></tr></table></figure></li><li><p>代码调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectStreamClass c = ObjectStreamClass.lookup(Student.class);</span><br><span class="line">long serialVersionUID = c.getSerialVersionUID();</span><br></pre></td></tr></table></figure></li><li><p>ide快捷工具</p></li></ul></blockquote><h3 id="5-为什么重写-equals-的同时必须重写-hashCode"><a href="#5-为什么重写-equals-的同时必须重写-hashCode" class="headerlink" title="5.为什么重写 equals 的同时必须重写 hashCode"></a>5.为什么重写 equals 的同时必须重写 hashCode</h3><blockquote><p>程序先进行 hashcode 的比较，如果不同，那没就不必在进行 equals 的比较了，这样就大大减少了 equals 比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用</p><p>hashCode 和 equals 两个方法是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，如果在重写 equals 时，不重写 hashCode，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。</p><p>回答:因为程序会先进行hashcode，我们希望Set集合能过滤相同数值的对象，因为涉及对象的值比较，我们重写equals，但我们要保证两个对象 equals 相等，那么hashcode也要相同，所以要重写hashcode，否则还是不能去重。（hashcode不是内存地址，跟内存地址相关）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java基础-2&quot;&gt;&lt;a href=&quot;#java基础-2&quot; class=&quot;headerlink&quot; title=&quot;java基础(2)&quot;&gt;&lt;/a&gt;java基础(2)&lt;/h2&gt;&lt;h3 id=&quot;1-java你用过的jdk版本&quot;&gt;&lt;a href=&quot;#1-java你用过的jd</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="java基础" scheme="https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>消息队列面试</title>
    <link href="https://gwtt.github.io/2022/06/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95/"/>
    <id>https://gwtt.github.io/2022/06/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95/</id>
    <published>2022-06-12T15:15:44.249Z</published>
    <updated>2022-08-02T14:57:20.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="1-消息队列有哪些作用"><a href="#1-消息队列有哪些作用" class="headerlink" title="1.消息队列有哪些作用"></a>1.消息队列有哪些作用</h3><blockquote><p>1．解耦:使用消息队列来作为两个系统直接的通讯方式，两个系统不需要相互依赖了</p><p>2．异步:系统A给消费队列发送完消息之后，就可以继续做其他事情了</p><p>3．流量削峰:如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，有消费者自己控制消费速度</p></blockquote><h3 id="2-死信队列和延迟队列是什么"><a href="#2-死信队列和延迟队列是什么" class="headerlink" title="2.死信队列和延迟队列是什么"></a>2.死信队列和延迟队列是什么</h3><blockquote><p>1．死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试<br>2．延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单</p></blockquote><h4 id="3-Kafka的Pull和Push分别有什么优缺点"><a href="#3-Kafka的Pull和Push分别有什么优缺点" class="headerlink" title="3.Kafka的Pull和Push分别有什么优缺点"></a>3.Kafka的Pull和Push分别有什么优缺点</h4><blockquote><ol><li>pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制，根据自己的消息处理能力来进行控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空</li><li>push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就得消费多少消息，所以可能会造成网络堵塞，消费者压力大等问题</li></ol></blockquote><h3 id="4-Kafka为什么比RocketMQ的吞吐量要高"><a href="#4-Kafka为什么比RocketMQ的吞吐量要高" class="headerlink" title="4.Kafka为什么比RocketMQ的吞吐量要高"></a>4.Kafka为什么比RocketMQ的吞吐量要高</h3><blockquote><p>Kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息并没有发送到Broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送给Broker。这种做法减少了网络io，从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了性能却降低了可靠性。</p></blockquote><h3 id="5-RocketMQ的底层实现原理"><a href="#5-RocketMQ的底层实现原理" class="headerlink" title="5.RocketMQ的底层实现原理"></a>5.RocketMQ的底层实现原理</h3><blockquote><p>RocketMQ由NameServer集群、Producer集群、Consumer集群、Broker集群组成，消息生产和消费的大致原理如下:</p><ul><li>Broker在启动的时候向所有的NameServer注册，并保持长连接，每30s发送一次心跳</li><li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li><li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li></ul></blockquote><h3 id="6-消息队列如何保证消息可靠传输"><a href="#6-消息队列如何保证消息可靠传输" class="headerlink" title="6.消息队列如何保证消息可靠传输"></a>6.消息队列如何保证消息可靠传输</h3><blockquote><ol><li>为了保证消息不多，也就是消息不能重复，也就是生产者不能重复生产消息，或者消费者不能重复消费消息</li><li>首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制</li><li>要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题</li><li>消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面</li><li>生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker</li><li>broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就 是消费端ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到ack后才会删除消息</li></ol></blockquote><h3 id="7-消息丢失怎么办"><a href="#7-消息丢失怎么办" class="headerlink" title="7.消息丢失怎么办"></a>7.消息丢失怎么办</h3><blockquote><p>丢失我们从三个角度出发(以下是RabbitMQ案例 )</p><h4 id="消费者丢数据"><a href="#消费者丢数据" class="headerlink" title="消费者丢数据"></a>消费者丢数据</h4><blockquote><p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ <strong>事务channel.txSelect</strong>，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</p><p><strong>缺点:吞吐量减少</strong></p><p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <strong>confirm</strong> 模式，在生产者那里设置开启 confirm 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm 机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p><p><strong>所以一般在生产者这块避免数据丢失，都是用 confirm 机制的。</strong></p></blockquote><h4 id="消息队列丢数据"><a href="#消息队列丢数据" class="headerlink" title="消息队列丢数据"></a>消息队列丢数据</h4><blockquote><p>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</p></blockquote><h4 id="消费端丢数据"><a href="#消费端丢数据" class="headerlink" title="消费端丢数据"></a>消费端丢数据</h4><blockquote><p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p><p>这个时候得用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p></blockquote><p><img src="https://pics3.baidu.com/feed/e1fe9925bc315c60668cdd22d3e7a31b48547744.jpeg?token=9ca5384b80f2f3bc315a49b06168b6d9" alt="img"></p></blockquote><h3 id="8-消息重复消费怎么办"><a href="#8-消息重复消费怎么办" class="headerlink" title="8.消息重复消费怎么办?"></a>8.消息重复消费怎么办?</h3><blockquote><h4 id="重复消费出现场景（消费完后没有返回状态然后重启重新消费）"><a href="#重复消费出现场景（消费完后没有返回状态然后重启重新消费）" class="headerlink" title="重复消费出现场景（消费完后没有返回状态然后重启重新消费）:"></a>重复消费出现场景（消费完后没有返回状态然后重启重新消费）:</h4><blockquote><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p><p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p><p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</p><p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p><p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p><p><strong>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</strong></p></blockquote><h4 id="如何保证幂等性"><a href="#如何保证幂等性" class="headerlink" title="如何保证幂等性"></a>如何保证幂等性</h4><blockquote><ul><li>数据库实现主键唯一</li><li>redis天然幂等性</li><li>唯一键和redis结合</li></ul></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h2&gt;&lt;h3 id=&quot;1-消息队列有哪些作用&quot;&gt;&lt;a href=&quot;#1-消息队列有哪些作用&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="消息队列" scheme="https://gwtt.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式面试</title>
    <link href="https://gwtt.github.io/2022/06/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95/"/>
    <id>https://gwtt.github.io/2022/06/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95/</id>
    <published>2022-06-12T15:14:14.872Z</published>
    <updated>2022-07-04T11:47:11.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="1-什么是CAP理论"><a href="#1-什么是CAP理论" class="headerlink" title="1.什么是CAP理论"></a>1.什么是CAP理论</h3><blockquote><p>CAP理论是分布式领域中非常重要的一个指导理论，C(Consistency)表示强一致性，A(Availability)表示可用性，P(Partition Tolerance)表示<br>分区容错性，CAP理论指出在目前的硬件条件下，一个分布式系统是必须要保证分区容错性的，而在这个前提下，分布式系统要么保证C，要么保证AP，无法同时保证CAP。</p><p><strong>分区容错性</strong>表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布式系统内部的某个结点挂点，或网络出现了故障，而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性的。</p><p><strong>强一致性</strong>表示，一个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的，不然就会造成数据不一致，所以强一致性和可用性是不能同时满足的。</p><p><strong>可用性</strong>表示，一个分布式系统对外要保证可用。</p></blockquote><h3 id="2-什么是BASE理论"><a href="#2-什么是BASE理论" class="headerlink" title="2.什么是BASE理论"></a>2.什么是BASE理论</h3><blockquote><p>由于不能同时满足CAP，所以出现了BASE理论:<br>1.BA: Basically Available，表示基本可用，表示可以允许一定程度的不可用，比如由于系统故障，请求时间变长，或者由于系统故障导致部分<br>非核心功能不可用，都是允许的</p><p>2.S: Soft state:表示分布式系统可以处于一种中间状态，比如数据正在同步</p><p>3.E:Eventually consistent，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后再达到一致，在达到一致过程中<br>系统也是可用的</p></blockquote><h3 id="3-什么是RPC"><a href="#3-什么是RPC" class="headerlink" title="3.什么是RPC"></a>3.什么是RPC</h3><blockquote><h2 id="什么是-RPC-？"><a href="#什么是-RPC-？" class="headerlink" title="什么是 RPC ？"></a>什么是 RPC ？</h2><ul><li>RPC (Remote Procedure Call)即<strong>远程过程调用</strong>，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。</li><li>除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</li><li>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。</li></ul><p><strong>简单的说</strong></p><ul><li>RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</li><li>RPC会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）。</li><li>客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</li></ul></blockquote><h3 id="4-什么是分布式ID"><a href="#4-什么是分布式ID" class="headerlink" title="4.什么是分布式ID"></a>4.什么是分布式ID</h3><blockquote><p>在分布式系统中，经常需要一些全局唯一的ID对数据、消息、http请求等进行唯一标识。那么这个全局唯一ID就叫分布式ID</p></blockquote><h3 id="5-为什么需要分布式ID"><a href="#5-为什么需要分布式ID" class="headerlink" title="5.为什么需要分布式ID"></a>5.为什么需要分布式ID</h3><blockquote><p>1.如果id我们使用的是数据库的自增长类型，在分布式系统中需要分库和分表时，会有两个相同的表，有可能产生主键冲突。</p><p>2.电商订单号，采用自增方式，是最简单的生成规则。但是！这种与流水号相同的订单号很容易就被竞争对手看出你公司真实的运营信息。</p></blockquote><h3 id="6-分布式ID解决方案"><a href="#6-分布式ID解决方案" class="headerlink" title="6.分布式ID解决方案"></a>6.分布式ID解决方案</h3><blockquote><p>1.uuid，这种方案复杂度最低，但是会影响存储空间和性能</p><p>⒉利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候此方案也不是最优方案</p><p>3.利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库(mysql)相比，性能有所提高,可以适当选用</p><p>4.雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证趋势递增。业界存在tinyid、 leaf等开源中间件实现了雪花算法</p></blockquote><h3 id="7-分布式锁的使用场景和实现方案"><a href="#7-分布式锁的使用场景和实现方案" class="headerlink" title="7.分布式锁的使用场景和实现方案"></a>7.分布式锁的使用场景和实现方案</h3><blockquote><p>在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时，遇到资源竞争时，可以利用ReentrantLock、synchronized等技术来作为锁，来控制共享资源的使用。</p><p>而在分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用ReentrantLock、synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，需要一个分布式锁生成器，分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁。</p><p>目前主流的分布式锁的实现方案有两种:</p><p>1.zookeeper:利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱</p><p>2.redis:利用redis的setnw、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式锁可能不可靠，不稳定(一旦redis中的数据出现了不一致)，可能会出现多个客户端同时加到锁的情况</p></blockquote><h3 id="8-分布式事务和实现实现方案"><a href="#8-分布式事务和实现实现方案" class="headerlink" title="8.分布式事务和实现实现方案"></a>8.分布式事务和实现实现方案</h3><blockquote><p>在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于一次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。常用解决方案有:</p><p>1.本地消息表:创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统</p><p>2.消息队列:目前RocketMQ中支持事务消息，它的工作原理是:</p><p>a.生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的</p><p>b.再创建订单，根据创建订单成功与否，向Broker发送commit或rollback</p><p>c.并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功</p><p>d.一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束</p><p>e.如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理</p><p>3.Seata:阿里开源的分布式事务框架，支持AT、TCC等多种模式，底层都是基于两阶段提交理论来实现的</p></blockquote><h3 id="9-简述zab协议"><a href="#9-简述zab协议" class="headerlink" title="9.简述zab协议"></a>9.简述zab协议</h3><blockquote><p>ZAB协议（Zookeeper Atomic Broadcast原子广播）是Zookeeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段:</p><p>1.领导者选举阶段:从Zookeeper集群中选出一个节点作为Leader，所有的写请求都会由Leader节点来处理</p><p>⒉数据同步阶段:集群中所有节点中的数据要和Leader节点保持一致，如果不一致则要进行同步</p><p>3.请求广播阶段:当Leader节点接收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致</p><p>但值得注意的是，Zookeeper只是尽量的在达到强一致性，实际上仍然只是最终一致性的。</p></blockquote><h3 id="10-Spring-Cloud和Dubbo有哪些区别"><a href="#10-Spring-Cloud和Dubbo有哪些区别" class="headerlink" title="10.Spring Cloud和Dubbo有哪些区别?"></a>10.Spring Cloud和Dubbo有哪些区别?</h3><blockquote><p>Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用间的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有SpringCloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来一起使用的。</p></blockquote><h3 id="11-什么是服务雪崩-什么是服务限流"><a href="#11-什么是服务雪崩-什么是服务限流" class="headerlink" title="11.什么是服务雪崩?什么是服务限流?"></a>11.什么是服务雪崩?什么是服务限流?</h3><blockquote><p>1.当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗<br>不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。<br>2．服务限流是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求<br>压垮，在秒杀中，限流是非常重要的。</p></blockquote><h3 id="12-什么是服务熔断-什么是服务降级-区别是什么"><a href="#12-什么是服务熔断-什么是服务降级-区别是什么" class="headerlink" title="12.什么是服务熔断?什么是服务降级?区别是什么?"></a>12.什么是服务熔断?什么是服务降级?区别是什么?</h3><blockquote><p>1.服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。</p><p>2.服务降级是指，当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力，这就是服务降级。</p><p>相同点:</p><p>1．都是为了防止系统崩溃</p><p>2．都让用户体验到某些功能暂时不可用</p><p>不同点:熔断是下游服务故障触发的，降级是为了降低系统负载</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分布式&quot;&gt;&lt;a href=&quot;#分布式&quot; class=&quot;headerlink&quot; title=&quot;分布式&quot;&gt;&lt;/a&gt;分布式&lt;/h2&gt;&lt;h3 id=&quot;1-什么是CAP理论&quot;&gt;&lt;a href=&quot;#1-什么是CAP理论&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="分布式" scheme="https://gwtt.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis面试(1)</title>
    <link href="https://gwtt.github.io/2022/06/12/Mybatis%E9%9D%A2%E8%AF%95(1)/"/>
    <id>https://gwtt.github.io/2022/06/12/Mybatis%E9%9D%A2%E8%AF%95(1)/</id>
    <published>2022-06-12T15:12:55.815Z</published>
    <updated>2022-07-02T09:39:28.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis-1"><a href="#Mybatis-1" class="headerlink" title="Mybatis(1)"></a>Mybatis(1)</h2><h3 id="1-Mybatis的优缺点"><a href="#1-Mybatis的优缺点" class="headerlink" title="1.Mybatis的优缺点"></a>1.Mybatis的优缺点</h3><blockquote><p>Mybaits 的优点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</span><br><span class="line"></span><br><span class="line">2.与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；</span><br><span class="line"></span><br><span class="line">3.很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。</span><br><span class="line"></span><br><span class="line">4.能够与 Spring 很好的集成；</span><br><span class="line"></span><br><span class="line">5.提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。</span><br></pre></td></tr></table></figure><p>MyBatis 框架的缺点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。</span><br><span class="line"></span><br><span class="line">2.SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-Mybatis中的-和-区别是什么"><a href="#2-Mybatis中的-和-区别是什么" class="headerlink" title="2.Mybatis中的#{}和${}区别是什么"></a>2.Mybatis中的#{}和${}区别是什么</h3><blockquote><p>1.#{}是预编译处理、是占位符，${}是字符串替换、是拼接符</p><p>2.Mybatis在处理#{}时，会将sql中的#替换为?号，调用PreparedStatement来赋值</p><p>3.Mybatis在处理${}时，就是把$替换成变量的值，调用Statement来赋值</p><p>4.使用#{}可以很大程度上防止SQL注入，提高系统安全性</p><p>5.#号防止sql注入的原理就是对参数及参数中的特殊字符进行了转义，从而达到防止sql注入的效果。</p></blockquote><h3 id="3-ORM框架是什么"><a href="#3-ORM框架是什么" class="headerlink" title="3.ORM框架是什么"></a>3.ORM框架是什么</h3><blockquote><p>对象关系映射（Object—Relational Mapping，简称ORM）</p><p>是一种为了解决面向对象与面向关系数据库存在的互不匹配的现象的技术；简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将java 程序中的对象自动持久化到关系数据库中；本质上就是将数据从一种形式转换到另外一种形式。</p><p>常见的比如Hibernate, Mybatis,TopLink等框架</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mybatis-1&quot;&gt;&lt;a href=&quot;#Mybatis-1&quot; class=&quot;headerlink&quot; title=&quot;Mybatis(1)&quot;&gt;&lt;/a&gt;Mybatis(1)&lt;/h2&gt;&lt;h3 id=&quot;1-Mybatis的优缺点&quot;&gt;&lt;a href=&quot;#1-Mybatis的</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mybatis" scheme="https://gwtt.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Redis面试</title>
    <link href="https://gwtt.github.io/2022/06/12/Redis%E9%9D%A2%E8%AF%95/"/>
    <id>https://gwtt.github.io/2022/06/12/Redis%E9%9D%A2%E8%AF%95/</id>
    <published>2022-06-12T15:11:30.900Z</published>
    <updated>2022-08-17T12:28:18.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-redis-的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？"><a href="#1-redis-的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？" class="headerlink" title="1.redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？"></a>1.redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？</h3><blockquote><h3 id="redis-持久化的两种方式"><a href="#redis-持久化的两种方式" class="headerlink" title="redis 持久化的两种方式"></a>redis 持久化的两种方式</h3><ul><li><p>RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。</p></li><li><p>AOF（append only file）：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。</p><h4 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a><strong>RDB 优缺点</strong></h4><ul><li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</li><li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li><li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</li><li>如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</li><li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li></ul><h4 id="AOF-优缺点"><a href="#AOF-优缺点" class="headerlink" title="AOF 优缺点"></a>AOF 优缺点</h4><ul><li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次<code>fsync</code>操作，最多丢失 1 秒钟的数据。</li><li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li><li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li><li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li><li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li><li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code>，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）</li><li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li></ul><h3 id="RDB-和-AOF-到底该如何选择"><a href="#RDB-和-AOF-到底该如何选择" class="headerlink" title="RDB 和 AOF 到底该如何选择"></a>RDB 和 AOF 到底该如何选择</h3><ul><li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</li><li>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</li><li>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li></ul></li></ul></blockquote><h3 id="2-说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？"><a href="#2-说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？" class="headerlink" title="2.说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？"></a>2.<strong>说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？</strong></h3><blockquote><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h2><p><strong>出现过程</strong></p><p>假设有如下一个系统，高峰期请求为5000次/秒，4000次走了缓存，只有1000次落到了数据库上，数据库每秒1000的并发是一个正常的指标，完全可以正常工作，<strong>但如果缓存宕机了，或者缓存设置了相同的过期时间，导致缓存在同一时刻同时失效</strong>，每秒5000次的请求会全部落到数据库上，数据库立马就死掉了，因为数据库一秒最多抗2000个请求，如果DBA重启数据库，立马又会被新的请求打死了，这就是缓存雪崩。</p><p><strong>解决方法</strong></p><ol><li>事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃</li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL被打死</li><li>事后：redis持久化RDB+AOF，快速恢复缓存数据</li><li>缓存的失效时间设置为随机值，避免同时失效</li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h2><p><strong>出现过程</strong></p><p>假如客户端每秒发送5000个请求，其中4000个为黑客的恶意攻击，即在数据库中也查不到。举个例子，用户id为正数，黑客构造的用户id为负数，如果黑客每秒一直发送这4000个请求，缓存就不起作用，数据库也很快被打死。</p><p><strong>解决方法</strong></p><ol><li>对请求参数进行校验，不合理直接返回</li><li>查询不到的数据也放到缓存，value为空，如 set -999 “”</li><li>使用布隆过滤器，快速判断key是否在数据库中存在，不存在直接返回</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h2><p><strong>出现过程</strong></p><p>设置了过期时间的key，承载着高并发，是一种热点数据。从这个key过期到重新从MySQL加载数据放到缓存的一段时间，大量的请求有可能把数据库打死。缓存雪崩是指大量缓存失效，缓存击穿是指热点数据的缓存失效</p><p><strong>解决方法</strong></p><ol><li><p>设置key永远不过期，或者快过期时，通过另一个异步线程重新设置key</p></li><li><p>当从缓存拿到的数据为null，重新从数据库加载数据的过程上锁，下面写个分布式锁实现的demo</p></li></ol>   <figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1，缓存雪崩:如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期时间上增加一点随机值，另外如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段</span><br><span class="line">2．缓存击穿:和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿，解决方案就是考虑这个热点key不设过期时间</span><br><span class="line">3．缓存穿透:假如某一时刻访问redis的大量key都在redis中不存在(比如黑客故意伪造一些乱七八糟的key)，那么也会给数据造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-redis为什么快"><a href="#3-redis为什么快" class="headerlink" title="3.redis为什么快"></a>3.redis为什么快</h3><blockquote><ul><li>1、<code>Redis</code> 是一款纯内存结构，避免了磁盘 <code>I/O</code> 等耗时操作。</li><li>2、<code>Redis</code> 命令处理的核心模块为单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。</li><li>3、采用了 <code>I/O</code> 多路复用机制，大大提升了并发效率。</li></ul></blockquote><h3 id="4-redis缓存淘汰策略"><a href="#4-redis缓存淘汰策略" class="headerlink" title="4.redis缓存淘汰策略"></a>4.redis缓存淘汰策略</h3><blockquote><p>Redis内存不足的缓存淘汰策略提供了8种。<br>noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键<br>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键<br>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键<br>allkeys-random：加入键的时候如果过限，从所有key随机删除<br>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐<br>volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键<br>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键<br>allkeys-lfu：从所有键中驱逐使用频率最少的键</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这八种大体上可以分为4中，lru、lfu、random、ttl。</span><br><span class="line">lru：Least Recently Used)，最近最少使用</span><br><span class="line">lfu：Least Frequently Used，最不经常使用法</span><br><span class="line">ttl：Time To Live，生存时间</span><br><span class="line">random：随机</span><br><span class="line">默认是noeviction。对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外</span><br><span class="line">eviction：“逐出；赶出；收回”。</span><br><span class="line">volatile：“不稳定的”。</span><br></pre></td></tr></table></figure><p><strong>Redis默认的过期策略是noeviction, 最暴力那个, 如果内存满了那就是一场“华丽”的故事了。</strong></p></blockquote><h3 id="5-Redis有哪些数据结构？分别有哪些典型的应用场景"><a href="#5-Redis有哪些数据结构？分别有哪些典型的应用场景" class="headerlink" title="5.Redis有哪些数据结构？分别有哪些典型的应用场景?"></a>5.Redis有哪些数据结构？分别有哪些典型的应用场景?</h3><blockquote><p>Redis的数据结构有:</p><ul><li>字符串:可以用来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</li><li>哈希表:可以用来存储一些key-value对，更适合用来存储对象</li><li>列表: Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据</li><li>集合:和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似,<br>我和某人共同关注的人、朋友圈点赞等功能</li><li>有序集合:集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</li></ul></blockquote><h3 id="6-Redis分布式锁底层是如何实现的"><a href="#6-Redis分布式锁底层是如何实现的" class="headerlink" title="6.Redis分布式锁底层是如何实现的"></a>6.Redis分布式锁底层是如何实现的</h3><blockquote><ul><li>首先利用setnx来保证:如果key不存在才能获取到锁，如果key存在，则获取不到锁</li><li>然后还要利用lua脚本来保证多个redis操作的原子性</li><li>同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约</li><li>同时还要考虑到redis书点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</li></ul></blockquote><h3 id="7-Redis和Mysql如何保证数据一致"><a href="#7-Redis和Mysql如何保证数据一致" class="headerlink" title="7.Redis和Mysql如何保证数据一致"></a>7.Redis和Mysql如何保证数据一致</h3><blockquote><p>1．先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致</p><p>2．先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中</p><p>3，延时双删，步骤是:先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致</p></blockquote><h3 id="8-redis的应用场景？"><a href="#8-redis的应用场景？" class="headerlink" title="8.redis的应用场景？"></a>8.redis的应用场景？</h3><blockquote><h4 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h4><p> 缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p><h4 id="2-排行榜"><a href="#2-排行榜" class="headerlink" title="2.排行榜"></a>2.排行榜</h4><p> 很多网站都有排行榜应用的，如淘宝的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p><h4 id="3-计数器"><a href="#3-计数器" class="headerlink" title="3.计数器"></a>3.计数器</h4><p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p><h4 id="4-分布式会话"><a href="#4-分布式会话" class="headerlink" title="4.分布式会话"></a>4.分布式会话</h4><p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p><h4 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5.分布式锁"></a>5.分布式锁</h4><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p><h4 id="6-朋友圈点赞"><a href="#6-朋友圈点赞" class="headerlink" title="6.朋友圈点赞"></a>6.朋友圈点赞</h4><p> 点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。</p><h4 id="7-最新消息"><a href="#7-最新消息" class="headerlink" title="7.最新消息"></a>7.最新消息</h4><p> Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p><h4 id="8-消息队列"><a href="#8-消息队列" class="headerlink" title="8.消息队列"></a>8.消息队列</h4><p> 消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h2&gt;&lt;h3 id=&quot;1-redis-的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？&quot;&gt;</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://gwtt.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
