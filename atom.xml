<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>滚~韬的博客</title>
  
  <subtitle>滚~</subtitle>
  <link href="https://gwtt.github.io/atom.xml" rel="self"/>
  
  <link href="https://gwtt.github.io/"/>
  <updated>2022-09-14T11:24:58.078Z</updated>
  <id>https://gwtt.github.io/</id>
  
  <author>
    <name>滚~韬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈Lambda表达式</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-09-14T11:14:23.000Z</published>
    <updated>2022-09-14T11:24:58.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Lambda表达式？"><a href="#什么是Lambda表达式？" class="headerlink" title="什么是Lambda表达式？"></a>什么是Lambda表达式？</h4><blockquote><p>可以将Lambda表达式理解为一个匿名函数； Lambda表达式允许将一个函数作为另外一个函数的参数； 我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码作为实参）,也可以理解为函数式编程，将一个函数作为参数进行传递。</p></blockquote><h4 id="2-为什么要引入Lambda表达式？"><a href="#2-为什么要引入Lambda表达式？" class="headerlink" title="2. 为什么要引入Lambda表达式？"></a>2. 为什么要引入Lambda表达式？</h4><blockquote><p>当java程序员看到其他语言的程序员（如JS，Python）在使用闭包或者Lambda表达式的时候，于是开始吐槽世界上使用最广的语言居然不支持函数式编程。千呼万唤，Java8推出了Lambda表达式。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.isea.java;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">       thread.start();</span><br><span class="line">       thread.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使这段代码变得更加简洁，可以使用匿名内部类重构一下（注意代码中的注释）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.isea.java;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="comment">//这里的new Runnable()，这里new 了接口，在这个new的接口里面，我们写了这个接口的实现类。</span></span><br><span class="line">        <span class="comment">//这里可以看出，我们把一个重写的run()方法传入了一个构造函数中。</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Lambda表达式的分类"><a href="#3-Lambda表达式的分类" class="headerlink" title="3. Lambda表达式的分类"></a>3. Lambda表达式的分类</h4><h5 id="1-无参无返回值"><a href="#1-无参无返回值" class="headerlink" title="1. 无参无返回值"></a>1. 无参无返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="2-有参无返回值"><a href="#2-有参无返回值" class="headerlink" title="2. 有参无返回值"></a>2. 有参无返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;AAAAA&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;BBBBB&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;CCCCC&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;DDDDD&quot;</span>);</span><br><span class="line"><span class="comment">//形参的类型是确定的，可省略；只有一个形参，()可以省略；</span></span><br><span class="line">        list.forEach(t -&gt; System.out.print(t + <span class="string">&quot;\t&quot;</span>));</span><br><span class="line"><span class="comment">//或者更简洁的方法引用：list.forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//打印结果：AAAAABBBBBCCCCCDDDDD</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span></span><br></pre></td></tr></table></figure></blockquote><p>forEach() 功能等同与增强型for循环 这个方法来自于Iterable接口，Collection接口继承了这个接口，List又继承了Collection接口，而ArrayList是List的实现类；forEach函数，指明该函数需要传入一个函数，而且是有参数没有返回值的函数，而Consumer接口中正好有且仅有一个这样的有参无返回值的抽象方法。接下来，我们会了解到这是使用Lambda的必要条件。</p><h5 id="3-无参有返回值"><a href="#3-无参有返回值" class="headerlink" title="3. 无参有返回值"></a>3. 无参有返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.generate(() -&gt;random.nextInt(<span class="number">100</span>));</span><br><span class="line">        stream.forEach(t -&gt; System.out.println(t));</span><br><span class="line">    &#125;<span class="comment">//只有一个return，可以省略return；该方法将会不断的打印100以内的正整数。</span></span><br><span class="line">&#125;<span class="comment">//Stream.generate()方法创建无限流，该方法要求传入一个无参有返回值的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> <span class="comment">//来自源码</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="4-有参有返回值"><a href="#4-有参有返回值" class="headerlink" title="4. 有参有返回值"></a>4. 有参有返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.Collator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collator</span> <span class="variable">collator</span> <span class="operator">=</span> Collator.getInstance();</span><br><span class="line">        TreeSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((s1,s2) -&gt; collator.compare(s1.getName(),s2.getName()));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">10</span>,<span class="string">&quot;张飞&quot;</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;周瑜&quot;</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>));</span><br><span class="line">        set.forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这里的Collator是一个抽象类，但是提供了获取该类实例的方法getInstance()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        Home | This.ID = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-函数式接口"><a href="#4-函数式接口" class="headerlink" title="4. 函数式接口"></a>4. 函数式接口</h4><blockquote><p>即SAM（Single Abstract Method ）接口，有且只有一个抽象方法的接口（可以有默认方法或者是静态方法和从Object继承来的方法，但是抽象方法有且只能有一个）。 JDK1.8之后，添加@FunctionalInterface表示这个接口是是一个函数式接口，因为有了@functionalInterface标记，也称这样的接口为Mark（标记）类型的接口。举例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">java.lang.Runnable&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">java.lang.Comparator&lt;T&gt;&#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面的例子，比方说这个Runnable接口是支持Lambda表达式，那么如果有一个方法（比如Thread类的构造函数）需要传入一个Runnable接口的实现类的话，那么就可以直接把Lambda表达式写进去。</p><p>换个角度说TreeSet，它有一个构造函数中是要求传入一个接口类型，如果这个接口类型恰好是函数式接口，那么直接传进去一个Lambda表达式即可。</p><p><strong>函数式接口作用</strong></p><blockquote><p>函数式接口能够接受匿名内部类的实例化对象，换句话说，我们可以使用匿名内部类来实例化函数式接口的对象，而Lambda表达式能够代替内部类实现代码的进一步简化，因此，Lambda表达式和函数式接口紧密的联系到了一起，接下来的这句话非常的重要：</p><p>每一个Lambda表达式能隐式的给函数式接口赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>)).start();</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>编译器会认为Thread()中传入的是一个Runnable的对象，而我们利用IDEA的智能感知，鼠标指向“-&gt;”或“（）”的时候，会发现这是一个Runnable类型，实际上编译器会自动将Lambda表达式赋值给函数式接口，在本例中就是Runnable接口。本例中Lambda表达式将打印方法传递给了Runnable接口中的run（）方法，从而形成真正的方法体。</p><p>而且，参数与返回值是一一对应的，即如果函数式接口中的抽象方法是有返回值，有参数的，那么要求Lambda表达式也是有返回值，有参数的（余下类推）</p></blockquote><blockquote><p><strong>四大函数式接口：</strong></p><p>有时候后，如果我们调用某一个方法，发现这个方法中需要传入的参数要求是一个函数式的接口，那么我们可以直接传入Lambda表达式。这些接口位于java.util.function包下，需要注意一下，java.util包和java.util.function包这两个包没有什么关系，切不可以为function包是java.util包下面的包。</p><ol><li>消费型接口：Consumer&lt; T&gt; void accept(T t)有参数，无返回值的抽象方法；</li><li>供给型接口：Supplier &lt; T&gt; T get() 无参有返回值的抽象方法；</li><li>断定型接口： Predicate&lt; T&gt; boolean test(T t):有参，但是返回值类型是固定的boolean</li><li>函数型接口： Function&lt; T，R&gt; R apply(T t)有参有返回值的抽象方法；</li></ol></blockquote><h4 id="5-新日期时间API-补充"><a href="#5-新日期时间API-补充" class="headerlink" title="5. 新日期时间API(补充)"></a>5. 新日期时间API(补充)</h4><blockquote><h4 id="1-LocalDate-只有年月日"><a href="#1-LocalDate-只有年月日" class="headerlink" title="1. LocalDate(只有年月日)"></a>1. LocalDate(只有年月日)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDate_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(date.getYear()+<span class="string">&quot; &quot;</span>+date.getMonthValue()+<span class="string">&quot; &quot;</span>+date.getDayOfMonth());</span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-LocalTime-只有时分秒"><a href="#2-LocalTime-只有时分秒" class="headerlink" title="2 . LocalTime(只有时分秒)"></a>2 . LocalTime(只有时分秒)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(time.getHour()+<span class="string">&quot; &quot;</span>+time.getMinute()+<span class="string">&quot; &quot;</span>+time.getSecond());</span><br><span class="line">        System.out.println(time.toString());</span><br><span class="line">        System.out.println(time.toSecondOfDay());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-LocalDateTime-年月日和时分秒"><a href="#3-LocalDateTime-年月日和时分秒" class="headerlink" title="3. LocalDateTime(年月日和时分秒)"></a>3. LocalDateTime(年月日和时分秒)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDateTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(dateTime.getYear()+<span class="string">&quot; &quot;</span>+dateTime.getMonthValue()+<span class="string">&quot; &quot;</span>+dateTime.getDayOfMonth()+</span><br><span class="line">                            dateTime.getHour()+<span class="string">&quot; &quot;</span>+dateTime.getMinute()+<span class="string">&quot; &quot;</span>+dateTime.getSecond());</span><br><span class="line">        System.out.println(dateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-DateTimeFormatter"><a href="#4-DateTimeFormatter" class="headerlink" title="4. DateTimeFormatter"></a>4. DateTimeFormatter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTimeFormatter_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd:HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2017-12-15:19:15:01&quot;</span>,formatter);</span><br><span class="line">        System.out.println(dateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-ZonedDateTime-有时区"><a href="#5-ZonedDateTime-有时区" class="headerlink" title="5. ZonedDateTime(有时区)"></a>5. ZonedDateTime(有时区)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZonedDateTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;MM/dd/yyyy:HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> zonedDateTime.format(formatter);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是Lambda表达式？&quot;&gt;&lt;a href=&quot;#什么是Lambda表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是Lambda表达式？&quot;&gt;&lt;/a&gt;什么是Lambda表达式？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;可以将Lambda表达式理</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Stream流</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Stream%E6%B5%81/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Stream%E6%B5%81/</id>
    <published>2022-09-14T08:52:23.000Z</published>
    <updated>2022-09-14T09:59:40.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Stream流"><a href="#什么是Stream流" class="headerlink" title="什么是Stream流"></a>什么是Stream流</h2><blockquote><p><code>Stream</code>被翻译为流，它的工作过程像将一瓶水导入有很多过滤阀的管道一样，水每经过一个过滤阀，便被操作一次，比如过滤，转换等，最后管道的另外一头有一个容器负责接收剩下的水。</p><p><code>Stream</code>作为Java 8的一大亮点，它专门针对集合的各种操作提供各种非常便利，简单，高效的API,<code>Stream API</code>主要是通过<code>Lambda</code>表达式完成，极大的提高了程序的效率和可读性，同时<code>Stram API</code>中自带的并行流使得并发处理集合的门槛再次降低，使用<code>Stream API</code>编程无需多写一行多线程的大门就可以非常方便的写出高性能的并发程序。使用<code>Stream API</code>能够使你的代码更加优雅。</p><p>流的另一特点是可无限性，使用<code>Stream</code>，你的数据源可以是无限大的。</p></blockquote><h2 id="如何使用流"><a href="#如何使用流" class="headerlink" title="如何使用流"></a>如何使用流</h2><blockquote><ul><li>获取流</li><li>对流操作</li><li>结束对流操作</li></ul></blockquote><h3 id="获取流"><a href="#获取流" class="headerlink" title="-  获取流"></a>-  获取流</h3><blockquote><p>获取流的方式有多种，对于常见的容器(<code>Collection</code>)可以直接<code>.stream()</code>获取 例如：</p><ul><li><code>Collection.stream()</code></li><li><code>Collection.parallelStream()</code></li><li><code>Arrays.stream(T array) or Stream.of()</code></li></ul><p>对于<code>IO</code>，我们也可以通过<code>lines()</code>方法获取流：</p><ul><li><code>java.nio.file.Files.walk()</code></li><li><code>java.io.BufferedReader.lines()</code></li></ul><p>最后，我们还可以从无限大的数据源中产生流：</p><ul><li><code>Random.ints()</code></li></ul><p>值得注意的是，<code>JDK</code>中针对基本数据类型的昂贵的装箱和拆箱操作，提供了基本数据类型的流：</p><ul><li><p><code>IntStream</code></p></li><li><p><code>LongStream</code></p></li><li><p><code>DoubleStream</code></p><p>这三种基本数据类型和普通流差不多，不过他们流里面的数据都是指定的基本数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intstream.of(new int[]&#123;1,2,3&#125;);</span><br><span class="line">Intstream.range(1,3);</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这边有个parallelStream和stream的区别</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为parallelstream是并行流,所以执行效率比较高</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并行流并不会按照原本的顺序轨迹执行, 而是 随机执行</span></span><br><span class="line">可以从以下三点入手考虑是否使用parallelstream</span><br><span class="line">是否需要并行？  </span><br><span class="line">任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class="line">结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure><blockquote><p>获取流的方式有多种，对于常见的容器(<code>Collection</code>)可以直接<code>.stream()</code>获取 例如：</p><ul><li><code>Collection.stream()</code></li><li><code>Collection.parallelStream()</code></li><li><code>Arrays.stream(T array) or Stream.of()</code></li></ul><p>对于<code>IO</code>，我们也可以通过<code>lines()</code>方法获取流：</p><ul><li><code>java.nio.file.Files.walk()</code></li><li><code>java.io.BufferedReader.lines()</code></li></ul><p>最后，我们还可以从无限大的数据源中产生流：</p><ul><li><code>Random.ints()</code></li></ul><p>值得注意的是，<code>JDK</code>中针对基本数据类型的昂贵的装箱和拆箱操作，提供了基本数据类型的流：</p><ul><li><p><code>IntStream</code></p></li><li><p><code>LongStream</code></p></li><li><p><code>DoubleStream</code></p><p>这三种基本数据类型和普通流差不多，不过他们流里面的数据都是指定的基本数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intstream.of(new int[]&#123;1,2,3&#125;);</span><br><span class="line">Intstream.rang(1,3);</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这边有个parallelStream和stream的区别</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为parallelstream是并行流,所以执行效率比较高</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并行流并不会按照原本的顺序轨迹执行, 而是 随机执行</span></span><br><span class="line">可以从以下三点入手考虑是否使用parallelstream</span><br><span class="line">是否需要并行？  </span><br><span class="line">任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class="line">结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure><h3 id="对流操作"><a href="#对流操作" class="headerlink" title="- 对流操作"></a>- 对流操作</h3><blockquote><p>对于中间操作，所有的<code>API</code>的返回值基本都是<code>Stream&lt;T&gt;</code>,因此以后看见一个陌生的<code>API</code>也能通过返回值判断它的所属类型。</p><h6 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a><strong>map/flatMap</strong></h6><p><code>map</code>顾名思义，就是映射，<code>map</code>操作能够将流中的每一个元素映射为另外的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p>可以看到<code>map</code>接受的是一个<code>Function</code>,也就是接收参数，并返回一个值。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提取 List&lt;Student&gt;  所有student 的名字 </span></span><br><span class="line">List&lt;String&gt; studentNames = students.stream().map(Student::getName)</span><br><span class="line">                                             .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上面的代码等同于以前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; studentNames=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line">    studentNames.add(student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>再比如：将List中所有字母转换为大写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words=Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt; upperWords=words.stream().map(String::toUpperCase)</span><br><span class="line">                                      .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><p><code>flatMap</code>顾名思义就是扁平化映射，它具体的操作是将多个<code>stream</code>连接成一个<code>stream</code>，这个操作是针对类似多维数组的，比如容器里面包含容器等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ints=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">                                          Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)));</span><br><span class="line">List&lt;Integer&gt; flatInts=ints.stream().flatMap(Collection::stream).</span><br><span class="line">                                       collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>可以看到，相当于降维。</p><hr><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filter`顾名思义，就是过滤，通过测试的元素会被留下来并生成一个新的`Stream</span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure><p>同理，我们可以<code>filter</code>接收的参数是<code>Predicate</code>，也就是推断型函数式接口，接收参数，并返回<code>boolean</code>值。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有大于18岁的学生</span></span><br><span class="line">List&lt;Student&gt; studentNames = students.stream().filter(s-&gt;s.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">                                              .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a><strong>distinct</strong></h6><p><code>distinct</code>是去重操作,它没有参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><hr><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a><strong>sorted</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sorted`排序操作，默认是从小到大排列，sorted方法包含一个重载，使用sorted方法，如果没有传递参数，那么流中的元素就需要实现Comparable&lt;T&gt;方法，也可以在使sorted方法的时候传入一个`Comparator&lt;T&gt;</span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>值得一说的是这个<code>Comparator</code>在<code>Java 8</code>之后被打上了<code>@FunctionalInterface</code>,其他方法都提供了<code>default</code>实现，因此我们可以在<code>sort</code>中使用<code>Lambda</code>表达式</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以年龄排序</span></span><br><span class="line">students.stream().sorted((s,o)-&gt;Integer.compare(s.getAge(),o.getAge()))</span><br><span class="line">                                  .forEach(System.out::println);;</span><br></pre></td></tr></table></figure><p>然而还有更方便的，<code>Comparator</code>默认也提供了实现好的方法引用，使得我们更加方便的使用：</p><p>例如上面的代码可以改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以年龄排序 </span></span><br><span class="line">students.stream().sorted(Comparator.comparingInt(Student::getAge))</span><br><span class="line">                            .forEach(System.out::println);;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以姓名排序</span></span><br><span class="line">students.stream().sorted(Comparator.comparing(Student::getName)).</span><br><span class="line">                          forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>是不是更加简洁。</p><hr><h6 id="peek"><a href="#peek" class="headerlink" title="peek"></a><strong>peek</strong></h6><p><code>peek</code>有遍历的意思，和<code>forEach</code>一样，但是它是一个中间操作。</p><p><code>peek</code>接受一个消费型的函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去重以后打印出来，然后再归并为List</span></span><br><span class="line">List&lt;Student&gt; sortedStudents= students.stream().distinct().peek(System.out::println).</span><br><span class="line">                                                collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h6 id="limit"><a href="#limit" class="headerlink" title="limit"></a><strong>limit</strong></h6><p><code>limit</code>裁剪操作，和<code>String::subString(0,x)</code>有点先沟通，<code>limit</code>接受一个<code>long</code>类型参数，通过<code>limit</code>之后的元素只会剩下<code>min(n,size)</code>个元素，<code>n</code>表示参数，<code>size</code>表示流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只留下前6个元素并打印</span></span><br><span class="line">students.stream().limit(<span class="number">6</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h6 id="skip"><a href="#skip" class="headerlink" title="skip"></a><strong>skip</strong></h6><p><code>skip</code>表示跳过多少个元素，和<code>limit</code>比较像，不过<code>limit</code>是保留前面的元素，<code>skip</code>是保留后面的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳过前3个元素并打印 </span></span><br><span class="line">students.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></blockquote><h3 id="终结操作"><a href="#终结操作" class="headerlink" title="- 终结操作"></a>- 终结操作</h3><blockquote><p>一个流处理中，有且只能有一个终结操作，通过终结操作之后，流才真正被处理，终结操作一般都返回其他的类型而不再是一个流,一般来说，终结操作都是将其转换为一个容器。</p><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><strong>forEach</strong></h6><p><code>forEach</code>是终结操作的遍历，操作和<code>peek</code>一样，但是<code>forEach</code>之后就不会再返回流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历打印</span></span><br><span class="line">students.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的代码和一下代码效果相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line">    System.out.println(sudents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a><strong>toArray</strong></h6><p><code>toArray</code>和<code>List##toArray()</code>用法差不多，包含一个重载。</p><p>默认的<code>toArray()</code>返回一个<code>Object[]</code>，</p><p>也可以传入一个<code>IntFunction&lt;A[]&gt; generator</code>指定数据类型</p><p>一般建议第二种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student[] studentArray = students.stream().skip(<span class="number">3</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><hr><h6 id="max-min"><a href="#max-min" class="headerlink" title="max/min"></a><strong>max/min</strong></h6><p><code>max/min</code>即使找出最大或者最小的元素。<code>max/min</code>必须传入一个<code>Comparator</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure><hr><h6 id="count"><a href="#count" class="headerlink" title="count"></a><strong>count</strong></h6><p><code>count</code>返回流中的元素数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span>  <span class="variable">count</span> <span class="operator">=</span> students.stream().skip(<span class="number">3</span>).count();</span><br></pre></td></tr></table></figure><hr><h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><strong>reduce</strong></h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce为归纳操作，主要是将流中各个元素结合起来，它需要提供一个起始值，然后按一定规则进行运算，比如相加等，它接收一个二元操作 <span class="code">`BinaryOperator`</span>函数式接口。从某种意义上来说，<span class="code">`sum,min,max,average`</span>都是特殊的reduce</span><br></pre></td></tr></table></figure><p><code>reduce</code>包含三个重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"></span><br><span class="line"> &lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity,</span></span><br><span class="line"><span class="params">                 BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">        </span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> integers.stream().reduce(<span class="number">0</span>,(x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure><p>以上代码等同于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> integers.stream().reduce(Integer::sum).get();</span><br></pre></td></tr></table></figure><p><code>reduce</code>两个参数和一个参数的区别在于有没有提供一个起始值，</p><p>如果提供了起始值，则可以返回一个确定的值，如果没有提供起始值，则返回<code>Opeational</code>防止流中没有足够的元素。</p><hr><h6 id="anyMatch-allMatch-noneMatch"><a href="#anyMatch-allMatch-noneMatch" class="headerlink" title="anyMatch\ allMatch\ noneMatch"></a><strong>anyMatch\ allMatch\ noneMatch</strong></h6><p>测试是否有任意元素\所有元素\没有元素匹配表达式</p><p>他们都接收一个推断类型的函数式接口：<code>Predicate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">noneMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> integers.stream().anyMatch(x-&gt;x&gt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h6 id="findFirst、-findAny"><a href="#findFirst、-findAny" class="headerlink" title="findFirst、 findAny"></a><strong>findFirst、 findAny</strong></h6><p>获取元素，这两个<code>API</code>都不接受任何参数，<code>findFirt</code>返回流中第一个元素，<code>findAny</code>返回流中任意一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">findFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">findAny</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>也有有人会问<code>findAny()</code>这么奇怪的操作谁会用？这个<code>API</code>主要是为了在并行条件下想要获取任意元素，以最大性能获取任意元素</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> integers.stream().findAny().get();</span><br></pre></td></tr></table></figure><hr><h6 id="collect"><a href="#collect" class="headerlink" title="collect"></a><strong>collect</strong></h6><p><code>collect</code>收集操作，这个<code>API</code>放在后面将是因为它太重要了，基本上所有的流操作最后都会使用它。</p><p>我们先看<code>collect</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>collect</code>包含两个重载：</p><p>一个参数和三个参数，</p><p>三个参数我们很少使用，因为<code>JDK</code>提供了足够我们使用的<code>Collector</code>供我们直接使用,我们可以简单了解下这三个参数什么意思：</p><ul><li><code>Supplier</code>:用于产生最后存放元素的容器的生产者</li><li><code>accumulator</code>:将元素添加到容器中的方法</li><li><code>combiner</code>：将分段元素全部添加到容器中的方法</li></ul><p>前两个元素我们都很好理解，第三个元素是干嘛的呢？因为流提供了并行操作，因此有可能一个流被多个线程分别添加，然后再将各个子列表依次添加到最终的容器中。</p><p>↓ - - - - - - - - -</p><p>↓ — — —</p><p>↓ ———</p><p>如上图，分而治之。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = stream.collect(ArrayList::<span class="keyword">new</span>, List::add, List::addAll);</span><br></pre></td></tr></table></figure><hr><p>接下来看只有一个参数的<code>collect</code></p><p>一般来说，只有一个参数的<code>collect</code>，我们都直接传入<code>Collectors</code>中的方法引用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; = integers.stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><code>Collectors</code>中包含很多常用的转换器。<code>toList()</code>,<code>toSet()</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collectors`中还包括一个`groupBy()`，他和`Sql`中的`groupBy`一样都是分组，返回一个`Map</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按学生年龄分组</span></span><br><span class="line">Map&lt;Integer,List&lt;Student&gt;&gt; map= students.stream().</span><br><span class="line">                                collect(Collectors.groupingBy(Student::getAge));</span><br></pre></td></tr></table></figure><p><code>groupingBy</code>可以接受3个参数，分别是</p><ol><li>第一个参数：分组按照什么分类</li><li>第二个参数：分组最后用什么容器保存返回（当只有两个参数是，此参数默认为<code>HashMap</code>）</li><li>第三个参数：按照第一个参数分类后，对应的分类的结果如何收集</li></ol><p>有时候单参数的<code>groupingBy</code>不满足我们需求的时候，我们可以使用多个参数的<code>groupingBy</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生以年龄分组，每组中只存学生的名字而不是对象</span></span><br><span class="line">Map&lt;Integer,List&lt;String&gt;&gt; map =  students.stream().</span><br><span class="line">  collect(Collectors.groupingBy(Student::getAge,Collectors.mapping(Student::getName,Collectors.toList())));</span><br></pre></td></tr></table></figure><p><code>toList</code>默认生成的是<code>ArrayList</code>,<code>toSet</code>默认生成的是<code>HashSet</code>，如果想要指定其他容器，可以如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> students.stream().collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">Collectors`还包含一个`toMap`，利用这个`API`我们可以将`List`转换为`Map</span><br><span class="line">  Map&lt;Integer,Student&gt; map=students.stream().</span><br><span class="line">                           collect(Collectors.toMap(Student::getAge,s-&gt;s));</span><br></pre></td></tr></table></figure><p>值得注意的一点是，<code>IntStream</code>，<code>LongStream</code>,<code>DoubleStream</code>是没有<code>collect()</code>方法的，因为对于基本数据类型，要进行装箱，拆箱操作，SDK并没有将它放入流中，对于基本数据类型流，我们只能将其<code>toArray()</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Stream流&quot;&gt;&lt;a href=&quot;#什么是Stream流&quot; class=&quot;headerlink&quot; title=&quot;什么是Stream流&quot;&gt;&lt;/a&gt;什么是Stream流&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt;被翻译为流，</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数据库大数据量问题</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%8F%92%E5%85%A5/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%8F%92%E5%85%A5/</id>
    <published>2022-09-14T03:27:23.000Z</published>
    <updated>2022-09-14T07:53:01.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大批量插入数据优化"><a href="#大批量插入数据优化" class="headerlink" title="大批量插入数据优化"></a>大批量插入数据优化</h2><blockquote><h3 id="1-一条SQL语句插入多条数据"><a href="#1-一条SQL语句插入多条数据" class="headerlink" title="1.一条SQL语句插入多条数据"></a>1.一条SQL语句插入多条数据</h3><p>常用的插入语句如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>修改后的插入操作能够提高程序的插入效率。这里第二种SQL执行效率高的主要原因是合并后日志量（MySQL的binlog和innodb的事务让日志）减少了， <strong>降低日志刷盘的数据量和频率，从而提高效率</strong>。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传输的IO 。</p><p>可以显著提高效率</p><h3 id="2-在事务中进行插入处理。"><a href="#2-在事务中进行插入处理。" class="headerlink" title="2.在事务中进行插入处理。"></a>2.在事务中进行插入处理。</h3><p>把插入修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>使用事务可以提高数据的插入效率，这是因为进行一个INSERT操作时，<strong>MySQL内部会建立一个事务</strong>，在事务内才进行真正插入处理操作。通过使用事务可以减少创建事务的消耗， <code>所有插入都在执行后才进行提交操作</code> 。</p><h3 id="3-数据有序插入。"><a href="#3-数据有序插入。" class="headerlink" title="3.数据有序插入。"></a>3.数据有序插入。</h3><p>数据有序的插入是指插入记录在主键上是有序排列，例如datetime是记录的主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;userid_2&#x27;</span>, <span class="string">&#x27;content_2&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;userid_2&#x27;</span>, <span class="string">&#x27;content_2&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>由于数据库插入时，需要维护索引数据</strong>，<code>无序的记录会增大维护索引的成本</code>。 我们可以参照InnoDB使用的B+tree索引，如果每次插入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，需要B+tree进行分裂合并等处理，会消耗比较多计算资源，并且插入记录的索引定位效率会下降，数据量较大时会有频繁的磁盘操作。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大批量插入数据优化&quot;&gt;&lt;a href=&quot;#大批量插入数据优化&quot; class=&quot;headerlink&quot; title=&quot;大批量插入数据优化&quot;&gt;&lt;/a&gt;大批量插入数据优化&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;1-一条SQL语句插入多条数据&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引相关</title>
    <link href="https://gwtt.github.io/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://gwtt.github.io/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/</id>
    <published>2022-09-14T02:32:47.141Z</published>
    <updated>2022-09-14T03:12:10.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么用-B-树做索引而不用哈希表做索引"><a href="#为什么用-B-树做索引而不用哈希表做索引" class="headerlink" title="为什么用 B+ 树做索引而不用哈希表做索引?"></a>为什么用 B+ 树做索引而不用哈希表做索引?</h3><blockquote><p>1、哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。</p><p>2、如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。</p><p>3、索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的<strong>链表</strong>，这样的话，查找的时间就会大大增加。</p></blockquote><h3 id="主键索引和非主键索引有什么区别？"><a href="#主键索引和非主键索引有什么区别？" class="headerlink" title="主键索引和非主键索引有什么区别？"></a>主键索引和非主键索引有什么区别？</h3><blockquote><p>例如对于下面这个表(其实就是上面的表中增加了一个k字段),且ID是主键。</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640.png" alt="图片"></p><p>主键索引和非主键索引的示意图如下：</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631230630081.png" alt="图片"></p><p>其中R代表一整行的值。</p><p>从图中不难看出，主键索引和非主键索引的区别是：非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>，其中非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p><p>根据这两种结构我们来进行下查询，看看他们在查询上有什么区别。</p><p>1、如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p><p>2、如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为回表。</p></blockquote><h3 id="为什么建议使用主键自增的索引？"><a href="#为什么建议使用主键自增的索引？" class="headerlink" title="为什么建议使用主键自增的索引？"></a>为什么建议使用主键自增的索引？</h3><blockquote><p>对于这颗主键索引的树</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631245106466.png" alt="图片"></p><p>如果我们插入 ID = 650 的一行数据，那么直接在最右边插入就可以了</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631245106467.png" alt="图片"></p><p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行<strong>页分裂</strong>操作，这样会更加糟糕。</p><p>但是，如果我们的主键是自增的，每次插入的 ID 都会比前面的大，那么我们每次只需要在后面插入就行， 不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么用-B-树做索引而不用哈希表做索引&quot;&gt;&lt;a href=&quot;#为什么用-B-树做索引而不用哈希表做索引&quot; class=&quot;headerlink&quot; title=&quot;为什么用 B+ 树做索引而不用哈希表做索引?&quot;&gt;&lt;/a&gt;为什么用 B+ 树做索引而不用哈希表做索引?&lt;/</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="MySQL" scheme="https://gwtt.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MySQL慢查询</title>
    <link href="https://gwtt.github.io/2022/09/11/%E6%B5%85%E8%B0%88Mysql%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <id>https://gwtt.github.io/2022/09/11/%E6%B5%85%E8%B0%88Mysql%E6%85%A2%E6%9F%A5%E8%AF%A2/</id>
    <published>2022-09-11T11:44:18.000Z</published>
    <updated>2022-09-11T15:42:07.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="慢查询是什么"><a href="#慢查询是什么" class="headerlink" title="慢查询是什么"></a>慢查询是什么</h3><blockquote><p>MySQL的慢查询，全名是<strong>慢查询日志</strong>，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。</p><p>具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。</p><p>long_query_time的默认值为10，意思是记录运行10秒以上的语句。</p><p>默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>慢查询日志支持将日志记录写入文件和数据库表。</p></blockquote><h3 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h3><blockquote><p><strong>mysql并不启动慢查询日志</strong>，需要我们手动开启</p><ul><li>1、输入命令开启慢查询（临时），在MySQL服务重启后会自动关闭；</li><li>2、配置my.cnf（windows是my.ini）系统文件开启，修改配置文件是持久化开启慢查询的方式</li></ul></blockquote><blockquote><h3 id="命令开启"><a href="#命令开启" class="headerlink" title="命令开启"></a>命令开启</h3><p>查询慢查询是否开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>开启慢查询命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>; </span><br></pre></td></tr></table></figure><p>指定记录慢查询日志SQL执行时间得阈值（long_query_time 单位：秒，默认10秒）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><p>查询 “慢查询日志文件存放位置”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log_file%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="配置文件开启"><a href="#配置文件开启" class="headerlink" title="配置文件开启"></a>配置文件开启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启慢查询功能</span></span><br><span class="line">slow_query_log=ON</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定记录慢查询日志SQL执行时间得阈值</span></span><br><span class="line">long_query_time=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选填，默认数据文件路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slow_query_log_file=/var/lib/mysql/localhost-slow.log</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="慢查询经验"><a href="#慢查询经验" class="headerlink" title="慢查询经验"></a>慢查询经验</h2><h3 id="LIMIT分页"><a href="#LIMIT分页" class="headerlink" title="LIMIT分页"></a>LIMIT分页</h3><blockquote><h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><p>  在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</p><p>  一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 1000000,10这样的查询，这是mysql需要查询1000000条然后只返回最后10条，前面的1000000条记录都将被舍弃，这样的代价很高，会造成慢查询。</p><p>  优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p>对于下面的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行耗时：1.379s</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info LIMIT <span class="number">1000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p> 该语句存在的最大问题在于limit M,N中偏移量M太大，导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。</p><p>  那么如果我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的10条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次查询都先从整个表中先找到满足条件的前M条记录，舍弃掉，再从M+1开始再找到10条满足条件的记录了。</p><h3 id="思路一：构造覆盖索引"><a href="#思路一：构造覆盖索引" class="headerlink" title="思路一：构造覆盖索引"></a>思路一：构造覆盖索引</h3><p>  通过修改SQL，使用上覆盖索引，比如我需要只查询表中的app_name、createTime等少量字段，那么我秩序在app_name、createTime字段设置联合索引，即可实现覆盖索引，无需全表扫描。适用于查询列较少的场景，查询列数过多的不推荐。</p><p>耗时：<code>0.390s</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> app_name,createTime <span class="keyword">from</span> vio_basic_domain_info LIMIT <span class="number">1000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="思路二：优化offset"><a href="#思路二：优化offset" class="headerlink" title="思路二：优化offset"></a>思路二：优化offset</h3><p>  无法用上覆盖索引，那么重点是想办法快速过滤掉前100w条数据。我们可以利用自增主键有序的条件，先查询出第1000001条数据的id值，再往后查10行；适用于主键id自增的场景。<br>耗时：<code>0.471s</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">where</span> </span><br><span class="line">  id <span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> id <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> id limit <span class="number">1000000</span>,<span class="number">1</span>) limit <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法三：“延迟关联”"><a href="#方法三：“延迟关联”" class="headerlink" title="方法三：“延迟关联”"></a>方法三：“延迟关联”</h3><p>耗时：<code>0.439s</code><br>延迟关联适用于数量级较大的表，SQL如下；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">1000000</span>,<span class="number">10</span>) <span class="keyword">as</span> myNew <span class="keyword">using</span>(id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们利用到了<code>覆盖索引+延迟关联查询</code>，相当于先只查询id列，利用覆盖索引快速查到该页的10条数据id，然后再把返回的10条id拿到表中通过主键索引二次查询。（表数据增速快的情况对该方法影响较小。）</p></blockquote><h3 id="索引没起作用"><a href="#索引没起作用" class="headerlink" title="索引没起作用"></a>索引没起作用</h3><blockquote><h3 id="1-模糊查询尽量避免用通配符’-’开头，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#1-模糊查询尽量避免用通配符’-’开头，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="1.模糊查询尽量避免用通配符’%’开头，会导致数据库引擎放弃索引进行全表扫描。如下："></a>1.模糊查询尽量避免用通配符’%’开头，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%MIKE%&#x27;</span> #不推荐</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;MIKE%&#x27;</span> #推荐</span><br></pre></td></tr></table></figure><p>如果需求是要在前面使用模糊查询，</p><p>使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置。<br>使用FullText全文索引，用match against 检索<br>数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级<br>当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like ‘%xx%’。<br>  但不得不说，MySQL模糊匹配大字段是硬伤，毕竟保证事务的ACID特性耗费了太多性能，因此，如果实际场景中有类似业务需求，建议果断更换大数据存储引擎如<strong>ElasticSearch</strong>、<strong>Hbase</strong>等。</p><h3 id="2-尽量避免使用-not-in，会导致引擎走全表扫描。建议用-not-exists-代替，如下："><a href="#2-尽量避免使用-not-in，会导致引擎走全表扫描。建议用-not-exists-代替，如下：" class="headerlink" title="2.尽量避免使用 not in，会导致引擎走全表扫描。建议用 not exists 代替，如下："></a>2.尽量避免使用 not in，会导致引擎走全表扫描。建议用 not exists 代替，如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> name <span class="keyword">not</span> <span class="keyword">IN</span> (<span class="string">&#x27;提莫&#x27;</span>,<span class="string">&#x27;队长&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">as</span> t1 <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">as</span> t2 <span class="keyword">where</span> name <span class="keyword">IN</span> (<span class="string">&#x27;提莫&#x27;</span>,<span class="string">&#x27;队长&#x27;</span>) <span class="keyword">and</span> t1.id <span class="operator">=</span> t2.id);</span><br></pre></td></tr></table></figure><h3 id="3-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#3-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="3.尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下："></a>3.尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优化方式：可以用<span class="keyword">union</span>代替<span class="keyword">or</span>。如下：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="4-尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#4-尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下："></a>4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">优化方式：可以给字段添加默认值<span class="number">0</span>，对<span class="number">0</span>值进行判断。如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> score <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="5-尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下："><a href="#5-尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下：" class="headerlink" title="5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下："></a>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全表扫描</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> score<span class="operator">/</span><span class="number">10</span> <span class="operator">=</span> <span class="number">9</span></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> score <span class="operator">=</span> <span class="number">10</span><span class="operator">*</span><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="6-当数据量大时，避免使用where-1-1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下："><a href="#6-当数据量大时，避免使用where-1-1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：" class="headerlink" title="6.当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下："></a>6.当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username, age, sex <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">优化方式：用代码拼装<span class="keyword">sql</span>时进行判断，没 <span class="keyword">where</span> 条件就去掉 <span class="keyword">where</span>，有<span class="keyword">where</span>条件就加 <span class="keyword">and</span>。</span><br></pre></td></tr></table></figure><h3 id="7-查询条件不要用-lt-gt-或者"><a href="#7-查询条件不要用-lt-gt-或者" class="headerlink" title="7.查询条件不要用 &lt;&gt; 或者 !="></a>7.查询条件不要用 &lt;&gt; 或者 !=</h3><p>使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</p><h3 id="8-where条件仅包含复合索引非前导列"><a href="#8-where条件仅包含复合索引非前导列" class="headerlink" title="8.where条件仅包含复合索引非前导列"></a>8.where条件仅包含复合索引非前导列</h3><p>如：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> key_part2<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part3<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> key_part1 <span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part2<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part3<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="9-隐式类型转换造成不使用索引"><a href="#9-隐式类型转换造成不使用索引" class="headerlink" title="9.隐式类型转换造成不使用索引"></a>9.隐式类型转换造成不使用索引</h3><p>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> col_varchar<span class="operator">=</span><span class="number">123</span>; </span><br></pre></td></tr></table></figure></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>你对MySQL的慢查询优化有了解吗 </p><blockquote><p><strong>标准回答</strong></p><p>​    慢查询优化的前提是定位到响应慢的SQL，这可以通过启用慢查询日志来实现。默认情况下，MySQL并不启用慢查询日志，我们需要手动开启这个参数。通过日志定位到慢查询的SQL之后，我们可以使用EXPLAIN语句来分析这个SQL，进而发现问题所在。导致慢查询的原因有很多，下面列举几种常见的原因，以及对应的解决方案：</p><ol><li><p>向数据库请求了多余的数据：</p><p>很多时候，我们的SQL返回的结果会超出我们的需要，例如实际上它返回了更多的行，而我们只要其中的一部分。又或者我们要求返回所有的列，实际上却只有其中少数的列。对于这类问题，我们可以通过LIMIT控制返回的行数，尽量不用<code>SELECT *</code>避免查询到过多的列。</p></li><li><p>SQL复杂导致无法利用缓存：</p><p>处于业务的需要，我们经常会写出比较复杂的SQL，这自然包括复杂的关联查询。由于复杂SQL返回的结果涉及多张表、多个条件、甚至各种函数，这样的SQL每次返回的结果势必不同，所以很难利用到数据库的缓存。如果我们将复杂SQL进行拆分，变成若干简单的SQL，那么其中有些SQL由于条件不变，就可以利用到数据库的缓存了，从而让查询效率得以提升。</p></li><li><p>没有选择正确的索引：</p><p>我们都知道，创建索引是提高查询效率的一个常用手段，事实上我们也经常会这样做。但是，很多时候我们创建了索引，通过EXPLAIN查看会发现并没有走这个索引，最终导致SQL执行变慢。所以，不是把索引创建出来就算完成任务，还要分析索引的选择性，根据业务条件不断的优化索引，从而增加索引的命中率。</p><p><strong>加分回答</strong></p><p>​    除上述优化的方向之外，SQL中还有很多地方都有优化的空间，例如COUNT()、关联查询、子查询、GROUP BY、LIMIT、UNION等。总体来说，不同的情况要区别对待，但所有优化的背后是基于慢查询日志的定位。另外，为了能够发现问题的本质，还需要对MySQL执行查询的过程有所了解：</p><ol><li>客户端发送一条查询SQL给服务器。 </li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。 </li><li>服务器进行SQL解析和预处理，再由优化器生成对应的执行计划。 </li><li>服务器根据优化器生成的执行计划，调用存储引擎的API来执行查询。 </li><li>将结果返回给客户端。 </li></ol><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p>​    B+树索引是基于B+树构建出来的有序结构，只有利用上它的有序性才能提高查询的效率。若不满足有序性这个前提，则在这个索引中的查询是离散的，其效率反而更低。查询优化器对索引的选择性，被称为最左前缀原则。</p><p>​    假设有如下一张表：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (</span><br><span class="line">  a <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  b <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  c <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  KEY idx_union(a,b,c)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB;</span><br></pre></td></tr></table></figure><p>​    假设idx_union的叶子节点数据如下：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>), (<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>), (<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>), (<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>), (<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>), (<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>​    该索引的选择性示例如下：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 匹配左前缀</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 匹配列前缀</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;x%&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;%x&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b <span class="keyword">like</span> <span class="string">&#x27;x%&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 全值匹配</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> c<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="comment">-- 匹配范围值</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 全值匹配 + 范围匹配</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> c <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;慢查询是什么&quot;&gt;&lt;a href=&quot;#慢查询是什么&quot; class=&quot;headerlink&quot; title=&quot;慢查询是什么&quot;&gt;&lt;/a&gt;慢查询是什么&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL的慢查询，全名是&lt;strong&gt;慢查询日志&lt;/strong&gt;，是MySQ</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL面试</title>
    <link href="https://gwtt.github.io/2022/09/05/SQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95/"/>
    <id>https://gwtt.github.io/2022/09/05/SQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95/</id>
    <published>2022-09-05T10:43:55.628Z</published>
    <updated>2022-09-05T10:49:52.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL的执行顺序"><a href="#1-SQL的执行顺序" class="headerlink" title="1.SQL的执行顺序"></a>1.SQL的执行顺序</h2><blockquote><p> from&gt;join&gt;where&gt;group by&gt;聚合函数&gt;having&gt;select&gt;order by&gt;limit </p><h3 id="1、最先执行from-table；"><a href="#1、最先执行from-table；" class="headerlink" title="1、最先执行from table；"></a>1、最先执行from table；</h3><p> 需要先确定从哪个表中取<a href>数据</a>，所以最先执行from table。 </p><h3 id="2、join连接"><a href="#2、join连接" class="headerlink" title="2、join连接"></a>2、join连接</h3><p> 用于把来自两个或多个表的行结合起来，简单补充一下连接的类型 </p><ul><li> 自然连接（natural join） </li><li> 内连接（inner join）：内连接查询能将左表和右表中能关联起来的<a href>数据</a>连接后返回，返回的结果就是两个表中所有相匹配的<a href>数据</a>。 </li><li> 外连接（outer join）：外连接分为左外连接（LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行）、右外连接（RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行）、还有一个FULL JOIN(全连接)，不过MYSQL不支持全连接 </li><li> 交叉连接（cross join）即笛卡尔连接 </li></ul><h3 id="3、where语句；"><a href="#3、where语句；" class="headerlink" title="3、where语句；"></a>3、where语句；</h3><p> where语句是对条件加以限定 </p><h3 id="4、分组语句【group-by……-having】；"><a href="#4、分组语句【group-by……-having】；" class="headerlink" title="4、分组语句【group by…… having】；"></a>4、分组语句【group by…… having】；</h3><p> group by是分组语句 </p><p> having是和group by配合使用的，用来作条件限定 </p><h3 id="5、聚合函数；"><a href="#5、聚合函数；" class="headerlink" title="5、聚合函数；"></a>5、聚合函数；</h3><p> 常用的聚合函数有max，min， count，sum，聚合函数的执行在group by之后，having之前 </p><p> 举例：count函数查询分组后，每一组分别有多少条<a href>数据</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="title function_">count</span><span class="params">(*)</span> from user group by gender</span><br></pre></td></tr></table></figure><p> 值得注意的是：<strong>聚合函数的执行在group by之后，having之前</strong> </p><h3 id="6、select语句；"><a href="#6、select语句；" class="headerlink" title="6、select语句；"></a>6、select语句；</h3><p> 对分组聚合完的表挑选出需要查询的<a href>数据</a> </p><h3 id="7、Distinct"><a href="#7、Distinct" class="headerlink" title="7、Distinct"></a>7、Distinct</h3><p> distinct对<a href>数据</a>进行去重 </p><p> 如果sql语句存在聚合函数，例如count、max等，会<strong>先执行聚合函数再去重</strong> </p><h3 id="8、order-by排序语句。"><a href="#8、order-by排序语句。" class="headerlink" title="8、order by排序语句。"></a>8、order by<a href>排序</a>语句。</h3><p> order by<a href>排序</a>语句 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id  升序排序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> 降序排序</span><br></pre></td></tr></table></figure><h3 id="9、limit"><a href="#9、limit" class="headerlink" title="9、limit"></a>9、limit</h3><p> limit用于指定返回的<a href>数据</a>条数 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">2</span></span><br><span class="line">从<span class="keyword">user</span>表中查询前两条数据</span><br><span class="line">该<span class="keyword">sql</span>等同于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">0</span>,<span class="number">2</span></span><br><span class="line">表示从第<span class="number">0</span>条开始取两条数据</span><br></pre></td></tr></table></figure><p> limit常配合order by使用 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">3</span></span><br><span class="line">根据id排序，选出id排序前三的数据</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <strong>from&gt;join&gt;where&gt;group by&gt;聚合函数&gt;having&gt;select&gt;order by&gt;limit</strong> </p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">distinct</span> user.name </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">join</span> vip <span class="keyword">on</span> user.id<span class="operator">=</span>vip.id </span><br><span class="line"><span class="keyword">where</span> user.id<span class="operator">&gt;</span><span class="number">10</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user.mobile </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> user.id</span><br><span class="line">limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol><li> from user </li><li> join vip on user.id=vip.id ，join是表示要关联的表，on是连接的条件 </li><li> where user.id&gt;10  </li><li> group by user.mobile 根据user.mobile分组 </li><li> 然后先执行count(*)在执行having，查询分组之后数量大于2的分组<a href>数据</a> </li><li> select 对分组聚合完的表挑选出需要查询的<a href>数据</a> </li><li> distinct查询出来的<a href>数据</a>去重 </li><li> order by user.id 对去重后的<a href>数据</a><a href>排序</a> </li><li> limit 3对<a href>排序</a>后的<a href>数据</a>选出前面3条</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-SQL的执行顺序&quot;&gt;&lt;a href=&quot;#1-SQL的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;1.SQL的执行顺序&quot;&gt;&lt;/a&gt;1.SQL的执行顺序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; from&amp;gt;join&amp;gt;where&amp;gt</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux防火墙</title>
    <link href="https://gwtt.github.io/2022/09/05/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E5%90%AF/"/>
    <id>https://gwtt.github.io/2022/09/05/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E5%90%AF/</id>
    <published>2022-09-05T10:32:23.000Z</published>
    <updated>2022-09-05T10:35:55.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-防火墙开启指定端口"><a href="#Linux-防火墙开启指定端口" class="headerlink" title="Linux 防火墙开启指定端口"></a>Linux 防火墙开启指定端口</h3><p>通常情况下，CentOS 系统部署完成后，关闭并禁用防火墙。但有些特殊情况需要保持防火墙的启用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启用防火墙</span></span><br><span class="line">systemctl enable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看已经开放的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启指定端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=[端口号]/[协议] --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line">--zone=&lt;zone&gt; # 指定 zone</span><br><span class="line">--add-port=&lt;portid&gt;]/&lt;protocol&gt; # 端口id / 协议</span><br><span class="line">--permanent # 永久开启，不添加则重启失效</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭指定端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public –remove-port=[端口号]/[协议] --permanent</span><br><span class="line">firewall-cmd --zone=public –remove-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新加载防火墙</span></span><br><span class="line">systemctl reload firewalld</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux-防火墙开启指定端口&quot;&gt;&lt;a href=&quot;#Linux-防火墙开启指定端口&quot; class=&quot;headerlink&quot; title=&quot;Linux 防火墙开启指定端口&quot;&gt;&lt;/a&gt;Linux 防火墙开启指定端口&lt;/h3&gt;&lt;p&gt;通常情况下，CentOS 系统部署完</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="运维" scheme="https://gwtt.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Mysql代码例子</title>
    <link href="https://gwtt.github.io/2022/09/05/Mysql%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90/"/>
    <id>https://gwtt.github.io/2022/09/05/Mysql%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90/</id>
    <published>2022-09-05T10:21:18.000Z</published>
    <updated>2022-09-05T10:29:11.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立一个用户允许远程连接，并赋予对应库的权限"><a href="#建立一个用户允许远程连接，并赋予对应库的权限" class="headerlink" title="建立一个用户允许远程连接，并赋予对应库的权限"></a>建立一个用户允许远程连接，并赋予对应库的权限</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p;#用密码登录mysql数据库</span><br><span class="line">use mysql;#使用对应的数据库</span><br><span class="line">select host,user,password from user;#查看数据库所有用户和密码</span><br><span class="line"></span><br><span class="line">修改host：update user set host = &#x27;%&#x27; where user = &#x27;用户名&#x27;;</span><br><span class="line">刷新数据：flush privileges;</span><br><span class="line">#或者</span><br><span class="line">添加用户：grant all privileges on *.* to 用户名@&#x27;%&#x27; identified by &quot;用户密码&quot;;</span><br><span class="line">刷新数据：flush privileges;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建立一个用户允许远程连接，并赋予对应库的权限&quot;&gt;&lt;a href=&quot;#建立一个用户允许远程连接，并赋予对应库的权限&quot; class=&quot;headerlink&quot; title=&quot;建立一个用户允许远程连接，并赋予对应库的权限&quot;&gt;&lt;/a&gt;建立一个用户允许远程连接，并赋予对应库的</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>gitlab自动部署</title>
    <link href="https://gwtt.github.io/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://gwtt.github.io/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2022-09-03T02:29:18.000Z</published>
    <updated>2022-09-05T05:08:22.295Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于GItlab CI/CD的自动部署方案</p><h3 id="GitLabCI-CD工作原理"><a href="#GitLabCI-CD工作原理" class="headerlink" title="GitLabCI/CD工作原理"></a>GitLabCI/CD工作原理</h3><blockquote><ul><li>将代码托管到Git存储库</li><li>在项目根目录创建ci文件.gitlab-ci.yml,在文件中指定构建、测试和部署脚本</li><li>GitLab将检测到它并使用名为GitLab Runner的工具运行脚本</li><li>脚本被分组为作业，它们共同组成一个管道 </li></ul><p>运行效果:</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904095646489.png" alt="image-20220904095646489"></p></blockquote><h3 id="首先什么我们要知道Gitlab是什么"><a href="#首先什么我们要知道Gitlab是什么" class="headerlink" title="首先什么我们要知道Gitlab是什么"></a>首先什么我们要知道Gitlab是什么</h3><blockquote><p>是一种类似github的服务，组织可以使用它来提供git存储库的内部管理。 它是一个自我托管的Git-repository管理系统，可以保持用户代码的私密性，并且可以轻松地部署代码的更改。</p></blockquote><h3 id="GitLab安装"><a href="#GitLab安装" class="headerlink" title="GitLab安装"></a>GitLab安装</h3><blockquote><ul><li>检查配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The following is the recommended minimum CPU hardware guidance for a handful of example GitLab user base sizes.</span><br><span class="line"></span><br><span class="line">4 cores is the recommended minimum number of cores and supports up to 500 users</span><br><span class="line">8 cores supports up to 1000 users</span><br><span class="line"></span><br><span class="line">The following is the recommended minimum Memory hardware guidance for a handful of example GitLab user base sizes.</span><br><span class="line"></span><br><span class="line">4GB RAM is the required minimum memory size and supports up to 500 users</span><br><span class="line">8GB RAM supports up to 1000 users</span><br><span class="line"></span><br><span class="line">一般来说，两核八GB就够用了</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查询cpu指令</span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line">查询内存指令</span><br><span class="line">cat /proc/meminfo</span><br><span class="line">查询Linux内核版本</span><br><span class="line">cat /proc/version</span><br><span class="line">友情提示：如果是一核两G不用试了</span><br></pre></td></tr></table></figure><ul><li>使用rpm包安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/e17/gitlab-ce-15.3.2-ce.0.el7.x86_64.rpm</span><br><span class="line">rpm -ivh gitlab-ce-15.3.2-ce.0.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">vim /etc/gitlab.rb #编辑站点地址</span><br><span class="line"></span><br><span class="line">gitlab-ctl reconfigure #配置</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">启动</span></span><br><span class="line">gitlab-ctl start</span><br><span class="line">状态</span><br><span class="line">gitlab-ctl status</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">停止</span></span><br><span class="line">gitlab-ctl stop</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">重启</span></span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>另外docker安装和kubernetes安装就不赘述了</p></blockquote><h3 id="GitLab-Runner介绍相关"><a href="#GitLab-Runner介绍相关" class="headerlink" title="GitLab Runner介绍相关"></a>GitLab Runner介绍相关</h3><blockquote><h3 id="GitLab-Runner简介"><a href="#GitLab-Runner简介" class="headerlink" title="GitLab Runner简介:"></a>GitLab Runner简介:</h3><ul><li>GitLab Runner是一个开源项目，用于运行作业并将结果发送GitLab</li><li>与GitLabCI结合使用，GitLabCI是GitLab随附的用于协调作业的开源持续集成服务</li><li>GitLab Runner是用Go编写的，可以在Linux,macOS和Windos操作系统上运行</li><li>容器部署需使用最新Docker版本。</li><li>可以根据配置需要配置任意数量的Runner</li></ul><h3 id="Runner特点"><a href="#Runner特点" class="headerlink" title="Runner特点:"></a>Runner特点:</h3><ul><li><p>作业运行控制：同时执行多个作业</p></li><li><p>作业运行环境:</p><ol><li>在本地、使用Docker容器、使用Docker容器并通过SSH执行作业</li><li>使用Docker容器在不同的云和虚拟化管理程序上自动缩放</li><li>连接到远程SSH服务器</li></ol></li><li><p>自动重新加载配置，无需重启</p></li><li><p>易于安装，可作为Linux,macOS和Windos的服务</p></li></ul><h3 id="GitLab-Runner类型与状态"><a href="#GitLab-Runner类型与状态" class="headerlink" title="GitLab Runner类型与状态"></a>GitLab Runner类型与状态</h3><ul><li>类型:<ul><li>shared 共享类型,运行整个平台项目的作业</li><li>group项目组类型，运行特定group下所有项目的作业</li><li>specific项目类型，运行指定的项目作业</li></ul></li><li>状态<ul><li>locked：锁定状态，无法运行项目作业</li><li>paused：暂停状态，暂时不会接受新的作业</li></ul></li></ul><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220903215422460.png" alt="image-20220903215422460"></p></blockquote><h3 id="GitLab-Runner安装相关"><a href="#GitLab-Runner安装相关" class="headerlink" title="GitLab Runner安装相关"></a>GitLab Runner安装相关</h3><blockquote><p>包管理工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Add the official GitLab repository 添加官方仓库</span><br><span class="line">curl -L &quot;https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh&quot; | sudo bash</span><br><span class="line"></span><br><span class="line">Install the latest version of GitLab Runner, or skip to the next step to install a specific version 安装最新版本或者下一步</span><br><span class="line">sudo yum install gitlab-runner</span><br><span class="line"></span><br><span class="line">To install a specific version of GitLab Runner:安装指定版本</span><br><span class="line">yum list gitlab-runner --showduplicates | sort -r</span><br><span class="line">sudo yum install gitlab-runner-10.0.0-1</span><br><span class="line"></span><br><span class="line">更新runner</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install gitlab-runner</span><br></pre></td></tr></table></figure></blockquote><h3 id="GitLab-Runner注册"><a href="#GitLab-Runner注册" class="headerlink" title="GitLab Runner注册"></a>GitLab Runner注册</h3><blockquote><p>获取shared类型runnertoken</p><p>进入系统设置-&gt;Runners</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904160532695.png" alt="image-20220904160532695"></p><p>同理也可以找到对应得group CI/CD Runner和单项目得CI/CD Runner</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/gitlab-runner register --locked=&quot;false&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向GitLab-CI注册一个Runner需要两样东西：</span></span><br><span class="line">GitLab-CI的url和注册token。 其中，token是为了确定你这个Runner是所有工程都能够使用的Shared Runner还是具体某一个工程才能使用的Specific Runner。 如果要注册Shared Runner，你需要到管理界面的Runners页面里面去找注册token。如下图所示</span><br></pre></td></tr></table></figure><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220903215549856.png" alt="image-20220903215549856"></p><p>GitLab CI/CD支持的执行器有很多种，最常用的是Docker， shell，Kubernets三种。</p><p>Shell 是最易于配置的执行器。构建中所需的依赖得你手工装在 Runner 所在机器上。</p><p>更好的方式是使用 Docker，它让你拥有干净的构建环境，以及简易的依赖管理——所有的编译项目所需的依赖都可以放进 Docker 镜像中。Docker 执行器很容易就能创建带有依赖服务的编译环境，比如 MySQL。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v v/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor &quot;docker&quot; \</span><br><span class="line">  --docker-image alpine:latest \</span><br><span class="line">  --url &quot;url&quot; \# 网页端域名 </span><br><span class="line">  --registration-token &quot;token&quot; \# gitlab提供的token</span><br><span class="line">  --description &quot;first-register-runner&quot; \</span><br><span class="line">  --tag-list &quot;test-cicd1,dockercicd1&quot; \</span><br><span class="line">  --run-untagged=&quot;true&quot; \</span><br><span class="line">  --locked=&quot;false&quot; \</span><br><span class="line">  --access-level=&quot;not_protected&quot;</span><br></pre></td></tr></table></figure></blockquote><h3 id="gitlab-ci-yml文件"><a href="#gitlab-ci-yml文件" class="headerlink" title=".gitlab-ci.yml文件"></a>.gitlab-ci.yml文件</h3><blockquote><p>如何检查你的yml文件是否符合,可以用CI Lint</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904164146671-16623544839293.png" alt="image-20220904164146671"></p></blockquote><h2 id="Pipeline语法"><a href="#Pipeline语法" class="headerlink" title="Pipeline语法"></a>Pipeline语法</h2><h3 id="1-Job"><a href="#1-Job" class="headerlink" title="1.Job"></a>1.Job</h3><blockquote><p>在.gitlab-ci.yml的文件中，可以定义一个或多个作业（job）。每个作业必须具有唯一的名称（不能使用关键字），每个作业是独立执行。作业定义了在约束条件下进行相关操作，每一个作业至少要包含至少一个script</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;execute-script-for-job1&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-script"><a href="#2-script" class="headerlink" title="2.script"></a>2.script</h3><blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure><p>有时，script命令将需要用单引号或双引号引起来。例如，包含冒号命令(:)需要加引号，以便被包裹的YAML解析器知道来解释整个事情作为一个字符串，而不是一个”键:值”对.使用特殊字符时要小心<code>:</code> ,<code>&#123;</code>,<code>&#125;</code>,<code>[</code>,<code>]</code>, <code>,</code> 等等</p></blockquote><h3 id="3-before-script"><a href="#3-before-script" class="headerlink" title="3.before_script"></a>3.before_script</h3><blockquote><p>跟script差不多，只不过在作业之前运行，如果失败则整个任务失败，作业失败不会影响after_sciprt</p></blockquote><h3 id="4-stages"><a href="#4-stages" class="headerlink" title="4.stages"></a>4.stages</h3><blockquote><p>用于定义作业可以使用的阶段，并且是全局定义的。同一阶段的作业并行运行，不同阶段按顺序执行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">codescan</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="5-pre-amp-post"><a href="#5-pre-amp-post" class="headerlink" title="5. .pre&amp;.post"></a>5. .pre&amp;.post</h3><blockquote><p>.pre始终是整个管道的第一个运行阶段, .post始终是整个管道的最后一个运行阶段。用户定义的阶段都在两者之间运行。.pre和.post的顺序无法更改。如果管道仅包含.pre或.post阶段的作业，则不会创建管道</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codescan:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">.pre</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;codescan&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="6-tags-指定runner"><a href="#6-tags-指定runner" class="headerlink" title="6.tags(指定runner)"></a>6.tags(指定runner)</h3><blockquote><p>用于从允许运行该项目的所有Runner列表中选择特定的Runner，在Runner注册期间，您可以指定Runner标签</p></blockquote><h3 id="7-allow-failure允许失败"><a href="#7-allow-failure允许失败" class="headerlink" title="7.allow_failure允许失败"></a>7.allow_failure允许失败</h3><blockquote><p>allow_failure允许作业失败，默认值为false。启用后，如果作业失败，将会在用户界面中显示橙色警告。但是，管道的逻辑流程将认为作业成功/通过，并且不会阻塞。假设所有其他作业均成功，则该作业的阶段及其管道将显示相同的橙色警告。但是，关联的提交将被标记”通过”,而不会发出警告。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">execute</span></span><br><span class="line">  <span class="attr">allow_failure:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">MAVEN_CLI_OPTS:</span> <span class="string">&quot;--batch-mode --errors --fail-at-end --show-version -s .m2/settings.xml&quot;</span></span><br><span class="line">  <span class="attr">MAVEN_OPTS:</span> <span class="string">&quot;-Dmaven.repo.local=.m2/repository&quot;</span></span><br><span class="line">  <span class="attr">PACKAGE_NAME:</span> <span class="string">&quot;certificate.jar&quot;</span></span><br><span class="line">  <span class="attr">PACKAGE_BACK_NAME:</span> <span class="string">&quot;certificateBack.jar&quot;</span></span><br><span class="line">  <span class="attr">PROD_ENV_1:</span> <span class="string">&quot;10.166.41.101&quot;</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">maven:3.8.1-openjdk-11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">$&#123;CI_COMMIT_REF_SLUG&#125;</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.m2/repository</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sacc/target/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;cd sacc&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mvn $MAVEN_CLI_OPTS package -Dmaven.test.skip=true -Pprod&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al target&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-prod:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh/&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;echo &quot;$SSH_PRIVATE_KEY&quot; &gt;&gt; ./id_rsa &amp;&amp; chmod 600 ./id_rsa&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;echo -e &quot;Host *\n\tStrictHostKeyChecking no\n\n&quot; &gt; ~/.ssh/config&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al sacc/target&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;yum install net-tools&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;/bin/cp -rf /opt/webapps/certificate/$PACKAGE_NAME \&quot;/opt/webapps/certificate/$PACKAGE_NAME.$(date +\&quot;%y%m%d\&quot;)\&quot;&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;scp -i ./id_rsa -r sacc/target/$PACKAGE_NAME root@$PROD_ENV_1:/opt/webapps/certificate/$PACKAGE_NAME&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;cp /dev/null /opt/webapps/certificate/nohup.out&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;ssh -i ./id_rsa root@$PROD_ENV_1 \&quot;pkill -f certificate.jar\&quot;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;nohup java -jar /opt/webapps/certificate/certificate.jar &amp;&gt; /opt/webapps/certificate/nohup.out &amp;&quot;&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是关于GItlab CI/CD的自动部署方案&lt;/p&gt;
&lt;h3 id=&quot;GitLabCI-CD工作原理&quot;&gt;&lt;a href=&quot;#GitLabCI-CD工作原理&quot; class=&quot;headerlink&quot; title=&quot;GitLabCI/CD工作原理&quot;&gt;&lt;/a&gt;GitLabCI/</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="运维" scheme="https://gwtt.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型</title>
    <link href="https://gwtt.github.io/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gwtt.github.io/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-09-01T10:54:21.938Z</published>
    <updated>2022-09-01T11:45:02.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的三大IO模型"><a href="#Java中的三大IO模型" class="headerlink" title="Java中的三大IO模型"></a>Java中的三大IO模型</h2><p>在JDK1.4之前，基于Java所有的socket通信都采用了同步阻塞模型（BIO），这种模型性能低下，当时大型的服务均采用C或C++开发，因为它们可以直接使用操作系统提供的异步IO或者AIO，使得性能得到大幅提升。</p><p>2002年，JDK1.4发布，新增了java.nio包，提供了许多异步IO开发的API和类库。新增的NIO，极大的促进了基于Java的异步非阻塞的发展和应用。</p><p>2011年，JDK7发布，将原有的NIO进行了升级，称为NIO2.0，其中也对AIO进行了支持。</p><h3 id="BIO模型"><a href="#BIO模型" class="headerlink" title="BIO模型"></a>BIO模型</h3><blockquote><p>java中的BIO是blocking I/O的简称，它是同步阻塞型IO，其相关的类和接口在java.io下。</p><p>BIO模型简单来讲，就是服务端为每一个请求都分配一个线程进行处理，如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/e8e029a04700e7f4523e63108c6c771992b4b1be.png@942w_497h_progressive.webp" alt="img"></p><p>示例代码：</p><p>public class BIOServer {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等待客户端连接。。。。&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">//阻塞</span></span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); <span class="comment">//阻塞</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                    <span class="keyword">if</span>(length == -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, length, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}<br>这种模式存在的问题：</p><p>客户端的并发数与后端的线程数成1:1的比例，线程的创建、销毁是非常消耗系统资源的，随着并发量增大，服务端性能将显著下降，甚至会发生线程堆栈溢出等错误。</p><p>当连接创建后，如果该线程没有操作时，会进行阻塞操作，这样极大的浪费了服务器资源。</p></blockquote><h3 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h3><blockquote><p>NIO，称之为New IO 或是 non-block IO （非阻塞IO），这两种说法都可以，其实称之为非阻塞IO更恰当一些。</p><p>NIO相关的代码都放在了java.nio包下，其三大核心组件：Buffer（缓冲区）、Channel（通道）、Selector（选择器/多路复用器）</p><p>Buffer</p><p>在NIO中，所有的读写操作都是基于缓冲区完成的，底层是通过数组实现的，常用的缓冲区是ByteBuffer，每一种java基本类型都有对应的缓冲区对象（除了Boolean类型），如：CharBuffer、IntBuffer、LongBuffer等。</p><p>Channel</p><p>在BIO中是基于Stream实现，而在NIO中是基于通道实现，与流不同的是，通道是双向的，既可以读也可以写。</p><p>Selector</p><p>Selector是多路复用器，它会不断的轮询注册在其上的Channel，如果某个Channel上发生读或写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey获取就绪Channel的集合，进行IO的读写操作。</p><p>基本示意图如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/262bc99c60a8dacc1116aff1585ec53655e1c44b.png@942w_509h_progressive.webp" alt="img"></p><p>可以看出，NIO模型要优于BIO模型，主要是：</p><p>通过多路复用器就可以实现一个线程处理多个通道，避免了多线程之间的上下文切换导致系统开销过大。</p><p>NIO无需为每一个连接开一个线程处理，并且只有通道真正有有事件时，才进行读写操作，这样大大的减少了系统开销。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectorDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Selector <span class="title function_">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取selector对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取通道并且绑定端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6677</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册感兴趣的事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="built_in">this</span>.getSelector();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select(); <span class="comment">//该方法会阻塞，直到至少有一个事件的发生</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                process(selectionKey, selector);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable())&#123; <span class="comment">//新连接请求</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel)key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123; <span class="comment">//读数据</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel)key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;form 客户端 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(), <span class="number">0</span>, byteBuffer.position()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SelectorDemo</span>().listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="AIO模型"><a href="#AIO模型" class="headerlink" title="AIO模型"></a>AIO模型</h3><blockquote><p>在NIO中，Selector多路复用器在做轮询时，如果没有事件发生，也会进行阻塞，如何能把这个阻塞也优化掉呢？那么AIO就在这样的背景下诞生了。</p><p>AIO是asynchronous I/O的简称，是异步IO，该异步IO是需要依赖于操作系统底层的异步IO实现。</p><p>AIO的基本流程是：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p><ul><li><p>kernel的数据准备</p><p>将数据从网络物理设备（网卡）读取到内核缓冲区。</p></li><li><p>kernel的数据复制</p><p>将数据从内核缓冲区拷贝到用户程序空间的缓冲区。</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/583df5514d2c98bf09ae08637144d8e96e47704f.png@731w_681h_progressive.webp" alt="img"></p><p>目前AIO模型存在的不足：</p><ol><li><p>需要完成事件的注册与传递，这里边需要底层操作系统提供大量的支持，去做大量的工作。</p></li><li><p>Windows 系统下通过 IOCP 实现了真正的异步 I/O。但是，就目前的业界形式来说，Windows 系统，很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p></li><li><p>而在 Linux 系统下，异步IO模型在2.6版本才引入，目前并不完善。所以，这也是在 Linux 下，实现高并发网络编程时都是以 NIO 多路复用模型模式为主。</p></li></ol></li></ul></blockquote><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><blockquote><p>Reactor线程模型不是Java专属，也不是Netty专属，它其实是一种并发编程模型，是一种思想，具有指导意义。比如，Netty就是结合了NIO的特点，应用了Reactor线程模型所实现的。</p><p>Reactor模型中定义的三种角色：</p><ul><li>Reactor：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li>Acceptor：处理客户端新连接，并分派请求到处理器链中。</li><li>Handler：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。</li></ul><p>常见的Reactor线程模型有三种，如下：</p><ul><li>Reactor单线程模型</li><li>Reactor多线程模型</li><li>主从Reactor多线程模型</li></ul><h4 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/9d48bbccca4988a42fceda53b7faef999a4593c0.png@942w_381h_progressive.webp" alt="img"></p><p>说明:</p><ul><li>Reactor充当多路复用器角色，监听多路连接的请求，由单线程完成</li><li>Reactor收到客户端发来的请求时，如果是新建连接通过Acceptor完成，其他的请求Handler完成。</li><li>Handler完成业务逻辑的处理，基本的流程是：Read –&gt; 业务处理 –&gt; Send 。</li></ul><p>这种模型优点:</p><ul><li>结构简单，由单线程完成，没有多线程、进程通信等问题</li><li>适合在一些业务逻辑比较简单、对于性能要求不高的应用场景</li></ul><p>缺点：</p><ul><li>由于是单线程操作、不能充分发挥多核CPU的性能</li><li>当Reactor线程负载过重之后、处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重Reactor线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈。</li><li>可靠性差，如果该线程进入死循环或意外终止，就会导致整个通信系统不可用，容易造成单点故障。 </li></ul><h4 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/0a19c9de9af761ed990068f2f48871268bd0cb02.png@942w_576h_progressive.webp" alt="img"></p><p>说明:</p><ul><li>在Reactor多线程模型相比较单线程模型而言，不同点在于，Handler不会处理业务逻辑，只是负责响应用户请求，真正的业务逻辑，在另外的线程中完成。</li><li>这样可以降低Reactor的性能开销，充分利用CPU资源，从而更专注的做事件分发工作了，提升整个应用的吞吐。 </li></ul><p>但是这个模型存在的问题：</p><ul><li><p>多线程数据共享和访问比较复杂。如果子线程完成业务处理后，把结果传递给主线程Reactor进行发送，就会涉及共享数据的互斥和保护机制。</p></li><li><p>Reactor承担所有事件的监听和响应，只在主线程中运行，可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。</p></li></ul><p>为了解决性能问题，产生了第三种主从Reactor多线程模型。</p><h4 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/348b425d88ffbce6873196c1ca299f07320f70ac.png@942w_432h_progressive.webp" alt="img"></p><p>在主从模型中，将Reactor分成2部分：</p><ul><li>MainReactor负责监听server socket，用来处理网络IO连接建立操作，将建立的socketChannel指定注册给SubReactor。</li><li>SubReactor主要完成和建立起来的socket的数据交互和事件业务处理操作。</li></ul><p>该模型的优点：</p><ul><li><p>响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的。</p></li><li><p>可扩展性强，可以方便地通过增加SubReactor实例个数来充分利用CPU资源。</p></li><li><p>可复用性高，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性。</p></li></ul></blockquote><h3 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h3><blockquote><p>Netty模型是基于Reactor模型实现的，对于以上三种模型都有非常好的支持，也非常的灵活，一般情况，在服务端会采用主从架构模型，基本示意图如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/a463c8eb5c2ebd4db875eed66346404d55c741b6.png@942w_369h_progressive.webp" alt="img"></p><p>说明：</p><ul><li><p>在Netty模型中，负责处理新连接事件的是BossGroup，负责处理其他事件的是WorkGroup。Group就是线程池的概念。</p></li><li><p>NioEventLoop表示一个不断循环的执行处理任务的线程，用于监听绑定在其上的读/写事件。</p></li><li><p>通过Pipeline（管道）执行业务逻辑的处理，Pipeline中会有多个ChannelHandler，真正的业务逻辑是在ChannelHandler中完成的。</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java中的三大IO模型&quot;&gt;&lt;a href=&quot;#Java中的三大IO模型&quot; class=&quot;headerlink&quot; title=&quot;Java中的三大IO模型&quot;&gt;&lt;/a&gt;Java中的三大IO模型&lt;/h2&gt;&lt;p&gt;在JDK1.4之前，基于Java所有的socket通信都采用</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Linux" scheme="https://gwtt.github.io/tags/Linux/"/>
    
    <category term="IO" scheme="https://gwtt.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>浅谈AQS</title>
    <link href="https://gwtt.github.io/2022/09/01/%E6%B5%85%E8%B0%88AQS/"/>
    <id>https://gwtt.github.io/2022/09/01/%E6%B5%85%E8%B0%88AQS/</id>
    <published>2022-09-01T09:53:23.000Z</published>
    <updated>2022-09-01T10:43:11.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h3><blockquote><p>AQS:全称是AbstractQuenedSynchronizer（抽象队列同步器）。是除了java自带的synchronized关键字之外的锁机制。</p></blockquote><h3 id="AQS的核心思想是"><a href="#AQS的核心思想是" class="headerlink" title="AQS的核心思想是:"></a><strong>AQS的核心思想</strong>是:</h3><blockquote><p> 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH（Craig，Landin，and Hagersten locks）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p><p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p><p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p><p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong></p></blockquote><p><img src="/2022/09/01/%E6%B5%85%E8%B0%88AQS/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211bGluc2VuNzc=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>如图示，AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line"></span><br><span class="line">setState()</span><br><span class="line"></span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure><p>AQS 定义了两种资源共享方式：<br>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(<span class="type">int</span>)：独占方式。尝试获取资源，成功则返回<span class="literal">true</span>，失败则返回<span class="literal">false</span>。</span><br><span class="line">tryRelease(<span class="type">int</span>)：独占方式。尝试释放资源，成功则返回<span class="literal">true</span>，失败则返回<span class="literal">false</span>。</span><br><span class="line">tryAcquireShared(<span class="type">int</span>)：共享方式。尝试获取资源。负数表示失败；<span class="number">0</span>表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(<span class="type">int</span>)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure><h3 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h3><p>AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; write.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用实现"><a href="#应用实现" class="headerlink" title="应用实现"></a>应用实现</h3><ul><li><p>Lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>通过注释我们知道，acquire方法是一种互斥模式，且忽略中断。该方法至少执行一次tryAcquire(int)方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。函数流程如下：</p><ul><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ul><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>1.判断状态位是否为0,0是可以占用,如果是0的话占用,不是0的话返回false</p><p>2.判断当前线程是否为得到位置的线程,比如如果前一个线程走了,然后又回来有点事情的话,那么返回false</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;AQS的原理&quot;&gt;&lt;a href=&quot;#AQS的原理&quot; class=&quot;headerlink&quot; title=&quot;AQS的原理&quot;&gt;&lt;/a&gt;AQS的原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;AQS:全称是AbstractQuenedSynchronizer（抽象队列同步器</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Juc" scheme="https://gwtt.github.io/tags/Juc/"/>
    
  </entry>
  
  <entry>
    <title>手动实现栈和队列</title>
    <link href="https://gwtt.github.io/2022/09/01/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://gwtt.github.io/2022/09/01/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-09-01T04:55:57.000Z</published>
    <updated>2022-09-01T09:41:55.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-手动实现栈"><a href="#1-手动实现栈" class="headerlink" title="1. 手动实现栈"></a>1. 手动实现栈</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[]stack;<span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;<span class="comment">//当前可以存放数据元素的下标——&gt;栈顶指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用构造函数给定一个初始容量10的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">( )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stack = (T[])<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];<span class="comment">//泛型不能实例化对象，但是可以类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否满了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (stack.length == <span class="built_in">this</span>.top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.top == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//判断栈是否已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="built_in">this</span>.stack = Arrays.copyOf(stack,<span class="number">2</span>*stack.length);<span class="comment">//满了就扩容成原来容量的两倍</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.stack[<span class="built_in">this</span>.top] = value;<span class="comment">//给top位置添加元素</span></span><br><span class="line">        <span class="built_in">this</span>.top++;<span class="comment">//top指针指向下一可用空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈操作，并返回弹出（删除）栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.top-<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.top--;</span><br><span class="line">        <span class="keyword">return</span> ret;<span class="comment">//返回删除的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到栈顶元素，但是不删除</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回栈顶元素，不删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stack[top-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示栈元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top-<span class="number">1</span>; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            System.out.print(stack[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-手动实现队列"><a href="#2-手动实现队列" class="headerlink" title="2.手动实现队列"></a>2.手动实现队列</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">//队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.first == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//尾插法，要判断是否第一次插入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.first == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.first = node;</span><br><span class="line">            <span class="built_in">this</span>.last = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.last.setNext(node);</span><br><span class="line">            <span class="built_in">this</span>.last = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="built_in">this</span>.first.getVal();</span><br><span class="line">        <span class="built_in">this</span>.first = <span class="built_in">this</span>.first.getNext();</span><br><span class="line">        <span class="keyword">return</span> ret;<span class="comment">//返回出队元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到队头元素但是不删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不要移动first</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.first.getVal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.first;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.getVal()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-手动实现栈&quot;&gt;&lt;a href=&quot;#1-手动实现栈&quot; class=&quot;headerlink&quot; title=&quot;1. 手动实现栈&quot;&gt;&lt;/a&gt;1. 手动实现栈&lt;/h3&gt;&lt;blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="java基础" scheme="https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的MVCC</title>
    <link href="https://gwtt.github.io/2022/08/30/Mysql%E7%9A%84MVCC/"/>
    <id>https://gwtt.github.io/2022/08/30/Mysql%E7%9A%84MVCC/</id>
    <published>2022-08-30T07:06:22.000Z</published>
    <updated>2022-08-30T09:32:54.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><blockquote><p><strong><code>MVCC</code><strong>，全称 <code>Multi-Version Concurrency Control</code> ，即多版本并发控制。</strong>mvcc</strong>，它是一种并发控制方法，一般在数据库管理系统中，实现数据库的并发访问，在编程语言中实现事务内存。</p><p><strong>总结：</strong>主要为了提升并发性能</p></blockquote><h3 id="为什么需要MVCC"><a href="#为什么需要MVCC" class="headerlink" title="为什么需要MVCC"></a>为什么需要MVCC</h3><blockquote><p><strong>数据库原生的锁</strong><br>        最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。</p><p><strong>读写锁的出现</strong><br>        读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够</p><p><strong>mvcc概念出现</strong><br>        能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能</p></blockquote><h3 id="MVCC适用于的事务隔离级别"><a href="#MVCC适用于的事务隔离级别" class="headerlink" title="MVCC适用于的事务隔离级别"></a>MVCC适用于的事务隔离级别</h3><blockquote><p>MVCC只在 READ COMMITTED (读取已提交) 和 REPEATABLE READ (可重复读) 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED (读取未提交) 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE (可串行化) 则会对所有读取的行都加锁。</p></blockquote><h3 id="MVCC实现原理✔"><a href="#MVCC实现原理✔" class="headerlink" title="MVCC实现原理✔"></a>MVCC实现原理✔</h3><blockquote><p><strong>MVCC</strong>的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <strong><code>3个隐式字段</code><strong>，</strong><code>undo日志</code></strong> ，**<code>Read View</code>** 来实现的。</p><h3 id="3个隐式字段"><a href="#3个隐式字段" class="headerlink" title="3个隐式字段"></a>3个隐式字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`DB_TRX_ID`, `DB_ROLL_PTR`, `DB_ROW_ID</span><br></pre></td></tr></table></figure><table><thead><tr><th>列名</th><th>长度（字节）</th><th>作用</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>6</td><td>插入或更新行的最后一个事务的事务标识符。（删除视为更新，将其标记为已删除）</td></tr><tr><td>DB_ROLL_PTR</td><td>7</td><td>写入回滚段的撤销日志记录（若行已更新，则撤销日志记录包含在更新之前重建行内容所需的信息）</td></tr><tr><td>DB_ROW_ID</td><td>6</td><td>行标识（隐藏单调自增id）</td></tr></tbody></table><p>比如:</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><p> <code>DB_ROW_ID</code> 是数据库默认为该行记录生成的唯一隐式主键，<code>DB_TRX_ID</code> 是当前操作该记录的事务 ID ,而 <code>DB_ROLL_PTR</code> 是一个回滚指针，用于配合 undo日志，指向上一个旧版本</p><p> <strong>事务A：</strong>对数据进行了修改（将name中的张三改为李四）</p><ul><li>第一步：用<strong>排他锁</strong>锁定这一条记录</li></ul><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><ul><li> 第二步：UNDOLOG会记录日志，作为旧记录，既在 <code>undo log</code> 中有当前行的拷贝副本</li></ul><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><ul><li> 第三步：将回滚指针的值copy到UNDOLOG中</li></ul><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR(这就是存储回滚指针的值)</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>ox29349384</td></tr></tbody></table><ul><li>第四步：修改当前的name值并且修改隐藏字段的事务 ID 为当前<code>事务 1</code>的 ID, 我们默认从 <code>1</code> 开始，之后递增，回滚指针指向拷贝到 <code>undo log</code> 的副本记录，既表示我的上一个版本就是它</li></ul><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR(这就是存储回滚指针的值)</th></tr></thead><tbody><tr><td>1</td><td>李四</td><td>18</td><td>1</td><td>1</td><td>ox29349384</td></tr></tbody></table><p><strong>事务B：</strong>事务A修改但未提交，同时对事务B也对该行数据做了修改</p><p>下表就是事务B做出的改变（改变的是年龄）</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td><strong>30</strong></td><td>1</td><td>2</td><td>ox23874982</td></tr></tbody></table><p>  上表的ox23874982指的地址是下表的地址</p><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>1</td><td>ox29349384</td></tr></tbody></table><p>上表的ox29349384指的地址是下表的地址</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><p>所以总结:</p><p>如果有当前事务，最早事务，最晚事务</p><p>最早事务ID&lt;当前事务ID&lt;最晚事务ID</p><ul><li>事务的排他锁形式修改数据</li><li>修改之前先把数据放到undolog，通过回滚指针关联</li><li>失败了从undolog回滚</li></ul></blockquote><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><blockquote><p>insert undo log<br>代表事务在 insert 新记录时产生的 undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>update undo log<br>事务在进行 update 或 delete 时产生的 undo log ; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除<br>在不考虑redo log 的情况下利用undo log工作的简化过程为：</p><table><thead><tr><th>序号</th><th>动作</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td></tr><tr><td>2</td><td>记录数据行数据快照到undolog</td></tr><tr><td>3</td><td>更新数据</td></tr><tr><td>4</td><td>将undolog写到磁盘</td></tr><tr><td>5</td><td>将数据写到磁盘</td></tr><tr><td>6</td><td>提交事务</td></tr></tbody></table><p> 1）为了保证数据的持久性数据要在事务提交之前持久化</p><p> 2）undo log的持久化必须在在数据持久化之前，这样才能保证系统崩溃时，可以用undo log来回滚事务</p></blockquote><h3 id="执行流程如下："><a href="#执行流程如下：" class="headerlink" title="执行流程如下："></a><strong>执行流程如下：</strong></h3><blockquote><p>*<em>一、比如一个有个事务插入 persion 表插入了一条新记录，记录如下，<code>name</code> 为 小明 , <code>age</code> 为 10 岁，*</em><code>隐式主键</code>*<em>是 1，*</em><code>事务 ID</code>*<em>和*</em><code>回滚指针</code>*<em>，我们假设为 NULL</em>*</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830171156856.png" alt="image-20220830171156856"></p><p><strong>二、 现在来了一个事务 1对该记录的 name 做出了修改，改为 小红</strong></p><ul><li>在<code>事务 1</code>修改该行(记录)数据时，数据库会先对该行加<code>排他锁</code></li></ul><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830171325637.png" alt="image-20220830171325637"></p><ul><li>然后把该行数据拷贝到 <code>undo log</code> 中，作为旧记录，既在 <code>undo log</code> 中有当前行的拷贝副本</li></ul><p>Undo日志</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172747995.png" alt="image-20220830172747995"></p><ul><li><p>拷贝完毕后，修改该行<code>name</code>为小红，并且修改隐藏字段的事务 ID 为当前<code>事务 1</code>的 ID, 我们默认从 <code>1</code> 开始，之后递增，回滚指针指向拷贝到 <code>undo log</code> 的副本记录，既表示我的上一个版本就是它</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172826227.png" alt="image-20220830172826227"></p><p>上个表的回滚指针地址指的是下个表</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172852127.png" alt="image-20220830172852127"></p></li><li><p>事务提交后，释放锁</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是MVCC&quot;&gt;&lt;a href=&quot;#什么是MVCC&quot; class=&quot;headerlink&quot; title=&quot;什么是MVCC&quot;&gt;&lt;/a&gt;什么是MVCC&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;MVCC&lt;/code&gt;&lt;strong&gt;，全称 </summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>聚集索引和非聚集索引</title>
    <link href="https://gwtt.github.io/2022/08/29/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    <id>https://gwtt.github.io/2022/08/29/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/</id>
    <published>2022-08-29T08:51:49.429Z</published>
    <updated>2022-08-29T09:10:55.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><h3 id="什么是聚集索引"><a href="#什么是聚集索引" class="headerlink" title="什么是聚集索引"></a>什么是聚集索引</h3><blockquote><p>聚集索引是将<strong>索引列字段</strong>和<strong>行记录数据</strong>维护在了一起,它的叶子节点存储的是 <strong>索引列字段 + 完整的行记录数据</strong>,通过聚集索引能直接获取到整行数据</p><p>Innodb 的主键索引就是基于聚集索引实现的</p><p>通俗点讲:利用聚集索引可以<strong>直接</strong>获取对应的元素数据</p><p><img src="https://img2022.cnblogs.com/blog/1636535/202204/1636535-20220427020132699-1363305095.png" alt="img"></p></blockquote><h3 id="什么是非聚集索引"><a href="#什么是非聚集索引" class="headerlink" title="什么是非聚集索引"></a>什么是非聚集索引</h3><blockquote><p>非聚集索引是相比较于聚集索引来说,它是把<strong>索引和行数据分开维护</strong>,叶子节点并没有包含完整的数据记录(叶子节点的数据区存储的是聚集索引的 id 或 数据的磁盘地址)Mysql 非聚集索引底层的数据结构也是 b+ 树,例如 Myisam 的索引、Innodb 的辅助索引</p><p><img src="https://img2022.cnblogs.com/blog/1636535/202204/1636535-20220428224329312-1207567303.png" alt="img"></p><p>比如在搜索年龄为41的数据时，会找到13，然后再去找利用聚集索引找主键为13的数据</p></blockquote><h3 id="回表（尽量去减少回表的产生）"><a href="#回表（尽量去减少回表的产生）" class="headerlink" title="回表（尽量去减少回表的产生）"></a>回表（尽量去减少回表的产生）</h3><blockquote><p>当通过非聚集索引来查询数据时,存储引擎会根据索引字段定位到最底层的叶子节点,并通过叶子节点获得指向主键索引的主键 id,然后通过主键 id 去主键索引(聚集索引)上找到一个完整的行记录.这个过程被称为 <strong>回表</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;聚集索引和非聚集索引&quot;&gt;&lt;a href=&quot;#聚集索引和非聚集索引&quot; class=&quot;headerlink&quot; title=&quot;聚集索引和非聚集索引&quot;&gt;&lt;/a&gt;聚集索引和非聚集索引&lt;/h2&gt;&lt;h3 id=&quot;什么是聚集索引&quot;&gt;&lt;a href=&quot;#什么是聚集索引&quot; class</summary>
      
    
    
    
    <category term="数据库" scheme="https://gwtt.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
    <category term="索引" scheme="https://gwtt.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>jdk动态代理和cglib动态代理</title>
    <link href="https://gwtt.github.io/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://gwtt.github.io/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2022-08-28T08:32:02.000Z</published>
    <updated>2022-08-28T11:54:16.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两者有何区别"><a href="#两者有何区别" class="headerlink" title="两者有何区别"></a>两者有何区别</h2><p>1、<strong>Jdk动态代理</strong>：利用拦截器（必须实现InvocationHandler接口）加上<strong>反射机制</strong>生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理</p><blockquote><p>JDK动态代理主要是通过，反射包中的Porxy类和InvokationHandler接口。它们结合在一起后可以创建动态代理类。Porxy类基于传递的参数创建动态代理类。InvokationHandler则用于激发动态代理类的方法。这个过程是在程序执行过程中动态生成与处理的，所以叫动态代理。</p></blockquote><p>2、 <strong>Cglib动态代理</strong>：利用ASM框架，对代理对象类生成的class文件加载进来，通过<strong>修改其字节码生成子类来进行代理</strong></p><p><strong>所以：</strong></p><ul><li><strong>如果想要实现JDK动态代理那么代理类必须实现接口，否则不能使用;</strong></li><li><strong>如果想要使用CGlib动态代理，那么代理类不能使用final修饰类和方法；</strong></li></ul><p>还有： 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理。</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="JDk动态代理例子"><a href="#JDk动态代理例子" class="headerlink" title="JDk动态代理例子"></a>JDk动态代理例子</h2><blockquote><p><strong>UserService接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新用户信息&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserProxy代理类，实现InvocationHandler接口重写invoke方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;记录日志&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserProxy</span> <span class="variable">userProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProxy</span>(impl);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(impl.getClass().getClassLoader(),impl.getClass().getInterfaces(),userProxy);</span><br><span class="line">        userService.addUser();</span><br><span class="line">        userService.updateUser(<span class="string">&quot;：我是滚韬&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20220828185237100.png" alt="image-20220828185237100"></p></blockquote><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><blockquote><p>首先要加入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(<span class="type">boolean</span> throwException)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello everyone!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(throwException)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;test exception&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现MethodInterceptor接口"><a href="#实现MethodInterceptor接口" class="headerlink" title="实现MethodInterceptor接口"></a>实现MethodInterceptor接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">     <span class="comment">//要代理的原始对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = target;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(<span class="built_in">this</span>.obj.getClass());<span class="comment">// 设置代理目标</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);<span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setClassLoader(target.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 前置通知</span></span><br><span class="line">            before();</span><br><span class="line">            result = proxy.invokeSuper(obj, args);</span><br><span class="line">            <span class="comment">// 后置通知</span></span><br><span class="line">            after();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            exception();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            beforeReturning();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after method invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exception</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method invoke exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">beforeReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before returning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) cglibProxy.createProxy(hello);</span><br><span class="line">        String result=proxy.sayHello(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="两个动态代理的使用场景是哪里"><a href="#两个动态代理的使用场景是哪里" class="headerlink" title="两个动态代理的使用场景是哪里"></a>两个动态代理的使用场景是哪里</h2><blockquote><p>我们主要是在Spring Aop项目中去使用它们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">     Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">     <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">              <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果</span></span><br><span class="line">     <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="number">1</span>、如果目标对象实现了接口，默认情况下会采用JDK的动态代理</span><br><span class="line">&gt;<span class="number">2</span>、如果目标对象实现了接口，也可以强制使用CGLIB</span><br><span class="line">&gt;<span class="number">3</span>、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</span><br></pre></td></tr></table></figure><h4 id="如果需要强制使用CGLIB来实现AOP，需要配置spring-aop-proxy-target-class-true或-EnableAspectJAutoProxy-proxyTargetClass-true"><a href="#如果需要强制使用CGLIB来实现AOP，需要配置spring-aop-proxy-target-class-true或-EnableAspectJAutoProxy-proxyTargetClass-true" class="headerlink" title="如果需要强制使用CGLIB来实现AOP，需要配置spring.aop.proxy-target-class=true或**@EnableAspectJAutoProxy(proxyTargetClass = true**"></a>如果需要强制使用CGLIB来实现AOP，需要配置<strong>spring.aop.proxy-target-class=true</strong>或**@EnableAspectJAutoProxy(proxyTargetClass = true**</h4></blockquote><h2 id="补充-Porxy类"><a href="#补充-Porxy类" class="headerlink" title="(补充)Porxy类"></a>(补充)Porxy类</h2><p>Porxy类提供了一个静态方法创建动态代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,           </span></span><br><span class="line"><span class="params">    Class&lt;?&gt;[] interfaces,                                      </span></span><br><span class="line"><span class="params">    InvocationHandler h)</span></span><br><span class="line"><span class="keyword">throws</span> IllegalArgumentException</span><br></pre></td></tr></table></figure><p>1、ClassLoader：</p><blockquote><p>ClassLoader会定义动态代理类，ClassLoader可以通过类或者接口获得，如果我们想通过接口获得，调用方法如下。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.class.getClassLoader()</span><br></pre></td></tr></table></figure><p>如果通过类来获得，加入我们有一个类TaskImpl实现了Task接口，我们有个TaskImpl的对象ob，然后ClassLoader获取方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob.getClassLoader()</span><br></pre></td></tr></table></figure><p>2、 Class&lt;?&gt;[] interfaces：动态代理类需要实现的接口</p><p>3、InvocationHandler：传递一个实现了InvokationHandler接口的类的实例</p><blockquote><p>InvokationHandler是Java 反射包里面的一个接口。InvokationHandler通过用户类来实现，来激发一个动态代理类的方法。它只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>    <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure><p>1、Object：实现方法的代理对象 </p><p>2、Method：代理实例激发的方法，Porxy参数中的接口方法 </p><p>3、Object[]：传递给方法的一系列参数</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两者有何区别&quot;&gt;&lt;a href=&quot;#两者有何区别&quot; class=&quot;headerlink&quot; title=&quot;两者有何区别&quot;&gt;&lt;/a&gt;两者有何区别&lt;/h2&gt;&lt;p&gt;1、&lt;strong&gt;Jdk动态代理&lt;/strong&gt;：利用拦截器（必须实现InvocationHandler</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="动态代理" scheme="https://gwtt.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>手写生产者消费者模式</title>
    <link href="https://gwtt.github.io/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwtt.github.io/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-27T11:47:36.000Z</published>
    <updated>2022-08-28T08:27:27.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生产者-消费者模式设计要求"><a href="#生产者-消费者模式设计要求" class="headerlink" title="生产者-消费者模式设计要求"></a>生产者-消费者模式设计要求</h3><p>这种模式满足三点要求：<br>（1）生产者生产数据到缓冲区中，消费者从缓冲区中取数据。<br>（2）缓冲区满时，生产者线程阻塞，进入等待状态。这期间消费者一旦取走数据，队列未满，就会唤醒阻塞的生产者。<br>（3）缓冲区空时，消费者线程阻塞，进入等待状态。这期间生产者一旦往队列中放入数据，就会唤醒阻塞的消费者。</p><blockquote><p>模式组成：<br>公共的缓存队列（给予缓存上限）+ 生产者线程 + 消费者线程。<br>特点：<br>1.实现了生产者、消费者的解耦：通过共享的数据缓冲区域，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。<br>2.实现了线程间的并发协作：如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；如果共享数据区为空的话，阻塞消费者继续消费数据。<br>应用场景：<br>模式解耦、消息队列、分布式场景中很常见。</p></blockquote><p>通常情况下，有5种方式来实现</p><ul><li>synchronized + wait() + notify() 方式</li><li>可重入锁ReentrantLock （配合Condition）</li><li>BlockingQueue 阻塞队列方式</li><li>信号量Semaphore 方式</li><li>管道输入输出流PipedInputStream和PipedOutputStream 方式</li></ul><h3 id="第一种方式（synchronized-）"><a href="#第一种方式（synchronized-）" class="headerlink" title="第一种方式（synchronized ）"></a>第一种方式（synchronized ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.maxSize = size;</span><br><span class="line">queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == maxSize) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列已满，生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;队列未满，生产者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;放入数据&quot;</span> + i);</span><br><span class="line"><span class="keyword">if</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列为空，消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == maxSize) &#123;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;队列有数据，消费者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;取出数据&quot;</span> + queue.remove());<span class="comment">//删除第一个数据，最早放入的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueue myBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(MyBlockingQueue myBlockingQueue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueue = myBlockingQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueue.put();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueue myBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(MyBlockingQueue myBlockingQueue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueue = myBlockingQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueue.take();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">producer_consumer_1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyBlockingQueue</span> <span class="variable">myBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBlockingQueue</span>(<span class="number">8</span>);</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(myBlockingQueue);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();<span class="comment">//生产者线程1，Thread-0</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer2).start();<span class="comment">//生产者线程2，Thread-1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();<span class="comment">//消费者线程1，Thread-3</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer2).start();<span class="comment">//消费者线程2，Thread-4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgwNzgw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><blockquote><p>补充说明：<br>1.使用Linkedlist+等待唤醒机制（wait、notify/notifyAll）+Synchronized实现线程安全。</p><p>2.为什么使用while不是if？</p><p>判断线程是否进入等待状态时，判断需要while，不能用if。在生产者、消费者线程只有一个时，if可以使用。但是多个线程的情况时就会出现问题。</p><p>例如：假设有两个消费者线程，一个生产者线程。队列为空时，消费者1进入等待状态，释放锁。消费者2抢到锁，进去后判断也进入等待，释放锁。这时生产者抢到锁生产数据，队列中有数据了，反过来唤醒两个消费者。<br>消费者1抢到锁执行wait()的逻辑，取出数据并释放锁。这时消费者2拿到锁，执行wait()后的逻辑取数据，但是此时队列中的数据已经被消费者1取出了，没有数据，这时就会出现线程不安全的情况。<br>利用while实现多次判断，不管消费者1还是2抢到锁，执行循环体的逻辑之前，会再一次判断条件是否成立，而if不会，所以使用while。</p></blockquote><h3 id="第二种方式（ReentrantLock-）"><a href="#第二种方式（ReentrantLock-）" class="headerlink" title="第二种方式（ReentrantLock ）"></a>第二种方式（ReentrantLock ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueueForCondition</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyBlockingQueueForCondition</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.max = max;</span><br><span class="line">queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == max) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列已满，生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">notFull.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">notEmpty.signalAll();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;队列未满，生产者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;放入数据&quot;</span> + i);</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列为空，消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">notEmpty.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == max) &#123;</span><br><span class="line">notFull.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">System.out.println(<span class="string">&quot;队列有数据，消费者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;取出数据&quot;</span> + i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerForCondition</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueueForCondition myBlockingQueueForCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerForCondition</span><span class="params">(MyBlockingQueueForCondition myBlockingQueueForCondition)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueueForCondition = myBlockingQueueForCondition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueueForCondition.put(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerForCondition</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueueForCondition myBlockingQueueForCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsumerForCondition</span><span class="params">(MyBlockingQueueForCondition myBlockingQueueForCondition)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueueForCondition = myBlockingQueueForCondition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueueForCondition.take();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">producer_consumer_2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">MyBlockingQueueForCondition</span> <span class="variable">myBlockingQueueForCondition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBlockingQueueForCondition</span>(<span class="number">8</span>);</span><br><span class="line"><span class="type">ProducerForCondition</span> <span class="variable">producerForCondition1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ProducerForCondition</span> <span class="variable">producerForCondition2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ConsumerForCondition</span> <span class="variable">consumerForCondition1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ConsumerForCondition</span> <span class="variable">consumerForCondition2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producerForCondition1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producerForCondition2).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumerForCondition1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumerForCondition2).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgwNzgw,size_16,color_FFFFFF,t_70-16616110494823.png" alt="在这里插入图片描述"></p><h3 id="第三种方式（BlockingQueue-）"><a href="#第三种方式（BlockingQueue-）" class="headerlink" title="第三种方式（BlockingQueue ）"></a>第三种方式（BlockingQueue ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueueTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer1).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;生产数据：&quot;</span> + element);</span><br><span class="line">queue.put(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">element</span> <span class="operator">=</span> (Integer) queue.take();</span><br><span class="line">System.out.println(<span class="string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;消费数据：&quot;</span> + element);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;生产者-消费者模式设计要求&quot;&gt;&lt;a href=&quot;#生产者-消费者模式设计要求&quot; class=&quot;headerlink&quot; title=&quot;生产者-消费者模式设计要求&quot;&gt;&lt;/a&gt;生产者-消费者模式设计要求&lt;/h3&gt;&lt;p&gt;这种模式满足三点要求：&lt;br&gt;（1）生产者生产数据到</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈股票dp问题</title>
    <link href="https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/"/>
    <id>https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-23T09:40:23.000Z</published>
    <updated>2022-08-23T16:03:13.801Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在力扣算题时，遇到股票题，觉得很有意思，于是写下自己的总结</p><h3 id="1-第一个股票问题（一次买卖）"><a href="#1-第一个股票问题（一次买卖）" class="headerlink" title="1.第一个股票问题（一次买卖）"></a>1.第一个股票问题（一次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823215745512.png" alt="image-20220823215745512"></p><blockquote><p> 首先是最简单的题目，只有一次购买，一次卖出</p><p>思路还是挺清晰的，还是DP思想：</p><ol><li>记录【今天之前买入的最小值】</li><li>计算【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】</li><li>比较【每天的最大获利】，取最大值即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当然因为我们只是用二维数组保存了两个状态，有股票和没股票，所以可以简化一下</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> prices.length;</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>,dp1 = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp0 = Math.max(dp0,dp1 + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp1 = Math.max(dp1,-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回没股票的时候</span></span><br><span class="line">            <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，没股票可以从昨天的有股票卖出，或者昨天的没股票得出（当然我们要尽量去获取最大值，毕竟利润最大），有股票可以是<strong>买今天的，或者昨天的有股票得到。</strong></p></blockquote><h3 id="2-第二个股票问题（多次买卖）"><a href="#2-第二个股票问题（多次买卖）" class="headerlink" title="2.第二个股票问题（多次买卖）"></a>2.第二个股票问题（多次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823222025568.png" alt="image-20220823222025568"></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将dp[i-<span class="number">1</span>][<span class="number">0</span>] 和dp[i-<span class="number">1</span>][<span class="number">1</span>] 存放在两个变量中，通过它们计算出 dp[i][<span class="number">0</span>] 和 dp[i][<span class="number">1</span>] 并存回对应的变量，以便于第 i+<span class="number">1</span> 天的状态转移即可。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//两个状态：手里没股票，手里有股票</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>,dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length; i ++)&#123;</span><br><span class="line">                <span class="comment">//手里没股票</span></span><br><span class="line">                dp0 = Math.max(dp0,dp1 + prices[i]);</span><br><span class="line">                <span class="comment">//手里有股票</span></span><br><span class="line">                dp1 = Math.max(dp1,dp0 - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回没股票的时候</span></span><br><span class="line">            <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比第一题，<strong>这题多了一个条件，可以多次买卖。</strong></p><p>总之，没股票可以从昨天的有股票卖出，或者昨天的没股票得出（当然我们要尽量去获取最大值，毕竟利润最大），有股票可以是<strong>从之前没股票的状态买今天的（之前的是不能的，只能是买一次），或者昨天的有股票得到。</strong></p></blockquote><h3 id="3-第三个股票问题（两次买卖）"><a href="#3-第三个股票问题（两次买卖）" class="headerlink" title="3.第三个股票问题（两次买卖）"></a>3.第三个股票问题（两次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823230742789.png" alt="image-20220823230742789"></p><blockquote><p>相比第二问，加了条只能买卖两次的设定，这使得我们必须要记录下数次交易中的两次最大值，所以我们必须新加状态进行购买次数的限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">一天结束时，可能有持股、可能未持股、可能卖出过<span class="number">1</span>次、可能卖出过<span class="number">2</span>次、也可能未卖出过</span><br><span class="line"></span><br><span class="line">所以定义状态转移数组dp[天数][当前是否持股][卖出的次数]</span><br><span class="line"></span><br><span class="line">具体一天结束时的<span class="number">6</span>种状态：</span><br><span class="line"></span><br><span class="line">未持股，未卖出过股票：说明从未进行过买卖，利润为<span class="number">0</span></span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">未持股，卖出过<span class="number">1</span>次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>]=max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">未持股，卖出过<span class="number">2</span>次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">2</span>]=max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>]=max(dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">持股，卖出过<span class="number">1</span>次股票：可能是今天买的，也可能是之前买的（昨天也持股）</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>]=max(dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">持股，卖出过<span class="number">2</span>次股票：最多交易<span class="number">2</span>次，这种情况不存在</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">2</span>]=<span class="type">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfitDP</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值Integer.MIN_VALUE-1=Integer.MAX_VALUE</span></span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">0</span>][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//持有昨天的股票，或者昨天没买，今天买了</span></span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">2</span>] = MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.max(<span class="number">0</span>, Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大神版</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一天考虑四个变量:</span></span><br><span class="line"><span class="comment">        fstBuy: 在该天第一次买入股票可获得的最大收益 </span></span><br><span class="line"><span class="comment">        fstSell: 在该天第一次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secBuy: 在该天第二次买入股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        secSell: 在该天第二次卖出股票可获得的最大收益</span></span><br><span class="line"><span class="comment">        分别对四个变量进行相应的更新, 最后secSell就是最大</span></span><br><span class="line"><span class="comment">        收益值(secSell &gt;= fstSell)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fstBuy</span> <span class="operator">=</span> Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">secBuy</span> <span class="operator">=</span> Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p : prices) &#123;</span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上也是考察的是对于状态的分析变化，需要我们理清昨天和今天的状态关系</p></blockquote><h3 id="4-第四个股票问题（k次买卖）"><a href="#4-第四个股票问题（k次买卖）" class="headerlink" title="4.第四个股票问题（k次买卖）"></a>4.第四个股票问题（k次买卖）</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823233637735.png" alt="image-20220823233637735"></p><blockquote><p>其实套路跟第三题一模一样，只是要求我们发现创建dp数组的规律</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>][k+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值,防止数据溢出</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>][i] = dp[<span class="number">0</span>][<span class="number">1</span>][i] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>][i] = dp[<span class="number">0</span>][<span class="number">1</span>][i] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;l&lt;=k;l++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j==<span class="number">0</span>&amp;&amp;l==<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=<span class="number">0</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>&amp;&amp;l==k)&#123;</span><br><span class="line">                            dp[i][j][l]=MIN_VALUE;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][l-<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][l]);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                            dp[i][j][l]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>][l]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][l]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">                max=Math.max(max,dp[prices.length-<span class="number">1</span>][<span class="number">0</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-第二个股票问题加上冷冻期"><a href="#5-第二个股票问题加上冷冻期" class="headerlink" title="5.第二个股票问题加上冷冻期"></a>5.第二个股票问题加上冷冻期</h3><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E8%82%A1%E7%A5%A8dp%E9%97%AE%E9%A2%98/image-20220823234119843.png" alt="image-20220823234119843"></p><blockquote><p>题目中定义的“冷冻期”=卖出的那一天的后一天，题目设置冷冻期的意思是，<strong>如果昨天卖出了，今天不可买入</strong>，那么关键在于哪一天卖出，只要在今天想买入的时候判断一下前一天是不是刚卖出，即可，所以关键的一天其实是卖出的那一天，而不是卖出的后一天</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//0代表不持股且当天没卖出</span></span><br><span class="line">        <span class="comment">//1代表持股</span></span><br><span class="line">        <span class="comment">//2代表不持股且当天卖出</span></span><br><span class="line">        <span class="type">int</span> [][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//从[1]...[n-1]</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">0</span>],dp[n-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者在力扣算题时，遇到股票题，觉得很有意思，于是写下自己的总结&lt;/p&gt;
&lt;h3 id=&quot;1-第一个股票问题（一次买卖）&quot;&gt;&lt;a href=&quot;#1-第一个股票问题（一次买卖）&quot; class=&quot;headerlink&quot; title=&quot;1.第一个股票问题（一次买卖）&quot;&gt;&lt;/a&gt;1.</summary>
      
    
    
    
    <category term="算法" scheme="https://gwtt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试， 动态规划" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>浅谈垃圾回收器</title>
    <link href="https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://gwtt.github.io/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2022-08-23T02:57:34.000Z</published>
    <updated>2022-08-23T10:37:44.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h1><p>如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直至垃圾回收结束！</p><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251706505-16612506422341.jpeg" alt="img"></p><p>CMS的全称：Concurrent Mark Sweep，翻译过来是<strong>并发标记清除</strong></p><p>用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是<strong>并发</strong>：在GC线程工作的时候，用户线程<strong>不会完全停止</strong>，用户线程在<strong>部分场景下</strong>与GC线程一起并发执行。</p><p>但是，要理解的是，无论是什么垃圾收集器，Stop The World是一定无法避免的！</p><p>CMS只是在<strong>部分</strong>的GC场景下可以让GC线程与用户线程并发执行</p><p>CMS的设计目标是为了避免<strong>老年代 GC</strong>出现<strong>长时间</strong>的卡顿（Stop The World）</p><h2 id="CMS的工作流程"><a href="#CMS的工作流程" class="headerlink" title="CMS的工作流程"></a>CMS的工作流程</h2><p>CMS可以简单分为5个步骤：初始标记、并发标记、（并发预清理）、重新标记以及并发清除</p><p>从步骤就不难看出，CMS主要是实现了<strong>标记清除</strong>垃圾回收算法</p><h2 id="初始标记的过程"><a href="#初始标记的过程" class="headerlink" title="初始标记的过程"></a>初始标记的过程</h2><p><strong>初始标记</strong>会标记GCRoots<strong>直接关联</strong>的对象以及<strong>年轻代</strong>指向<strong>老年代</strong>的对象</p><p><strong>初始标记</strong>这个过程是会发生Stop The World的。但这个阶段的速度算是很快的，因为没有<strong>向下追溯</strong>（只标记一层）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251706562.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251706562.jpeg" alt="img"></a></p><h2 id="并发标记的过程"><a href="#并发标记的过程" class="headerlink" title="并发标记的过程"></a>并发标记的过程</h2><p>在<strong>初始标记</strong>完了之后，就进入了<strong>并发标记</strong>阶段啦</p><p><strong>并发标记</strong>这个过程是不会停止用户线程的（不会发生 Stop The World）。这一阶段主要是从GC Roots向下<strong>追溯</strong>，标记所有可达的对象。</p><p><strong>并发标记</strong>在GC的角度而言，是比较耗费时间的（需要追溯）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707207.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707207.jpeg" alt="img"></a></p><p><strong>并发标记</strong>这个阶段完成之后，就到了<strong>并发预处理</strong>阶段啦</p><p><strong>并发预处理</strong>这个阶段主要想干的事情：希望能减少下一个阶段<strong>重新标记</strong>所消耗的时间</p><p>因为下一个阶段<strong>重新标记</strong>是需要Stop The World的</p><p><strong>并发标记</strong>这个阶段由于用户线程是没有被挂起的，所以对象是有可能发生变化的</p><p>可能有些对象，从新生代晋升到了老年代。可能有些对象，直接分配到了老年代（大对象）。可能老年代或者新生代的对象引用发生了变化…</p><h2 id="跨代引用的问题"><a href="#跨代引用的问题" class="headerlink" title="跨代引用的问题"></a>跨代引用的问题</h2><p>针对老年代的对象，其实还是可以借助类card table的存储（将老年代对象发生变化所对应的卡页标记为dirty）</p><p>所以<strong>并发预处理</strong>这个阶段会扫描可能由于<strong>并发标记</strong>时导致老年代发生变化的对象，会再扫描一遍标记为dirty的卡页</p><p>对于新生代的对象，我们还是得遍历新生代来看看在<strong>并发标记</strong>过程中有没有对象引用了老年代..</p><p>不过JVM里给我们提供了很多<strong>参数</strong>，有可能在这个过程中会触发一次 minor GC（触发了minor GC 是意味着就可以更少地遍历新生代的对象）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707070.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707070.jpeg" alt="img"></a></p><h2 id="重新标记的过程"><a href="#重新标记的过程" class="headerlink" title="重新标记的过程"></a>重新标记的过程</h2><p><strong>并发预处理</strong>这个阶段阶段结束后，就到了<strong>重新标记</strong>阶段</p><p><strong>重新标记</strong>阶段会Stop The World，这个过程的停顿时间其实很大程度上取决于上面<strong>并发预处理</strong>阶段（可以发现，这是一个追赶的过程：一边在标记存活对象，一边用户线程在执行产生垃圾）</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207251707172.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207251707172.jpeg" alt="img"></a></p><h2 id="并发清除的过程"><a href="#并发清除的过程" class="headerlink" title="并发清除的过程"></a>并发清除的过程</h2><p>最后就是<strong>并发清除</strong>阶段，不会Stop The World</p><p>一边用户线程在执行，一边GC线程在回收不可达的对象</p><p>这个过程，还是有可能用户线程在不断产生垃圾，但只能留到下一次GC 进行处理了，产生的这些垃圾被叫做“浮动垃圾”</p><p>完了以后会重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备</p><p><a href="https://test1.jsdelivr.net/gh/Faetbwac/img/202207252308270.jpeg"><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/202207252308270.jpeg" alt="img"></a></p><h2 id="CMS的缺点"><a href="#CMS的缺点" class="headerlink" title="CMS的缺点"></a>CMS的缺点</h2><ol><li>空间需要预留：CMS垃圾收集器可以一边回收垃圾，一边处理用户线程，那需要在这个过程中保证有充足的内存空间供用户使用。如果CMS运行过程中预留的空间不够用了，会报错（Concurrent Mode Failure），这时会启动 Serial Old垃圾收集器进行老年代的垃圾回收，会导致停顿的时间很长。显然啦，空间预留多少，肯定是有参数配置的。</li><li><strong>浮动垃圾</strong>：由于垃圾回收和用户线程是同时进行的，在进行标记或者清除的同时，用户的线程还会去改变对象的引用，使得原来某些对象不是垃圾，但是当 CMS 进行清理的时候变成了垃圾，CMS 收集器无法收集，只能等到下一次 GC。CMS 收集器无法处理<strong>浮动垃圾</strong>（Floating Garbage），可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。如果在应用中老年代增长不是太快，可以适当调高参数 - XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。</li><li>内存碎片问题：CMS本质上是实现了<strong>标记清除算法</strong>的收集器（从过程就可以看得出），这会意味着会产生内存碎片。由于碎片太多，又可能会导致内存空间不足所触发full GC，CMS一般会在触发full GC这个过程对碎片进行整理。整理涉及到<strong>移动</strong>/<strong>标记</strong>，那这个过程肯定会Stop The World的，如果内存足够大（意味着可能装载的对象足够多），那这个过程卡顿也是需要一定的时间的。</li></ol><h2 id="补充面试题"><a href="#补充面试题" class="headerlink" title="补充面试题:"></a>补充面试题:</h2><h3 id="1-CMS的过程？"><a href="#1-CMS的过程？" class="headerlink" title="1.CMS的过程？"></a>1.CMS的过程？</h3><blockquote><p>初始标记、并发标记、（并发预清理）、重新标记以及并发清除</p></blockquote><h3 id="2-怎么标记垃圾的？"><a href="#2-怎么标记垃圾的？" class="headerlink" title="2,怎么标记垃圾的？"></a>2,怎么标记垃圾的？</h3><blockquote><p>使用三色标记法</p></blockquote><h3 id="3-什么是三色标记法"><a href="#3-什么是三色标记法" class="headerlink" title="3.什么是三色标记法"></a>3.什么是三色标记法</h3><blockquote><p><img src="/2022/08/23/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Nzk4NTU2,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>　三色标记法，是把内存中的对象，标记为3种颜色，分布是：黑、灰、白。(<strong>上文图中的红色仅供参考</strong>)</p><ul><li><p>黑：表示该对象已经扫描到，并且它可触达的对象也已经扫描到；</p></li><li><p>灰：表示该对象已经扫描到，但是它能触发的对象至少还有一个没有扫描到；</p></li><li><p>白：表示该节点没有被扫描到；</p></li></ul></blockquote><h3 id="4-CMS和G1的区别"><a href="#4-CMS和G1的区别" class="headerlink" title="4.CMS和G1的区别"></a>4.CMS和G1的区别</h3><blockquote><ul><li>G1和CMS都分为4个阶段,前三个阶段基本相同都为初始标记,并发标记,再次标记,区别在于最后清除阶段CMS是并发的,G1不是并发的,因此CMS最终会产生浮动垃圾,只能等待下次gc才能清除</li><li>G1可以管理整个堆,而CMS只能作用于老年代,并且CMS在老年代使用的是标记清除算法,会产生内存碎片,而G1使用标记整理算法,不会产生内存碎片</li><li>G1相比于CMS最大的区别是G1将内存划分为大小相等的Region,可以选择垃圾对象多的Region而不是整个堆从而减少STW,同时使用Region可以更精确控制收集,我们可以手动明确一个垃圾回收的最大时间</li></ul></blockquote><h3 id="5-CMS什么时候会STW？为什么要STW（咋瓦鲁多）"><a href="#5-CMS什么时候会STW？为什么要STW（咋瓦鲁多）" class="headerlink" title="5.CMS什么时候会STW？为什么要STW（咋瓦鲁多）?"></a>5.CMS什么时候会STW？为什么要STW（咋瓦鲁多）?</h3><blockquote><p><strong>初始标记和重新标记的时候</strong></p><p>因为初始标记标记的是GC Root，而GC Root容易变动，比如栈帧中的本地变量表。所以需要STW。</p><p>因为在重新标记之前是并发标记，在并发标记的期间会出现漏标和多标的对象，所以为了修正这部分对象，需要在重新标记期间STW。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMS垃圾回收器&quot;&gt;&lt;a href=&quot;#CMS垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;CMS垃圾回收器&quot;&gt;&lt;/a&gt;CMS垃圾回收器&lt;/h1&gt;&lt;p&gt;如果用Seria和Parallel系列的垃圾收集器：在垃圾回收的时，用户线程都会完全停止，直</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Jvm" scheme="https://gwtt.github.io/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法</title>
    <link href="https://gwtt.github.io/2022/08/20/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://gwtt.github.io/2022/08/20/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-08-20T06:28:34.000Z</published>
    <updated>2022-08-27T11:48:02.950Z</updated>
    
    <content type="html"><![CDATA[<p> 下图展示了十大排序的名字和大致用法 </p><h3 id><a href="#" class="headerlink" title></a><img src="https://pic.leetcode-cn.com/1652691519-SVKUkM-image.png" alt="image.png"></h3><blockquote><p>说到排序，首先要用到就是交换数字，接下来谈谈三次交换方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: 利用临时数tmp</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二: 利用加减运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapCal</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>; <span class="comment">// 若无法保证swapCal被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span></span><br><span class="line">    arr[i] = arr[i] + arr[j]; <span class="comment">// a = a + b</span></span><br><span class="line">    arr[j] = arr[i] - arr[j]; <span class="comment">// b = a - b</span></span><br><span class="line">    arr[i] = arr[i] - arr[j]; <span class="comment">// a = a - b</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三: 利用异或运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapXOR</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) <span class="keyword">return</span>; <span class="comment">// 若无法保证swapXOR被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// a = a ^ b，也可写成 arr[i] ^= arr[j];</span></span><br><span class="line">    arr[j] = arr[i] ^ arr[j]; <span class="comment">// b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a， 也可写成 arr[j] ^= arr[i];</span></span><br><span class="line">    arr[i] = arr[i] ^ arr[j]; <span class="comment">// a = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b， 也可写成 arr[i] ^= arr[j];</span></span><br><span class="line">&#125;</span><br><span class="line">方法一: 利用一个临时数 tmp 来交换 arr[i] ，arr[j] 。</span><br><span class="line">方法二: 利用 arr[i] 和和 arr[j] 的加减运算避免临时数 tmp 的开销，但由于涉及到加减法可能导致数字 「提前溢出」 。</span><br><span class="line">方法三: 利用位运算中的 异或 运算，能够避免 tmp 的开销且不会导致数字溢出。</span><br></pre></td></tr></table></figure></blockquote><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>从第一位开始向后依次比较，如果前者大则交换（实际根据大小方向），循环arr.length-1次</p><h4 id="最笨的形式"><a href="#最笨的形式" class="headerlink" title="最笨的形式"></a>最笨的形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="提前结束优化"><a href="#提前结束优化" class="headerlink" title="提前结束优化"></a>提前结束优化</h5><p>当某一轮比较均未发生交换，说明排序已完成，可设置一个布尔值记录一轮排序是否有发生交换，若无则提前退出循环结束程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1轮次执行，当前 n - 1 个元素排好后，最后一个元素无需执行，故i &lt; arr.length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 本轮执行是否有交换的标志，若无则false，若有则true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 若左大于右则交换，并将swapped置为true</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无交换，表示当前数组已完全排序，退出大循环</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="冒泡界优化"><a href="#冒泡界优化" class="headerlink" title="冒泡界优化"></a>冒泡界优化</h5><p>记录前一轮交换的最终位置，说明该位置之后的元素为已排序状态，下一轮的交换只需执行到该处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastSwappedIdx</span> <span class="operator">=</span> arr.length - <span class="number">1</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">swappedIdx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// lastSwappedIdx表示前一轮交换的最终位置，即下标为lastSwappedIdx是未排序部分中的最后一个数的下标，</span></span><br><span class="line">    <span class="comment">// 因此for中的界是i &lt; lastSwappedIdx而不需要写成i &lt;= lastSwappedIdx</span></span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123; <span class="comment">// 当swapped = false时，排序完成</span></span><br><span class="line">        <span class="comment">// 本轮执行是否有交换的标志，若无则true，若有则false</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lastSwappedIdx; i++) &#123;</span><br><span class="line">            <span class="comment">// 若左大于右则交换，并将swapped置为true</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                swappedIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastSwappedIdx = swappedIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n^2)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>每一轮循环选一个最小（或者最大）的数放到第i位，循环arr.length-1次</p><h4 id="单元选择排序"><a href="#单元选择排序" class="headerlink" title="单元选择排序"></a>单元选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1 轮次执行,当前 n - 1 个元素排好后，最后一个元素无需执行，故 i &lt; arr.length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 找到本轮执行中最小的元素，将最小值下标赋值给min</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])  minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若本轮第一个数字不是最小值，则交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) swap(arr, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双元选择排序"><a href="#双元选择排序" class="headerlink" title="双元选择排序"></a>双元选择排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectSortDouble(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">// 每轮确定两个数字，因此界也会动态变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span> - i; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIdx</span> <span class="operator">=</span> i, maxIdx = i;</span><br><span class="line">        <span class="comment">// 找到本轮执行中最小和最大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) minIdx = j;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[maxIdx]) maxIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若本轮最大值等于最小值，说明未排序部分所有元素相等，无需再排序</span></span><br><span class="line">        <span class="keyword">if</span>(minIdx == maxIdx) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 若本轮第一个数字不是最小值，则交换位置（将最小值与本轮第一个数字交换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) swap(arr, i, minIdx);</span><br><span class="line">        <span class="comment">// 在交换i和minIdx时，有可能出现i即maxIdx的情况，此时需要修改maxIdx为minIdx</span></span><br><span class="line">        <span class="keyword">if</span>(maxIdx == i) maxIdx = minIdx;</span><br><span class="line">        <span class="comment">// 若本轮最后一个数字不是最大值，则交换位置（将最大值与本轮最后一个数字交换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (maxIdx != n - <span class="number">1</span> - i) swap(arr, n - <span class="number">1</span> - i, maxIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间:O(n^2)</strong></p><p><strong>空间:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>对于待排序数组，从第2个元素开始(称作插入对象元素)，比较它与之前的元素(称作比较对象元素)，当插入对象元素小于比较对象元素时，继续往前比较，直到不小于(≥)比较对象，此时将插入对象元素插入到该次比较对象元素之后。重复这个插入过程直到最后一个元素作为插入对象元素完成插入操作。</p><h4 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// N-1轮次执行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; arr[j]) arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = target; <span class="comment">// 若发生移动，此时的插入对象数字≥j位置的数字，故插入位置为j + 1，若未移动也成立，无需判断</span></span><br><span class="line">        <span class="comment">// if(j != i - 1) arr[j + 1] = target; // 也可以用这种写法，表示发生移动才插入，否则不必插入(赋值)，但不判断效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="折半插入优化-利用二分来减少中间比较次数"><a href="#折半插入优化-利用二分来减少中间比较次数" class="headerlink" title="折半插入优化(利用二分来减少中间比较次数)"></a>折半插入优化(利用二分来减少中间比较次数)</h4><p>注意到插入排序的每一轮向前插入都使得该元素在完成插入后，从第一个元素到该元素是排序状态（指这部分的相对排序状态，在它们中间后续可能还会插入其他数字），利用这一点，对一个新的插入对象向前执行折半插入，能够显著减少比较的次数。另一种优化是增量递减插入排序，也叫希尔排序，将在希尔排序章节中介绍。</p><p>折半插入的关键在于找到插入位置，折半过程代码如下。这实际上是二分查找「模版一」中的「小于等于」情形。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertSortBinary(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// n - 1 轮次执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 若当前插入对象大于等于前一个对象，无需插入</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &lt;= arr[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">// 折半查找 (二分查找「模版一」)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// while结束后，target要插入的位置为low或high + 1 (low = high + 1)</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[center] &lt;= target) low = center + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = center - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; low; j--) &#123; <span class="comment">// 移动</span></span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = target; <span class="comment">// 插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间:O(n^2)</strong></p><p><strong>空间:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="Shell增量"><a href="#Shell增量" class="headerlink" title="Shell增量"></a>Shell增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序：采用Shell增量 N / 2^k</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortShell(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// gap 初始为 n/2，缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; n; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Hibbard增量"><a href="#Hibbard增量" class="headerlink" title="Hibbard增量"></a>Hibbard增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序： 采用Hibbard增量 &#123;1, 3, 7, 15,...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortHibbard(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n / <span class="number">2</span>) gap = gap * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 初始化gap (Hibbard增量序列)</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123; <span class="comment">// 缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; arr.length; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Knuth增量"><a href="#Knuth增量" class="headerlink" title="Knuth增量"></a>Knuth增量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序： 采用Knuth增量 &#123;1, 4, 13, 40,...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSortKnuth(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, gap = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n / <span class="number">3</span>) gap = gap * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 初始化gap (Knuth增量序列)</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123; <span class="comment">// 缩小gap直到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; gap; start++) &#123; <span class="comment">// 步长增量是gap，当前增量下需要对gap组序列进行简单插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + gap; i &lt; arr.length; i += gap) &#123; <span class="comment">// 此for及下一个for对当前增量序列执行简单插入排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i], j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j -= gap) &#123; </span><br><span class="line">                     <span class="keyword">if</span> (target &lt; arr[j]) &#123;</span><br><span class="line">                         arr[j + gap] = arr[j];</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">                &#125;                 </span><br><span class="line">                <span class="keyword">if</span> (j != i - gap) arr[j + gap] = target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单插入排序和希尔排序比较</p><p><img src="https://pic.leetcode-cn.com/1653024423-RVrPou-image.png" alt="image.png"></p></blockquote><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序是 <strong>分治思想</strong> 的应用，即将原待排数组 <strong>递归或迭代地</strong> 分为左右两半，直到数组长度为1，然后对左右数组进行合并(merge)，在合并中完成排序。</p><p><strong>自顶向下</strong>(top-down)：从输入数组出发，不断二分该数组，直到数组长度为1，再执行合并。适合用 递归 实现。</p><p><strong>自底向上</strong>(bottom-up)：从输入数组的单个元素出发，一一合并，二二合并，四四合并直到数组有序。适合用 迭代 实现。</p><h4 id="自顶向下非原地归并"><a href="#自顶向下非原地归并" class="headerlink" title="自顶向下非原地归并"></a>自顶向下非原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, tmpArr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, tmpArr, left, center);</span><br><span class="line">        mergeSort(arr, tmpArr, center + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tmpArr, left, center, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原地合并方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> leftPos, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightPos</span> <span class="operator">=</span> leftEnd + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">startIdx</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpPos</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="keyword">while</span> (leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[leftPos] &lt;= arr[rightPos]) &#123;</span><br><span class="line">            tmpArr[tmpPos++] = arr[leftPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmpArr[tmpPos++] = arr[rightPos++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后若左数组还有剩余，则将其添加到tmpArr剩余空间</span></span><br><span class="line">    <span class="keyword">while</span> (leftPos &lt;= leftEnd) &#123;</span><br><span class="line">        tmpArr[tmpPos++] = arr[leftPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较完成后若右数组还有剩余，则将其添加到tmpArr剩余空间</span></span><br><span class="line">    <span class="keyword">while</span> (rightPos &lt;= rightEnd) &#123;</span><br><span class="line">        tmpArr[tmpPos++] = arr[rightPos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容易遗漏的步骤，将tmpArr拷回arr中</span></span><br><span class="line">    <span class="comment">// 从小区间排序到大区间排序，大区间包含原来的小区间，需要从arr再对应比较排序到tmpArr中，</span></span><br><span class="line">    <span class="comment">// 所以arr也需要动态更新为排序状态，即随时将tmpArr拷回到arr中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt;= rightEnd; i++) &#123;</span><br><span class="line">        arr[i] = tmpArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自顶向下原地归并"><a href="#自顶向下原地归并" class="headerlink" title="自顶向下原地归并"></a>自顶向下原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, center);</span><br><span class="line">        mergeSort(arr, center + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, center, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地归并（手摇算法）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> leftPos, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftPos, j = leftEnd + <span class="number">1</span>; <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt;= arr[j]) i++; <span class="comment">// #2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j; <span class="comment">// #3</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= rightEnd &amp;&amp; arr[j] &lt; arr[i]) j++; <span class="comment">// #4 注意是 arr[j] &lt; arr[i]，即找到j使得arr[j] 为第一个大于等于 arr[i]值</span></span><br><span class="line">        exchange(arr, i, index - <span class="number">1</span>, j - <span class="number">1</span>); <span class="comment">// #5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三次翻转实现交换</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> leftEnd, <span class="type">int</span> rightEnd)</span> &#123;</span><br><span class="line">    reverse(arr, left, leftEnd);</span><br><span class="line">    reverse(arr, leftEnd + <span class="number">1</span>, rightEnd);</span><br><span class="line">    reverse(arr, left, rightEnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        swap(arr, start, end);</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自底向上非原地归并"><a href="#自底向上非原地归并" class="headerlink" title="自底向上非原地归并"></a>自底向上非原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSortBU(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="comment">// 间隔，注意不能写成gap &lt; arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; arr.length; gap *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - gap; left += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="comment">// 调用非原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;</span></span><br><span class="line">            merge(arr, tmpArr, left, left + gap - <span class="number">1</span>, Math.min(left + <span class="number">2</span> * gap - <span class="number">1</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自底向上原地归并"><a href="#自底向上原地归并" class="headerlink" title="自底向上原地归并"></a>自底向上原地归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSortBUInPlace(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 间隔，注意不能写成gap &lt; arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; arr.length; gap *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - gap; left += <span class="number">2</span> * gap) &#123;</span><br><span class="line">            <span class="comment">// 调用原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;</span></span><br><span class="line">            merge(arr, left, left + gap - <span class="number">1</span>, Math.min(left + <span class="number">2</span> * gap - <span class="number">1</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p><strong>与归并排序一样，快速排序也是一种利用 分治思想 的排序方法，确定 主轴及分区 是快速排序的核心操作。首先在数组中确定一个主轴元素(下标记为 pivot)，然后将数组分为两部分，小于主轴的放在（确定最终位置的）主轴左侧，大于等于主轴的放在主轴右侧。递归地对主轴左右两侧数组执行这个过程，每次递归都传入待排序数组 arr 和本次要处理的部分的左右界，只处理这个范围内的序列。当所有递归都到达基准情形时，排序完成。因为是原地交换，递归过程中 arr总是在动态排序，递归过程无需返回，为尾递归形式。</strong></p><h4 id="递归快排"><a href="#递归快排" class="headerlink" title="递归快排"></a>递归快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三数取中快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortMedian3(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    quickSortMedian3(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortMedian3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; right) &#123; </span><br><span class="line">        <span class="comment">// 执行median3将左，中，右三数中值放到left位置上</span></span><br><span class="line">        median3(arr, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortMedian3(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortMedian3(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将left, center, right下标三个数中，大小居中者放到left下标处</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">median3</span><span class="params">(<span class="type">int</span>[]arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[c]) swap(arr, l, c); <span class="comment">// 左中，大者居中</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[r]) swap(arr, c, r); <span class="comment">// 中右，大者居右，此时最大者居右</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[l]) swap(arr, l, c); <span class="comment">// 左中，大者居左，此时中者居左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机主轴快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortRandom(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSortRandom(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortRandom</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 取区间内随机下标，注意Random().nextInt(int x)方法的使用（含0不含x）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left) + left + <span class="number">1</span>; <span class="comment">// 在[left + 1, right]范围内的随机值</span></span><br><span class="line">        <span class="comment">// 交换随机取得的下标元素与当前起始元素</span></span><br><span class="line">        swap(arr, left, randomIndex); <span class="comment">// arr[left]与它之后的某个数交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortRandom(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortRandom(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素快排(首位为主轴)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortSimple(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    quickSortSimple(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 后两个参数是下标值</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortSimple</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 若left == right，表示此时arr只有一个元素，即为基准情形，完成递归(准确说是完成递进)</span></span><br><span class="line">    <span class="comment">// (尾递归，“回归”过程中不做任何事情）</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSortSimple(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSortSimple(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//　partition方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left, index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意此时right是坐标，要执行到最后一个元素，所以是&lt;=</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, index, i);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个小于主轴元素的元素下标是index - 1</span></span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="非递归快排-迭代快排"><a href="#非递归快排-迭代快排" class="headerlink" title="非递归快排 (迭代快排)"></a><strong>非递归快排 (迭代快排)</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] quickSortStack(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 用于保存区间左右边界的栈，按right到left的顺序将初始区间界入栈</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 判断栈是否空，不空则弹出一对left，right界</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop(), right = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123; <span class="comment">// 执行partition的前提是left小于right</span></span><br><span class="line">            <span class="comment">// 对[left, right]区间执行partition方法，得到pivot</span></span><br><span class="line">              <span class="comment">// 加入后续两行实现随机轴快排</span></span><br><span class="line">            <span class="comment">// int randomIndex = new Random().nextInt(right - left) + left + 1; // 在[left + 1, right]范围内的随机值</span></span><br><span class="line">            <span class="comment">// swap(arr, left, randomIndex); // arr[left]与它之后的某个数交换</span></span><br><span class="line">              <span class="comment">// 加入下行实现三数取中快排</span></span><br><span class="line">            median3(arr, left, right);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            <span class="comment">// 当前pivot的左区间存在则将该区间right，left界入栈</span></span><br><span class="line">            <span class="keyword">if</span>(pivot &gt; left) &#123;</span><br><span class="line">                stack.push(pivot - <span class="number">1</span>);</span><br><span class="line">                stack.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前pivot的右区间存在则将该区间right，left界入栈</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt; pivot) &#123;</span><br><span class="line">                stack.push(right);</span><br><span class="line">                stack.push(pivot + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(logn)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>将输入数组建立为一个 <strong>大顶堆</strong>，之后反复取出堆顶并对剩余元素重建大顶堆，将依次取出的堆顶逆序排列，即可将原数组从小到大排列完成排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    heapify(arr, arr.length - <span class="number">1</span>); <span class="comment">// 构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// i &gt; 0即可，无需写成i &gt;= 0，当n - 1个元素排序时，最后一个元素也已排序</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i); <span class="comment">// 交换堆顶和当前未排序部分最后一个元素</span></span><br><span class="line">        <span class="comment">// 此时除当前堆顶元素外都是保持堆序的，只需要对该堆顶调用一次下滤操作</span></span><br><span class="line">        siftDown(arr, <span class="number">0</span>, i - <span class="number">1</span>); <span class="comment">// i - 1是未排序部分最后一个元素下标，确保下滤不会超过此范围</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> endIdx)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hole</span> <span class="operator">=</span> (endIdx - <span class="number">1</span>) / <span class="number">2</span>; hole &gt;= <span class="number">0</span>; hole--) &#123; <span class="comment">// (endIdx - 1) / 2伪最后一个非叶子节点下标</span></span><br><span class="line">        siftDown(arr, hole, endIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> hole, <span class="type">int</span> endIdx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[hole]; <span class="comment">// target是要下滤的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= endIdx) &#123;</span><br><span class="line">        <span class="comment">// 满足第一个条件child &lt; endIdx表示hole有右孩子，不满足则hole无右孩子，跳过</span></span><br><span class="line">        <span class="comment">// 第二个条件arr[child + 1] &gt; arr[child]只在第一个条件成立前提下进行判断（因此不必担心arr[child + 1]越界），</span></span><br><span class="line">        <span class="comment">// 若满足，表示hole有右孩子且右孩子更大，令child为右孩子下标。</span></span><br><span class="line">        <span class="comment">// 因此此if过后使得child是hole的孩子中较大的那个</span></span><br><span class="line">        <span class="keyword">if</span> (child &lt; endIdx &amp;&amp; arr[child + <span class="number">1</span>] &gt; arr[child]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若child大于target，则child上移到当前hole，hole下滤到child位置 </span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &gt; target) &#123;</span><br><span class="line">            arr[hole] = arr[child];</span><br><span class="line">            hole = child;</span><br><span class="line">            child = hole * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 当然也可以写成child = child * 2 + 1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 若无需交换hole与child，说明hole已经满足堆序(无需/无法再下滤)，退出while</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[hole] = target; <span class="comment">// 将target填入hole中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(nlogn)</strong></p><p><strong>空间复杂度:O(1)</strong></p><p><strong>不稳定</strong></p></blockquote><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><blockquote><h4 id="计数排序的特征"><a href="#计数排序的特征" class="headerlink" title="计数排序的特征"></a><strong>计数排序的特征</strong></h4><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><p> 算法的步骤如下：</p><ul><li>（1）找出待排序的数组中最大和最小的元素</li><li>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><h4 id="不稳定计数排序"><a href="#不稳定计数排序" class="headerlink" title="不稳定计数排序"></a>不稳定计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSortUnstable(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        countArr[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countArr.length; i++) &#123; <span class="comment">// 遍历countArr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countArr[i]; j++) &#123; <span class="comment">// countArr[i]可能有多个相同数字</span></span><br><span class="line">            arr[index] = i + min; <span class="comment">// 复用了原输入数组arr</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="稳定计数排序"><a href="#稳定计数排序" class="headerlink" title="稳定计数排序"></a>稳定计数排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] countSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length, min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>]; <span class="comment">// arr最多有max-min+1种数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        countArr[arr[i] - min]++; <span class="comment">// arr[i]的值出现一次，则countArr[arr[i]-min]加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; countArr.length; i++) &#123; <span class="comment">// 变形</span></span><br><span class="line">        countArr[i] += countArr[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 根据sortedArr, nums, countArr三者关系完成sortedArr的输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sortedArr[countArr[arr[i] - min] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        countArr[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n+k)</strong></p><p><strong>空间复杂度:O(n+k)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><blockquote><p>非比较排序，「基」指的是数的位，例如十进制数 123，共有百十个位，共 3 个位。基数排序 按数字的位进行循环，每一轮操作都是对当前位（基数）的计数排序，使得输出到 arr 后所有数字在截止到当前位上（即去掉未考察的位后）是排序状态，考察完最大位后完成排序。具体过程如下：</p><ul><li>遍历待排序数组 arr ，找到最大值，计算其位数，例如 arr 中最大数为 123 ，则 maxDigitLen = 3 。</li><li>数组的数字为 n 进制，就创建大小为 n 的计数数组 countArr ，也可以称为 n 个桶。</li><li>开始「位」的 for 循环，循环次数等于 maxDigitLen ，每一轮对 当前所有数字的当前位 执行一次 计数排序。</li><li>每次计数排序结束后将结果写回 arr 。</li><li>for循环结束后返回排序结果 arr。</li></ul><h4 id="以计数排序为基础"><a href="#以计数排序为基础" class="headerlink" title="以计数排序为基础"></a>以计数排序为基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.abs(arr[<span class="number">0</span>]); <span class="comment">// 找到arr中绝对值最大者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigitLen</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">10</span>; <span class="comment">// 最大位数 &amp; 基（几进制就是几）</span></span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLen++;</span><br><span class="line">        max /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在接下来的for中，每一轮都对当前位(基数)执行一次计数排序</span></span><br><span class="line">    <span class="type">int</span>[] sortedArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigitLen; i++) &#123;</span><br><span class="line">        <span class="type">int</span>[] countArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">19</span>]; <span class="comment">// 处理负数优化</span></span><br><span class="line">        <span class="comment">// 根据每一个数字当前位的数字，累计相应位置的计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 此步处理要注意，当base大于10时，例如base=100时，1234%100=34</span></span><br><span class="line">            <span class="comment">// 还需要再除以(base/10)，得到的3，然后再+9（考虑负数）才是本次的bucketIdx</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>;</span><br><span class="line">            countArr[bucketIdx]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// countArr变形，得到每个下标所代表的arr中的数的当前位在arr中的最大位置（从1开始）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; countArr.length; j++) &#123;</span><br><span class="line">            countArr[j] += countArr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序输出保持稳定性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">thisBase</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>;</span><br><span class="line">            <span class="comment">// countArr[thisBase]得到的从1开始计算的位置，转成下标要-1</span></span><br><span class="line">            sortedArr[countArr[thisBase] - <span class="number">1</span>] = arr[j]; </span><br><span class="line">            countArr[thisBase]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成当前位的计数排序后将排序结果拷贝回原数组</span></span><br><span class="line">        arr = Arrays.copyOf(sortedArr, sortedArr.length);</span><br><span class="line">        <span class="comment">// base进一位，准备下一轮对下一位的计数排序</span></span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="不以计数排序为基础"><a href="#不以计数排序为基础" class="headerlink" title="不以计数排序为基础"></a>不以计数排序为基础</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 找到arr中绝对值最大者</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.abs(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, Math.abs(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigitLen</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">10</span>; <span class="comment">// 最大位数 &amp; 基</span></span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLen++;</span><br><span class="line">        max /= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arr.length + 1的作用是令每个桶的第0位保存该桶的元素个数。</span></span><br><span class="line">    <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">19</span>][arr.length + <span class="number">1</span>]; <span class="comment">// 处理负数优化</span></span><br><span class="line">    <span class="comment">// 在每一位上将数组中所有具有该位的数字装入对应桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigitLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 此步处理要注意，当base大于10时，例如base=100时，1234%100=34</span></span><br><span class="line">            <span class="comment">// 还需要再除以(base/10)，得到的3才是本次的bucketIndex</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (arr[j] % base) / (base / <span class="number">10</span>) + <span class="number">9</span>; <span class="comment">// +9使其可以处理负数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentBucketQuantity</span> <span class="operator">=</span> buckets[bucketIdx][<span class="number">0</span>];</span><br><span class="line">            buckets[bucketIdx][currentBucketQuantity + <span class="number">1</span>] = arr[j];</span><br><span class="line">            buckets[bucketIdx][<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前所有桶的数按桶序，桶内按低到高输出为本轮排序结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= buckets[j][<span class="number">0</span>]; k++) &#123;</span><br><span class="line">                arr[arrIdx++] = buckets[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一轮过后将桶计数归零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) bucket[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        base *= <span class="number">10</span>; <span class="comment">// 调整base</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(d(n+k))</strong></p><p><strong>空间复杂度:O(n+k)</strong></p><p><strong>稳定</strong></p></blockquote><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote><p>桶排序将原数组划分到称为 「桶」 的多个区间中，然后对每个桶单独进行排序，之后再按桶序和桶内序输出结果。适合于分布较均匀的数据，具体做法如下。</p><ul><li><p>根据数据规模按照 一定的方法 将待排序数组arr划分为多个区间，每个区间称作一个桶。</p></li><li><p>每个桶可以是数组，也可以是泛型容器，用于保存arr中落在该桶范围内的数。</p></li><li><p>对每一个桶都单独排序，需要 以适当的排序 方法支持，例如插入排序，快速排序等。</p></li><li><p>所有桶完成排序后，按桶序，桶内序依次输出所有元素，得到arr的排序结果。</p><p><strong>稳定性：取决于桶内排序方法的稳定性。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>], max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用泛型List存储所有桶，每个桶是一个ArrayList&lt;Integer&gt;，并初始化所有桶。</span></span><br><span class="line">    <span class="comment">// arr.length/3表示设置数组大小三分之一数量的桶</span></span><br><span class="line">    List&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr.length / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历arr，根据元素值将所有元素装入对应值区间的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// (arr[i] - min)/D为arr[i]元素应该装入的桶的下标，间隔D = (max-min)/(arr.length-1)</span></span><br><span class="line">        <span class="comment">// 虽可写成(arr[i] - min)*(arr.length-1)/(max-min)的形式，但当输入数组取值范围较大且元素较多时</span></span><br><span class="line">        <span class="comment">// (arr[i] - min)*(arr.length-1)可能会超过int上限，因此先做除法求出double类型的D</span></span><br><span class="line">        <span class="comment">// 再做一次除法求出bucketIndex，可以避免计算精度不够高带来的问题</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">interval</span> <span class="operator">=</span> (<span class="type">double</span>)(max - min) / (<span class="type">double</span>)(arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketIdx</span> <span class="operator">=</span> (<span class="type">int</span>) ((arr[i] - min) / interval);</span><br><span class="line">        buckets.get(bucketIdx).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序(调用库函数，从小到大)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.size(); i++) &#123;</span><br><span class="line">        Collections.sort(buckets.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sortedItem : bucket) &#123;</span><br><span class="line">            arr[index] = sortedItem; <span class="comment">// 复用输入数组arr</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度:O(n)</strong></p><p><strong>空间复杂度:O(n)</strong></p><p><strong>稳定</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 下图展示了十大排序的名字和大致用法 &lt;/p&gt;
&lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;img src=&quot;https://pic.leetcode-cn.com/1652691519-SVKUkM-image.png</summary>
      
    
    
    
    <category term="算法" scheme="https://gwtt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试， 排序" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C-%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux面试(1)</title>
    <link href="https://gwtt.github.io/2022/08/18/Linux%E9%9D%A2%E8%AF%95(1)/"/>
    <id>https://gwtt.github.io/2022/08/18/Linux%E9%9D%A2%E8%AF%95(1)/</id>
    <published>2022-08-18T14:23:13.000Z</published>
    <updated>2022-09-01T04:53:20.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-在Linux系统中如何统计某个字符串出现的次数"><a href="#1-在Linux系统中如何统计某个字符串出现的次数" class="headerlink" title="1.在Linux系统中如何统计某个字符串出现的次数"></a>1.在Linux系统中如何统计某个字符串出现的次数</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -o targetStr filename | wc -l（单个字符串）</span><br><span class="line">&quot;targetStr&quot;可以不加引号</span><br><span class="line">grep -o targetStr_1\|targetStr_2\|targetStr_3…… filename | wc -l</span><br><span class="line">&quot;targetStr_1&quot;这些必须加引号</span><br><span class="line">但是上面的方法是不准确的，因为wc -l只是显示行数，如果一行字符串多次出现，那么结果不准确</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-Linux查看日志的几种命令"><a href="#2-Linux查看日志的几种命令" class="headerlink" title="2.Linux查看日志的几种命令"></a>2.Linux查看日志的几种命令</h3><blockquote><h3 id="1-tail-查看实时变化的日志-比较吃内存"><a href="#1-tail-查看实时变化的日志-比较吃内存" class="headerlink" title="1. tail 查看实时变化的日志(比较吃内存)"></a>1. tail 查看实时变化的日志(<strong>比较吃内存</strong>)</h3><p>退出tail命令：Ctrl+c</p><table><thead><tr><th>-f</th><th>循坏读取</th></tr></thead><tbody><tr><td>-q</td><td>不显示处理信息</td></tr><tr><td>-v</td><td>显示详细的处理信息</td></tr><tr><td>-c</td><td>&lt;数目&gt; 显示的字节数</td></tr><tr><td>-n</td><td>显示行数 （相当于nl命令）</td></tr><tr><td>-pid=PID</td><td>与-f合用,表示在进程ID,PID死掉之后结束.</td></tr><tr><td>-q,-quiet,-slient</td><td>从不输出给出文件名的首部</td></tr><tr><td>-s, –sleep-interval=S</td><td>与-f合用,表示在每次反复的间隔休眠S秒</td></tr></tbody></table><table><thead><tr><th>用法</th><th>作用</th></tr></thead><tbody><tr><td>1. tail -f filename</td><td>默认最后10行,相当于增加参数 -n 10</td></tr><tr><td>2. tail -n 20 filename</td><td>显示filename最后20行</td></tr><tr><td>3. tail -n +5 filename</td><td>从第5行开始显示文件</td></tr></tbody></table><h3 id="2-cat命令"><a href="#2-cat命令" class="headerlink" title="2. cat命令"></a>2. cat命令</h3><p>cat命令搜索关键字附近的日志</p><p>常用用法：</p><p>查看log.log前200行</p><p><code>cat  log.log | head -n 200</code></p><p>查看test.log倒数200行</p><p><code>cat  test.log | tail -n 200</code></p><p>查看test.log中包含http的所有行</p><p><code>cat  test.log | grep &quot;http&quot;</code></p><p>查看test.log中包含http的所有行，并显示前后行</p><p><code>cat -n test.log | grep -C 5 “http”         (匹配字串那行以及前后5行)</code></p><p><code>cat -n test.log | grep -B 5 “http”         (匹配字串那行以及前5行)</code></p><p><code>cat -n test.log | grep -A 5 “http”         (匹配字串那行以及后5行)</code></p><h3 id="3-grep命令"><a href="#3-grep命令" class="headerlink" title="3. grep命令"></a>3. grep命令</h3><p>grep命令，文本搜索命令，可以使用正则表达式搜索文本<br>用法示例：</p><p>查看test.log中包含http的所有行(-i忽略大小写）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&quot;http&quot;</span> ./test.log</span><br></pre></td></tr></table></figure><h3 id="4-sed命令"><a href="#4-sed命令" class="headerlink" title="4. sed命令"></a>4. sed命令</h3><p>SED 查看某时间段日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/2022-06-02 13:10:30/,/2022-06-02 13:10:40/p&#x27;</span> test.log</span><br></pre></td></tr></table></figure><p>某时间端日志输出到指定文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/2022-06-02 13:10:30/,/2022-06-02 13:10:40/p&#x27;</span> test.log &gt; test20220602.log</span><br></pre></td></tr></table></figure><p>当然还可以使用vi文本编辑命令，less或者more命令进行查看</p><p>正向查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/关键字 按n键把光标移动到下一个符合条件的地方</span><br></pre></td></tr></table></figure><p>反向查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?关键字  按shift+n 键,把光标移动到下一个符合条件的</span><br></pre></td></tr></table></figure><p>日志文件本身还是一个文件，检索命令，编辑命令，查找命令都是可以进行操作的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-在Linux系统中如何统计某个字符串出现的次数&quot;&gt;&lt;a href=&quot;#1-在Linux系统中如何统计某个字符串出现的次数&quot; class=&quot;headerlink&quot; title=&quot;1.在Linux系统中如何统计某个字符串出现的次数&quot;&gt;&lt;/a&gt;1.在Linux系统中</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Linux" scheme="https://gwtt.github.io/tags/Linux/"/>
    
    <category term="指令" scheme="https://gwtt.github.io/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
</feed>
