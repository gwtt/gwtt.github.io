<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>滚~韬的博客</title>
  
  <subtitle>滚~</subtitle>
  <link href="https://gwtt.github.io/atom.xml" rel="self"/>
  
  <link href="https://gwtt.github.io/"/>
  <updated>2022-09-21T15:25:33.058Z</updated>
  <id>https://gwtt.github.io/</id>
  
  <author>
    <name>滚~韬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4/22美团后端实习面经一面</title>
    <link href="https://gwtt.github.io/2022/09/19/4%E6%9C%8822%E6%97%A5%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E4%B8%80%E9%9D%A2/"/>
    <id>https://gwtt.github.io/2022/09/19/4%E6%9C%8822%E6%97%A5%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E4%B8%80%E9%9D%A2/</id>
    <published>2022-09-19T15:15:22.000Z</published>
    <updated>2022-09-21T15:25:33.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h3><blockquote><p>略</p></blockquote><h3 id="2-介绍项目（基本面试官好像都喜欢挖项目）"><a href="#2-介绍项目（基本面试官好像都喜欢挖项目）" class="headerlink" title="2.介绍项目（基本面试官好像都喜欢挖项目）"></a>2.介绍项目（基本面试官好像都喜欢挖项目）</h3><blockquote><p>略，后面补充</p></blockquote><h3 id="3-项目里提到的Mysql，开始展开提问"><a href="#3-项目里提到的Mysql，开始展开提问" class="headerlink" title="3.项目里提到的Mysql，开始展开提问"></a>3.项目里提到的Mysql，开始展开提问</h3><blockquote><p>略</p></blockquote><h3 id="4-mysql的索引引擎，有什么，之间区别"><a href="#4-mysql的索引引擎，有什么，之间区别" class="headerlink" title="4.mysql的索引引擎，有什么，之间区别"></a>4.mysql的索引引擎，有什么，之间区别</h3><blockquote><p>有InnoDB,MyISAM,Memory</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB:"></a>InnoDB:</h2><ul><li>主键自增</li><li>支持外键</li><li>DML操作支持事务</li><li>支持行级锁</li></ul><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM:"></a>MyISAM:</h2><ul><li>支持表锁，不支持行锁</li><li>不支持外键</li><li>不支持事务</li><li>占用空间小，访问速度快</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory:"></a>Memory:</h2><ul><li>内存存放</li><li>支持哈希索引</li></ul></blockquote><h3 id="5-InnoDB采用什么结构存储？为什么？"><a href="#5-InnoDB采用什么结构存储？为什么？" class="headerlink" title="5.InnoDB采用什么结构存储？为什么？"></a>5.InnoDB采用什么结构存储？为什么？</h3><blockquote><p>B+树</p><ol><li>节点排序（用来加快查询速度）    </li><li>一个节点多个元素存取（B树高度不会很高）</li><li>叶子节点有指针（可以方便支持全表扫描，范围查找）</li><li>叶子节点冗余（提升范围查找的效率）</li></ol></blockquote><h3 id="6-B-树存储怎么能确定高度？"><a href="#6-B-树存储怎么能确定高度？" class="headerlink" title="6.B+树存储怎么能确定高度？"></a>6.B+树存储怎么能确定高度？</h3><blockquote><p>InnoDB最小存储单位是页，叶子节点和非叶子节点最小单位都是页，页大小Mysql 默认设定16384字节，约为16KB。我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节<br> 我们一个页中能存放多少这样的索引元素，其实就代表有多少指针，即16384/14=1170;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右</span><br></pre></td></tr></table></figure><p>高度为2的B+树能存放1170×16=18720<br>高度为3的B+树能存放1170×1170×16 = 21902400</p></blockquote><h3 id="7-最左匹配（给举个例子，说出能否用索引）"><a href="#7-最左匹配（给举个例子，说出能否用索引）" class="headerlink" title="7.最左匹配（给举个例子，说出能否用索引）"></a>7.最左匹配（给举个例子，说出能否用索引）</h3><blockquote><p>略</p></blockquote><h3 id="8-mysql中行锁具体怎么锁（当时理解错了，答得MVCC，面试官也是耐心听完了，然后问我，那行锁呢？就很尴尬）"><a href="#8-mysql中行锁具体怎么锁（当时理解错了，答得MVCC，面试官也是耐心听完了，然后问我，那行锁呢？就很尴尬）" class="headerlink" title="8.mysql中行锁具体怎么锁（当时理解错了，答得MVCC，面试官也是耐心听完了，然后问我，那行锁呢？就很尴尬）"></a>8.mysql中行锁具体怎么锁（当时理解错了，答得MVCC，面试官也是耐心听完了，然后问我，那行锁呢？就很尴尬）</h3><blockquote><p>用记录锁、间隙锁、临键锁（都是排他锁）</p><p><strong>(1)记录锁(Record):</strong> 通过主键或唯一索引加锁，锁定某行记录，锁定的是已存在的记录</p><p><strong>(2)间隙锁(Gap):</strong> 锁定的是索引记录中的间隔，锁定的是未存在记录的区间。</p><p><strong>(3)临键锁(Next-key):</strong> 既包含已存在的记录，又包含未存在记录的区间（记录锁+间隙锁）</p><p><strong>锁的触发条件</strong></p><p>1.记录锁(Record)触发条件: 查询的条件中只包含表中存在的记录</p><p>2.间隙锁(Gap)触发条件: 查询的条件中不包含表中任何记录</p><p>3.临键锁(Next-key)触发条件: 查询的条件中既包含表中存在的记录，也包含表中不存在的记录</p></blockquote><h3 id="9-redis在应用时怎么保证数据一致性的（问的是项目里用的时候）"><a href="#9-redis在应用时怎么保证数据一致性的（问的是项目里用的时候）" class="headerlink" title="9.redis在应用时怎么保证数据一致性的（问的是项目里用的时候）"></a>9.redis在应用时怎么保证数据一致性的（问的是项目里用的时候）</h3><blockquote><h4 id="采用延时双删策略"><a href="#采用延时双删策略" class="headerlink" title="采用延时双删策略"></a>采用延时双删策略</h4><p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存</p><h3 id="先更新数据库，再删除缓存（推荐）"><a href="#先更新数据库，再删除缓存（推荐）" class="headerlink" title="先更新数据库，再删除缓存（推荐）"></a>先更新数据库，再删除缓存（推荐）</h3></blockquote><h3 id="10-有没有想过用本地缓存，不用redis（当时不了解memcache，随便说了个更新频繁）"><a href="#10-有没有想过用本地缓存，不用redis（当时不了解memcache，随便说了个更新频繁）" class="headerlink" title="10.有没有想过用本地缓存，不用redis（当时不了解memcache，随便说了个更新频繁）"></a>10.有没有想过用本地缓存，不用redis（当时不了解memcache，随便说了个更新频繁）</h3><blockquote><ol><li>使用ConcurrentHashMap实现本地缓存<br>缓存的本质就是存储在内存中的KV数据结构，对应的就是jdk中线程安全的ConcurrentHashMap，但是要实现缓存，还需要考虑淘汰、最大限制、缓存过期时间淘汰等等功能；</li></ol><p>优点是实现简单，不需要引入第三方包，比较适合一些简单的业务场景。缺点是如果需要更多的特性，需要定制化开发，成本会比较高，并且稳定性和可靠性也难以保障。对于比较复杂的场景，建议使用比较稳定的开源工具。</p><ol start="2"><li>基于Guava Cache实现本地缓存<br>Guava是Google团队开源的一款 Java 核心增强库，包含集合、并发原语、缓存、IO、反射等工具箱，性能和稳定性上都有保障，应用十分广泛。Guava Cache支持很多特性：</li></ol><p>支持最大容量限制<br>支持两种过期删除策略（插入时间和访问时间）<br>支持简单的统计功能<br>基于LRU算法实现</p></blockquote><h3 id="11-接10问，redis一般存哪种数据结构（存的list，所以本地缓存用不了）"><a href="#11-接10问，redis一般存哪种数据结构（存的list，所以本地缓存用不了）" class="headerlink" title="11.接10问，redis一般存哪种数据结构（存的list，所以本地缓存用不了）"></a>11.接10问，redis一般存哪种数据结构（存的list，所以本地缓存用不了）</h3><blockquote><p>存String</p></blockquote><h3 id="12-想没想过redis宕机怎么办？"><a href="#12-想没想过redis宕机怎么办？" class="headerlink" title="12.想没想过redis宕机怎么办？"></a>12.想没想过redis宕机怎么办？</h3><blockquote><p>如果是一台机器，利用AOF和RDB机制进行redis数据恢复</p><p>从机宕机:</p><ul><li>只要把从的redis重新启动，再和主的进行连接就可以</li><li>如果从redis上面做数据的持久化，可以直接连接到主的上面，只要实现增量备份。</li></ul><p>主机宕机:</p><ul><li>先把从的redis升级为主的redis. 执行slave of one命令<br>原来的主的可以重新启动，作为从的redis, 连接到主的redis上面做主从复制。<br>可以使用Redis 提供哨兵 机制来简化上面的操作。</li></ul></blockquote><h3 id="13-了不了解垃圾回收器，说一下CMS的过程？"><a href="#13-了不了解垃圾回收器，说一下CMS的过程？" class="headerlink" title="13.了不了解垃圾回收器，说一下CMS的过程？"></a>13.了不了解垃圾回收器，说一下CMS的过程？</h3><blockquote><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul></blockquote><h3 id="14-FullGC发生的条件？（面试官说应该有三种，只说上两种）"><a href="#14-FullGC发生的条件？（面试官说应该有三种，只说上两种）" class="headerlink" title="14.FullGC发生的条件？（面试官说应该有三种，只说上两种）"></a>14.FullGC发生的条件？（面试官说应该有三种，只说上两种）</h3><blockquote><ol><li>年老代（Tenured）被写满；</li><li>持久代（Perm）被写满；</li><li>System.gc()被显示调用；</li><li>上一次GC之后Heap的各域分配策略动态变化；</li></ol></blockquote><h3 id="15-了解线程池吗？主要参数？"><a href="#15-了解线程池吗？主要参数？" class="headerlink" title="15.了解线程池吗？主要参数？"></a>15.了解线程池吗？主要参数？</h3><blockquote><p>了解</p><p>corePoolSize核心线程数</p><p>maximumPoolSize最大线程数</p><p>keepAliveTime线程空闲时间</p><p>unit时间单位</p><p>workQueue阻塞队列</p><p>threadFactory线程工厂</p><p>handler任务拒绝处理器</p></blockquote><h3 id="16-线程池的执行过程？"><a href="#16-线程池的执行过程？" class="headerlink" title="16.线程池的执行过程？"></a>16.线程池的执行过程？</h3><blockquote><p>当我们利用线程池执行任务时:</p><p>1.如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</p><p>⒉.如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</p><p>3.如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</p><p>4.如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。</p><p>5.当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</p></blockquote><h3 id="17-可重入锁是怎么实现的？"><a href="#17-可重入锁是怎么实现的？" class="headerlink" title="17.可重入锁是怎么实现的？"></a>17.可重入锁是怎么实现的？</h3><blockquote><p>利用AQS实现(AbstractQueueSynchronize)抽象队列同步器</p></blockquote><h3 id="18-由于17问说不知道，提醒出了18问AQS知道吗？（答完之后，面试官说这就是可重入锁实现）"><a href="#18-由于17问说不知道，提醒出了18问AQS知道吗？（答完之后，面试官说这就是可重入锁实现）" class="headerlink" title="18.由于17问说不知道，提醒出了18问AQS知道吗？（答完之后，面试官说这就是可重入锁实现）"></a>18.由于17问说不知道，提醒出了18问AQS知道吗？（答完之后，面试官说这就是可重入锁实现）</h3><blockquote><p>AQS 中有两个重要的东西，一个以Node为节点实现的链表的队列(CHL队列)，还有一个STATE标志，并且通过CAS来改变它的值。</p><p>CLH队列：</p><p>链表结构，在头尾结点中，需要特别指出的是头结点是一个空对象结点，无任何意义，即傀儡结点；</p><p>每一个Node结点都维护了一个指向前驱的指针和指向后驱的指针，结点与结点之间相互关联构成链表；</p><p>入队在尾，出队在头，出队后需要激活该出队结点的后继结点，若后继结点为空或后继结点waitStatus&gt;0，则从队尾向前遍历取waitStatus&lt;0的触发阻塞唤醒；</p><p>队列中节点状态值（waitStatus，只能为以下值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量：表示节点的线程是已被取消的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"><span class="comment">//常量：表示当前节点的后继节点的线程需要被唤醒</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//常量：表示线程正在等待某个条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//常量：表示下一个共享模式的节点应该无条件的传播下去</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br></pre></td></tr></table></figure></blockquote><h3 id="19-CAS是什么"><a href="#19-CAS是什么" class="headerlink" title="19.CAS是什么"></a>19.CAS是什么</h3><blockquote><p>CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。</p><p>CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p><p>ps:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题:</span><br><span class="line">①.CAS容易造成ABA问题。一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。</span><br><span class="line">②.CAS造成CPU利用率增加。之前说过了CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。</span><br></pre></td></tr></table></figure></blockquote><h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><h3 id="20-打算实习时间"><a href="#20-打算实习时间" class="headerlink" title="20.打算实习时间"></a>20.打算实习时间</h3><blockquote><p>大约寒假就可以开始</p></blockquote><p>转载<a href="https://blog.nowcoder.net/n/18665b426d354fba9064db4f2af43863">美团Java后端实习面经（一二面），已接offer~_牛客博客 (nowcoder.net)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-自我介绍&quot;&gt;&lt;a href=&quot;#1-自我介绍&quot; class=&quot;headerlink&quot; title=&quot;1.自我介绍&quot;&gt;&lt;/a&gt;1.自我介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-介绍项目（基本面试官好</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程和操作系统的线程有啥区别</title>
    <link href="https://gwtt.github.io/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/"/>
    <id>https://gwtt.github.io/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/</id>
    <published>2022-09-17T09:38:23.000Z</published>
    <updated>2022-09-19T15:04:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-用户空间和内核空间"><a href="#1-用户空间和内核空间" class="headerlink" title="1. 用户空间和内核空间"></a><strong>1. 用户空间和内核空间</strong></h2><blockquote><p>至于什么是系统空间和用户空间也非常好理解：在操作系统中，内存通常会被分成用户空间（User space）与内核空间（Kernel space）这两个部分。当进程/线程运行在用户空间时就处于用户态，运行在内核空间时就处于内核态：</p><ul><li>运行在内核态的程序可以访问用户空间和内核空间，或者说它可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等</li><li>而应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问用户空间</li></ul><p><strong>那为什么要区分用户态和内核态呢</strong>？</p><p>其实早期操作系统是不区分用户态和内核态的，也就是说应用程序可以访问任意内存空间，如果程序不稳定常常会让系统崩溃，比如清除了操作系统的内存数据。为此大佬们设计出了一套规则：对于那些比较危险的操作需要切到内核态才能运行，比如 CPU、内存、设备等资源管理器程序就应该在内核态运行，否则安全性没有保证。</p><p>举个例子，对于文件系统和数据来说，文件系统数据和管理就必须放在内核态，但是用户的数据和管理可以放在用户态。</p><p><strong>用户态的程序不能随意操作内核地址空间，这样有效地防止了操作系统程序受到应用程序的侵害</strong>。</p><p>那如果处于用户态的程序想要访问内核空间的话怎么办呢？就需要进行系统调用从用户态切换到内核态。</p></blockquote><h2 id="2-操作系统线程"><a href="#2-操作系统线程" class="headerlink" title="2. 操作系统线程"></a><strong>2. 操作系统线程</strong></h2><h3 id="①-在用户空间中实现线程"><a href="#①-在用户空间中实现线程" class="headerlink" title="① 在用户空间中实现线程"></a><strong>① 在用户空间中实现线程</strong></h3><p>在<strong>早期</strong>的操作系统中，所有的线程都是在用户空间下实现的，操作系统只能看到线程所属的进程，而不能看到线程。</p><p><img src="/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/1620.png" alt="img"></p><p>从我们开发者的角度来理解用户级线程就是说：在这种模型下，我们需要自己定义线程的数据结构、创建、销毁、调度和维护等，这些线程运行在操作系统的某个进程内，然后操作系统直接对进程进行调度。</p><p>这种方式的好处一目了然，首先第一点，就是即使操作系统原生不支持线程，我们也可以通过库函数来支持线程；第二点，线程的调度只发生在用户态，避免了操作系统从内核态到用户态的转换开销。</p><p>当然缺点也很明显：由于操作系统看不见线程，不知道线程的存在，而 CPU 的时间片切换是以进程为维度的，所以如果进程中某个线程进行了耗时比较长的操作，那么由于用户空间中没有时钟中断机制，就会导致此进程中的其它线程因为得不到 CPU 资源而长时间的持续等待；另外，如果某个线程进行系统调用时比如缺页中断而导致了线程阻塞，此时操作系统也会阻塞住整个进程，即使这个进程中其它线程还在工作。</p><h3 id="②-在内核空间中实现线程"><a href="#②-在内核空间中实现线程" class="headerlink" title="② 在内核空间中实现线程"></a><strong>② 在内核空间中实现线程</strong></h3><blockquote><p>所谓内核级线程就是运行在内核空间的线程， 直接由内核负责，只能由内核来完成线程的调度。</p><p>几乎所有的<strong>现代</strong>操作系统，包括 Windows、Linux、Mac OS X 和 Solaris 等，都支持内核线程。</p><p>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，<strong>支持多线程的内核就叫做多线程内核</strong>（Multi-Threads Kernel）。</p><p>从我们开发者的角度来理解内核级线程就是说：我们可以直接使用操作系统中已经内置好的线程，线程的创建、销毁、调度和维护等，都是直接由操作系统的内核来实现，我们只需要使用系统调用就好了，不需要像用户级线程那样自己设计线程调度等。</p></blockquote><p><img src="/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/1620-1663408134188-3.png" alt="img"></p><p>上图画的是 1：1 的线程模型，所谓线程模型，也就是用户线程和内核线程之间的关联方式，线程模型当然不止 1：1 这一种，下面我们来详细解释以下这三种多线程模型：</p><p>1）<strong>多对一线程模型</strong>：</p><p><img src="/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/1620-1663408160035-6.png" alt="img"></p><ul><li>在多对一模型中，多个用户级线程映射到某一个内核线程上</li><li>线程管理由用户空间中的线程库处理，这非常有效</li><li>但是，如果进行了阻塞系统调用，那么即使其他用户线程能够继续，整个进程也会阻塞</li><li>由于单个内核线程只能在单个 CPU 上运行，因此多对一模型不允许在多个 CPU 之间拆分单个进程</li></ul><p>从并发性角度来总结下，虽然多对一模型允许开发人员创建任意多的用户线程，但是由于内核只能一次调度一个线程，所以并未增加并发性。现在已经几乎没有操作系统来使用这个模型了，因为它无法利用多个处理核。</p><p>2）<strong>一对一线程模型</strong>：</p><p><img src="/2022/09/17/Java%20%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/1620-1663408160035-7.png" alt="img"></p><ul><li>一对一模型克服了多对一模型的问题</li><li>一对一模型创建一个单独的内核线程来处理每个用户线程</li><li>但是，管理一对一模型的开销更大，涉及更多开销和减慢系统速度</li><li>此模型的大多数实现都限制了可以创建的线程数</li></ul><p>从并发性角度来总结下，虽然一对一模型提供了更大的并发性，但是开发人员应注意不要在应用程序内创建太多线程（有时系统可能会限制创建线程的数量），因为管理一对一模型的开销更大。<strong>Windows (从 Win95 开始) 和 Linux 都实现了线程的一对一模型</strong>。</p><p>3）<strong>多对多线程模型</strong>：</p><p>![img](Java 线程和操作系统的线程有啥区别/1620-1663408160035-8.png)</p><ul><li>多对多模型将任意数量的用户线程复用到相同或更少数量的内核线程上，结合了一对一和多对一模型的最佳特性</li><li>用户对创建的线程数没有限制</li><li>阻止内核系统调用不会阻止整个进程</li><li>进程可以分布在多个处理器上</li><li>可以为各个进程分配可变数量的内核线程，具体取决于存在的 CPU 数量和其他因素</li></ul><h2 id="3-Java-线程"><a href="#3-Java-线程" class="headerlink" title="3. Java 线程"></a><strong>3. Java 线程</strong></h2><blockquote><p>在进入 Java 线程主题之前，有必要讲解一下<strong>线程库</strong> Thread library 的概念。</p><p>在上面的模型介绍中，我们提到了通过线程库来创建、管理线程，那么什么是线程库呢？</p><p><strong>线程库就是为开发人员提供创建和管理线程的一套 API</strong>。</p><p>当然，线程库不仅可以在用户空间中实现，还可以在内核空间中实现。前者涉及仅在用户空间内实现的 API 函数，没有内核支持。后者涉及系统调用，也就是说调用库中的一个 API 函数将会导致对内核的系统调用，并且需要具有线程库支持的内核。</p><p>下面简单介绍下三个主要的线程库：</p><p>1）POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展</p><p>2）Win32 线程：用于 Window 操作系统的内核级线程库</p><p>3）Java 线程：<strong>Java 线程 API 通常采用宿主系统的线程库来实现</strong>，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。</p><p>下面我们来详细讲解 Java 线程：</p><p>事实上，<strong>在 JDK 1.2 之前</strong>，Java 线程是基于称为 “绿色线程”（Green Threads）的用户级线程实现的，也就是说程序员大佬们为 JVM 开发了自己的一套线程库或者说线程管理机制。</p><p>而<strong>在 JDK 1.2 及以后</strong>，JVM 选择了更加稳定且方便使用的操作系统原生的内核级线程，通过系统调用，将线程的调度交给了操作系统内核。而对于不同的操作系统来说，它们本身的设计思路基本上是完全不一样的，因此它们各自对于线程的设计也存在种种差异，所以 JVM 中明确声明了：<strong>虚拟机中的线程状态，不反应任何操作系统中的线程状态</strong>。</p><p>也就是说，在 JDK 1.2 及之后的版本中，Java 的线程很大程度上依赖于操作系统采用什么样的线程模型，这点在不同的平台上没有办法达成一致，JVM 规范中也并未限定 Java 线程需要使用哪种线程模型来实现，可能是一对一，也可能是多对多或多对一。</p><p>总结来说，回答下文题，<strong>现今 Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，比如在 Windows 中 Java 就是基于 Wind32 线程库来管理线程，且 Windows 采用的是一对一的线程模型</strong>。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-java线程是操作系统的线程吗，调度也是依据操作系统调度吗"><a href="#1-java线程是操作系统的线程吗，调度也是依据操作系统调度吗" class="headerlink" title="1.java线程是操作系统的线程吗，调度也是依据操作系统调度吗"></a>1.java线程是操作系统的线程吗，调度也是依据操作系统调度吗</h3><blockquote><p>现今 Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现</p></blockquote><p>[转载]Java 线程和操作系统的线程有啥区别？ - 腾讯云开发者社区-腾讯云 (tencent.com)](<a href="https://cloud.tencent.com/developer/article/1818151">https://cloud.tencent.com/developer/article/1818151</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-用户空间和内核空间&quot;&gt;&lt;a href=&quot;#1-用户空间和内核空间&quot; class=&quot;headerlink&quot; title=&quot;1. 用户空间和内核空间&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 用户空间和内核空间&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;至于</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈CMS和G1收集器</title>
    <link href="https://gwtt.github.io/2022/09/16/%E6%B5%85%E8%B0%88CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://gwtt.github.io/2022/09/16/%E6%B5%85%E8%B0%88CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2022-09-16T12:38:23.000Z</published>
    <updated>2022-09-17T09:29:09.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><h3 id="1-什么是CMS收集器"><a href="#1-什么是CMS收集器" class="headerlink" title="1.什么是CMS收集器"></a>1.什么是CMS收集器</h3><blockquote><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>从名字（包含 “Mark Sweep”）上就可以看出，CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤,包括:</p><ul><li>初始标记(CMS initial mark)</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)</li><li>并发清除(CMS concurrent sweep)</li></ul><p>其中，初始标记、重新标记这两个步骤需要“Stop the World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>CMS是一款优秀的收集器，它的主要优点在名字上就已经体现出来了: 并发收集、低停顿，Sum公司文档也会称为Concurrent Low Pause Collector(并发低停顿收集器)</p></blockquote><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.<strong>优点</strong></h3><blockquote><ul><li>并发收集</li><li>低停顿</li></ul></blockquote><h3 id="3-CMS收集器缺点"><a href="#3-CMS收集器缺点" class="headerlink" title="3.CMS收集器缺点"></a>3.CMS收集器<strong>缺点</strong></h3><blockquote><ul><li>CMS收集器对CPU资源非常敏感。</li></ul><blockquote><p>在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p></blockquote><ul><li>CMS收集器无法处理浮动垃圾（Floating Garbage)。</li></ul><blockquote><p>可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行者，伴随程序运行自然有不断的垃圾不断的产生，这些垃圾只能留在下一次GC才能清理掉。</p></blockquote><ul><li>CMS收集器是基于标记-清除算法，该算法的缺点都有。</li></ul><blockquote><p>收集结束时会有大量空间碎片。</p><p>标记和清除两个过程的效率都不高。</p></blockquote></blockquote><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><h3 id="1-什么是G1收集器"><a href="#1-什么是G1收集器" class="headerlink" title="1.什么是G1收集器"></a>1.什么是G1收集器</h3><blockquote><p>G1(Garbage-First)收集器是当今收集器技术发展的最前沿成果之一，早在JDK1.7刚刚确立项目目标，Sum公司给出的JDK1.7 RoadMap里面，它就被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。从JDK 6u14中开始就有Early Access版本的G1收集器共开发人员实验和试用，由此开始G1收集器的“Experimental”状态持续了数年时间，直至JDK7u4，Sum公司才认为它达到足够成熟的商用程度，移除了“Experimental“的标识。</p><p><strong>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</strong></p></blockquote><h3 id="2-优点-1"><a href="#2-优点-1" class="headerlink" title="2.优点"></a>2.优点</h3><blockquote><ul><li>并发与并行</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</span><br></pre></td></tr></table></figure><ul><li>分代收集</li><li>空间整合</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与CMS的标记-清除算法不同，G1从整体来看是基于标记-整理算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</span><br></pre></td></tr></table></figure><ul><li>可预测的停顿</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。</span><br></pre></td></tr></table></figure><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p><p><img src="/2022/09/16/%E6%B5%85%E8%B0%88CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/16ded186e15f5871tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="G1堆的Region布局.png"></p><p>G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。Region的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的Region，这一点可以参看如下<a href="https://link.juejin.cn/?target=http://hg.openjdk.java.net/jdk/jdk/file/fa2f93f99dbc/src/hotspot/share/gc/g1/heapRegionBounds.hpp">源码</a>。其实这个数字既可以手动调整，G1也会根据堆大小自动进行调整。</p><p><strong>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</p><p>对于打算从CMS或者ParallelOld收集器迁移过来的应用，按照官方的建议，如果发现符合如下特征，可以考虑更换成G1收集器以追求更佳性能：</p><ul><li>实时数据占用了超过半数的堆空间；</li><li>对象分配率或“晋升”的速度变化明显；</li><li>期望消除耗时较长的GC或停顿（超过0.5——1秒）。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Applications running today with either the CMS or the ParallelOld garbage collector would benefit switching to G1 if the application has one or more of the following traits.</span><br><span class="line"></span><br><span class="line">More than 50% of the Java heap is occupied with live data.</span><br><span class="line">The rate of object allocation rate or promotion varies significantly.</span><br><span class="line">Undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-运行过程"><a href="#3-运行过程" class="headerlink" title="3.运行过程"></a>3.运行过程</h3><blockquote><p><strong>G1收集的运作过程大致如下：</strong></p><ul><li><strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，<strong>这阶段需要<code>停顿线程</code>，但耗时很短</strong>。</li><li><strong>并发标记（Concurrent Marking）</strong>：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，<strong>这阶段耗时较长</strong>，但可与用户程序并发执行。</li><li><strong>最终标记（Final Marking）</strong>：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，<strong>这阶段需要<code>停顿线程</code>，但是可并行执行</strong>。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong>：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ul><p>全局变量和栈中引用的对象是可以列入根集合的，这样在寻找垃圾时，就可以从根集合出发扫描堆空间。在G1中，引入了一种新的能加入根集合的类型，就是<code>记忆集</code>（Remembered Set）。Remembered Sets（也叫RSets）用来跟踪对象引用。G1的很多开源都是源自Remembered Set，例如，它通常约占Heap大小的20%或更高。并且，我们进行对象复制的时候，因为需要扫描和更改Card Table的信息，这个速度影响了复制的速度，进而影响暂停时间。</p><p><img src="/2022/09/16/%E6%B5%85%E8%B0%88CMS%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8/16ded186e1757662tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="image.png"></p></blockquote><h2 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h2><blockquote><h3 id="卡表（Card-Table）"><a href="#卡表（Card-Table）" class="headerlink" title="卡表（Card Table）"></a>卡表（Card Table）</h3><p>有个场景，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为GC Roots。那不是得又做全堆扫描？成本太高了吧。</p><p>HotSpot给出的解决方案是一项叫做<code>卡表</code>（Card Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。</p><p>在进行Minor GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。</p><p>想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。</p><p><strong>卡表能用于减少老年代的全堆空间扫描，这能很大的提升GC效率</strong>。</p></blockquote><h2 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h2><blockquote><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的数据结构。</p><p>如果我们不考虑效率和成本问题，我们可以用一个数组存储所有有指针指向新生代的老年代对象。但是如果这样的话我们维护成本就很好，打个比方，假如所有的老年代对象都有指针指向了新生代，那么我们需要维护整个老年代大小的记忆集，毫无疑问这种方法是不可取的。因此我们引入了卡表的数据结构</p></blockquote><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><blockquote><p>我们每次对引用进行改变时，我们在程序中并没有手动去维护卡表的信息，那么卡表信息的维护到底是如何进行的呢，这就依赖于我们的写屏障功能。</p><p>写屏障可以理解为对于我们引用类型字段复制的AOP操作。在赋前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的部分的写屏障叫作写后屏障（PostWrite Barrier）。</p></blockquote><h2 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h2><blockquote><p>由于CPU集成的多级缓存中是以缓存行来读取数据的，通过MESI协议保证多个CPU之间的缓存一致性。<br>伪共享问题是卡表元素更改时处于同一缓存行导致的，诱发的因素是不同卡页内的对象发生了跨代引用，从而使CPU并行执行变为串行执行，降低了并发性能。</p><p>举例： 若a、b位于同一缓存行，当CPU1修改a后，若CPU2想修改b，必须先提交CPU1的缓存，然后CPU2再去主存中读取数据。</p><p>伪共享问题解决方案：JAVA中的解决方案有填充法 和 Contended 注解。</p><p>填充法：就是 扩大对象的大小，这样，就可以一个缓冲行中，<strong>只存在一个对象</strong>！这样，就不会导致结果是串行执行了！(JDK8之前)<br>Contended 注解法：Java1.8 中提供了Contended注解，使用这个注解，VM必须设置 -XX:-RestrictContended。<br>ConcurrentHashMap的内部类CounterCell有用到这个注解</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CMS收集器&quot;&gt;&lt;a href=&quot;#CMS收集器&quot; class=&quot;headerlink&quot; title=&quot;CMS收集器&quot;&gt;&lt;/a&gt;CMS收集器&lt;/h2&gt;&lt;h3 id=&quot;1-什么是CMS收集器&quot;&gt;&lt;a href=&quot;#1-什么是CMS收集器&quot; class=&quot;header</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>9/16华为技术面</title>
    <link href="https://gwtt.github.io/2022/09/16/9%E6%9C%8816%E6%97%A5%E5%8D%8E%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%9D%A2/"/>
    <id>https://gwtt.github.io/2022/09/16/9%E6%9C%8816%E6%97%A5%E5%8D%8E%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%9D%A2/</id>
    <published>2022-09-16T02:45:22.000Z</published>
    <updated>2022-09-19T15:01:10.424Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java的跨平台的机制是什么？"><a href="#1-Java的跨平台的机制是什么？" class="headerlink" title="1. Java的跨平台的机制是什么？"></a>1. Java的跨平台的机制是什么？</h3><blockquote><p><em>java语言编写的程序,一次编译后,可以在多个系统平台上运行</em></p><p>Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序</p></blockquote><h3 id="2-JVM-内存是怎么管理的？"><a href="#2-JVM-内存是怎么管理的？" class="headerlink" title="2. JVM  内存是怎么管理的？"></a>2. JVM  内存是怎么管理的？</h3><blockquote><p>堆，方法区，程序计数器，虚拟机栈，本地方法栈</p></blockquote><h3 id="3-GC-一般在什么时候触发？"><a href="#3-GC-一般在什么时候触发？" class="headerlink" title="3.GC  一般在什么时候触发？"></a>3.GC  一般在什么时候触发？</h3><blockquote><ul><li>Young GC 一般是在新生代的 Eden 区满了之后触发的</li><li>Full GC<ol><li>年老代（Tenured）被写满；</li><li>持久代（Perm）被写满；</li><li>System.gc()被显示调用；</li><li>上一次GC之后Heap的各域分配策略动态变化；</li></ol></li></ul></blockquote><h3 id="4-调用GC（System-gc-）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？"><a href="#4-调用GC（System-gc-）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？" class="headerlink" title="4. 调用GC（System.gc()）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？"></a>4. 调用GC（System.gc()）之后会立即触发吗？如果立马触发的话，会导致频繁回收，又会带来什么问题？</h3><p> 如果不是，是什么机制来保障的（finalize）</p><blockquote><p>不会立马触发。甚至可能不会垃圾回收。</p><p>造成系统卡顿</p><p>用justRanFinalization来保障System.gc()执不执行</p></blockquote><h3 id="5-Java-有了-GC-之后还会有内存泄漏问题吗？"><a href="#5-Java-有了-GC-之后还会有内存泄漏问题吗？" class="headerlink" title="5. Java  有了  GC  之后还会有内存泄漏问题吗？"></a>5. Java  有了  GC  之后还会有内存泄漏问题吗？</h3><blockquote><ol><li><p>静态集合类泄漏<br>静态集合类像HashMap，Vector等的使用最容易出现内存泄漏，静态变量的声明周期与应用程序一直，所有的对象Object也不能内释放，因为被其他对象引用着。</p></li><li><p>单例造成的泄漏</p><p>单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</p></li><li><p>各种连接<br>数据库连接，网络连接，IO连接等没有显式调用close()关闭，会导致内存泄漏。</p></li><li><p>监听器的使用<br>在释放对象的同时，没有删除相应监听器，也会造成内存泄漏。</p></li></ol></blockquote><h3 id="6-哪些可以作为-GC-Roots-？"><a href="#6-哪些可以作为-GC-Roots-？" class="headerlink" title="6. 哪些可以作为  GC Roots  ？"></a>6. 哪些可以作为  GC Roots  ？</h3><blockquote><ol><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ol></blockquote><h3 id="7-String-类型不可修改，为什么呢？字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？非要改String类型的值，能改的到吗？new一个String对象，是放在哪里的？StringBuilder和StringBuffer有什么区别？"><a href="#7-String-类型不可修改，为什么呢？字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？非要改String类型的值，能改的到吗？new一个String对象，是放在哪里的？StringBuilder和StringBuffer有什么区别？" class="headerlink" title="7. String  类型不可修改，为什么呢？字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？非要改String类型的值，能改的到吗？new一个String对象，是放在哪里的？StringBuilder和StringBuffer有什么区别？"></a>7. String  类型不可修改，为什么呢？字符串常量，或者new一个String对象，创建对象的时候有什么差异吗？非要改String类型的值，能改的到吗？new一个String对象，是放在哪里的？StringBuilder和StringBuffer有什么区别？</h3><blockquote><p>String不可变是因为字符数组被final和private修饰。并且String没有提供可以修改字符数组的API</p><p>new一个对象时指向堆里面的，字符串常量时指向方法区里的字符串常量池</p><p>反射可以修改（不是声明底层字段会失败）</p><p>放在堆里（Heap）</p><p>一个线程不安全一个线程安全</p></blockquote><h3 id="8-反射机制有了解吗？反射创建对象和new创建对象有什么区别？反射和new的性能哪个更高一点？"><a href="#8-反射机制有了解吗？反射创建对象和new创建对象有什么区别？反射和new的性能哪个更高一点？" class="headerlink" title="8.  反射机制有了解吗？反射创建对象和new创建对象有什么区别？反射和new的性能哪个更高一点？"></a>8.  反射机制有了解吗？反射创建对象和new创建对象有什么区别？反射和new的性能哪个更高一点？</h3><blockquote><p>有</p><p>new属于静态编译<br>反射属于动态编译，意思就说只有到运行时才会去获得该对象的实例,Spring就是使用的反射</p><p>new性能更高</p></blockquote><h3 id="9-多线程了解吗？通过什么类来实现？"><a href="#9-多线程了解吗？通过什么类来实现？" class="headerlink" title="9. 多线程了解吗？通过什么类来实现？"></a>9. 多线程了解吗？通过什么类来实现？</h3><blockquote><p>了解</p><p>主要通过Thread类</p></blockquote><h3 id="10-设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）"><a href="#10-设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）" class="headerlink" title="10. 设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便管理类、分工开发）"></a>10. 设计模式有了解吗？用了这些模式，带来的好处是什么？为什么要用这些设计模式（方便<a href>管理类</a>、分工开发）</h3><blockquote><p>​    了解</p><ul><li>方便重用，方便移植</li><li>方便阅读，方便他人了解</li><li>代码可靠性更高，降低错误发生</li><li>节省写项目的时间</li></ul></blockquote><h3 id="11-Redis-和大型数据库有什么区别？为什么要用这个数据库（Redis）"><a href="#11-Redis-和大型数据库有什么区别？为什么要用这个数据库（Redis）" class="headerlink" title="11.Redis  和大型数据库有什么区别？为什么要用这个数据库（Redis）"></a>11.Redis  和大型数据库有什么区别？为什么要用这个<a href>数据</a>库（Redis）</h3><blockquote><ul><li>Redis是非关系型数据库，Mysql是关系型数据库</li><li>Mysql持久化到硬盘中，读取较慢，Redis数据存储到内存中，读取速度快</li></ul><p>为什么要用:</p><p>反复连接数据库需要花费很多时间，从而导致<strong>运行效率过慢</strong>，反复连接也会导致<strong>数据库负载变高</strong>。由于Redis是基于内存操作，所以<code>CPU不是性能瓶颈</code>，机器的<code>内存和宽带才是Redis的瓶颈</code>，所以用Redis可以减少访问数据库的次数，提高运行效率。</p></blockquote><h3 id="12-编码的时候，会做网络字节序转换，大小端转换，为什么要做这个转换呢？-（不会）"><a href="#12-编码的时候，会做网络字节序转换，大小端转换，为什么要做这个转换呢？-（不会）" class="headerlink" title="12. 编码的时候，会做网络字节序转换，大小端转换，为什么要做这个转换呢？   （不会）"></a>12. 编码的时候，会做网络字节序转换，大小端转换，为什么要做这个转换呢？   （不会）</h3><blockquote><p> 因为不同的计算机都有自己的主机字节序，为了保证数据传输的统一性，就是让数据在所有计算机上都以一种通用形式呈现，所以会作网络字节序转换。</p><p>TCP/IP协议规定使用“大端”字节序作为网络字节序。</p></blockquote><h3 id="13-ICMP-协议，有了解吗？"><a href="#13-ICMP-协议，有了解吗？" class="headerlink" title="13.  ICMP  协议，有了解吗？"></a>13.  ICMP  协议，有了解吗？</h3><blockquote><p>ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><p>它的功能是报告无法传送的数据包的错误，并帮助对这些错误进行疑难解答。</p><p>典型应用:PING,traceroute（检查路由（路径）并测量跨Internet协议（IP）网络的传输延迟数据包的工具）</p></blockquote><h3 id="14-HTTP-和-HTTPS-的区别是什么？"><a href="#14-HTTP-和-HTTPS-的区别是什么？" class="headerlink" title="14. HTTP  和  HTTPS  的区别是什么？"></a>14. HTTP  和  HTTPS  的区别是什么？</h3><blockquote><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></blockquote><h3 id="15-数字证书使用了什么机制？数字证书为什么被创建？"><a href="#15-数字证书使用了什么机制？数字证书为什么被创建？" class="headerlink" title="15. 数字证书使用了什么机制？数字证书为什么被创建？"></a>15. 数字证书使用了什么机制？数字证书为什么被创建？</h3><blockquote><p>数字证书采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。用于加密和验证签名。当发送一份保密文件时，发送方使用接收方的公钥对数据加密，而接收方则使用自己的私钥解密，这样信息就可以安全无误地到达目的地了。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。</p><p>为了防止信息泄露，所以必须保证网络安全的四大要素:</p><ul><li>信息传输的保密性</li><li>数据交换的完整性</li><li>发送信息的不可否认性</li><li>交易者身份的确定性</li></ul><p>所以创建数字证书</p></blockquote><p>摘自华为面经-Java-西安_笔经面经_牛客网(<a href="https://www.nowcoder.com/discuss/1053917">https://www.nowcoder.com/discuss/1053917</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Java的跨平台的机制是什么？&quot;&gt;&lt;a href=&quot;#1-Java的跨平台的机制是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Java的跨平台的机制是什么？&quot;&gt;&lt;/a&gt;1. Java的跨平台的机制是什么？&lt;/h3&gt;&lt;blockquote</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Lambda表达式</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-09-14T11:14:23.000Z</published>
    <updated>2022-09-14T11:24:58.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Lambda表达式？"><a href="#什么是Lambda表达式？" class="headerlink" title="什么是Lambda表达式？"></a>什么是Lambda表达式？</h4><blockquote><p>可以将Lambda表达式理解为一个匿名函数； Lambda表达式允许将一个函数作为另外一个函数的参数； 我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码作为实参）,也可以理解为函数式编程，将一个函数作为参数进行传递。</p></blockquote><h4 id="2-为什么要引入Lambda表达式？"><a href="#2-为什么要引入Lambda表达式？" class="headerlink" title="2. 为什么要引入Lambda表达式？"></a>2. 为什么要引入Lambda表达式？</h4><blockquote><p>当java程序员看到其他语言的程序员（如JS，Python）在使用闭包或者Lambda表达式的时候，于是开始吐槽世界上使用最广的语言居然不支持函数式编程。千呼万唤，Java8推出了Lambda表达式。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.isea.java;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">       thread.start();</span><br><span class="line">       thread.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使这段代码变得更加简洁，可以使用匿名内部类重构一下（注意代码中的注释）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.isea.java;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="comment">//这里的new Runnable()，这里new 了接口，在这个new的接口里面，我们写了这个接口的实现类。</span></span><br><span class="line">        <span class="comment">//这里可以看出，我们把一个重写的run()方法传入了一个构造函数中。</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Lambda表达式的分类"><a href="#3-Lambda表达式的分类" class="headerlink" title="3. Lambda表达式的分类"></a>3. Lambda表达式的分类</h4><h5 id="1-无参无返回值"><a href="#1-无参无返回值" class="headerlink" title="1. 无参无返回值"></a>1. 无参无返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="2-有参无返回值"><a href="#2-有参无返回值" class="headerlink" title="2. 有参无返回值"></a>2. 有参无返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;AAAAA&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;BBBBB&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;CCCCC&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;DDDDD&quot;</span>);</span><br><span class="line"><span class="comment">//形参的类型是确定的，可省略；只有一个形参，()可以省略；</span></span><br><span class="line">        list.forEach(t -&gt; System.out.print(t + <span class="string">&quot;\t&quot;</span>));</span><br><span class="line"><span class="comment">//或者更简洁的方法引用：list.forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//打印结果：AAAAABBBBBCCCCCDDDDD</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span></span><br></pre></td></tr></table></figure></blockquote><p>forEach() 功能等同与增强型for循环 这个方法来自于Iterable接口，Collection接口继承了这个接口，List又继承了Collection接口，而ArrayList是List的实现类；forEach函数，指明该函数需要传入一个函数，而且是有参数没有返回值的函数，而Consumer接口中正好有且仅有一个这样的有参无返回值的抽象方法。接下来，我们会了解到这是使用Lambda的必要条件。</p><h5 id="3-无参有返回值"><a href="#3-无参有返回值" class="headerlink" title="3. 无参有返回值"></a>3. 无参有返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.generate(() -&gt;random.nextInt(<span class="number">100</span>));</span><br><span class="line">        stream.forEach(t -&gt; System.out.println(t));</span><br><span class="line">    &#125;<span class="comment">//只有一个return，可以省略return；该方法将会不断的打印100以内的正整数。</span></span><br><span class="line">&#125;<span class="comment">//Stream.generate()方法创建无限流，该方法要求传入一个无参有返回值的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> <span class="comment">//来自源码</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="4-有参有返回值"><a href="#4-有参有返回值" class="headerlink" title="4. 有参有返回值"></a>4. 有参有返回值</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.Collator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collator</span> <span class="variable">collator</span> <span class="operator">=</span> Collator.getInstance();</span><br><span class="line">        TreeSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((s1,s2) -&gt; collator.compare(s1.getName(),s2.getName()));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">10</span>,<span class="string">&quot;张飞&quot;</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;周瑜&quot;</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>));</span><br><span class="line">        set.forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这里的Collator是一个抽象类，但是提供了获取该类实例的方法getInstance()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        Home | This.ID = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-函数式接口"><a href="#4-函数式接口" class="headerlink" title="4. 函数式接口"></a>4. 函数式接口</h4><blockquote><p>即SAM（Single Abstract Method ）接口，有且只有一个抽象方法的接口（可以有默认方法或者是静态方法和从Object继承来的方法，但是抽象方法有且只能有一个）。 JDK1.8之后，添加@FunctionalInterface表示这个接口是是一个函数式接口，因为有了@functionalInterface标记，也称这样的接口为Mark（标记）类型的接口。举例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">java.lang.Runnable&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line">java.lang.Comparator&lt;T&gt;&#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面的例子，比方说这个Runnable接口是支持Lambda表达式，那么如果有一个方法（比如Thread类的构造函数）需要传入一个Runnable接口的实现类的话，那么就可以直接把Lambda表达式写进去。</p><p>换个角度说TreeSet，它有一个构造函数中是要求传入一个接口类型，如果这个接口类型恰好是函数式接口，那么直接传进去一个Lambda表达式即可。</p><p><strong>函数式接口作用</strong></p><blockquote><p>函数式接口能够接受匿名内部类的实例化对象，换句话说，我们可以使用匿名内部类来实例化函数式接口的对象，而Lambda表达式能够代替内部类实现代码的进一步简化，因此，Lambda表达式和函数式接口紧密的联系到了一起，接下来的这句话非常的重要：</p><p>每一个Lambda表达式能隐式的给函数式接口赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>)).start();</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>编译器会认为Thread()中传入的是一个Runnable的对象，而我们利用IDEA的智能感知，鼠标指向“-&gt;”或“（）”的时候，会发现这是一个Runnable类型，实际上编译器会自动将Lambda表达式赋值给函数式接口，在本例中就是Runnable接口。本例中Lambda表达式将打印方法传递给了Runnable接口中的run（）方法，从而形成真正的方法体。</p><p>而且，参数与返回值是一一对应的，即如果函数式接口中的抽象方法是有返回值，有参数的，那么要求Lambda表达式也是有返回值，有参数的（余下类推）</p></blockquote><blockquote><p><strong>四大函数式接口：</strong></p><p>有时候后，如果我们调用某一个方法，发现这个方法中需要传入的参数要求是一个函数式的接口，那么我们可以直接传入Lambda表达式。这些接口位于java.util.function包下，需要注意一下，java.util包和java.util.function包这两个包没有什么关系，切不可以为function包是java.util包下面的包。</p><ol><li>消费型接口：Consumer&lt; T&gt; void accept(T t)有参数，无返回值的抽象方法；</li><li>供给型接口：Supplier &lt; T&gt; T get() 无参有返回值的抽象方法；</li><li>断定型接口： Predicate&lt; T&gt; boolean test(T t):有参，但是返回值类型是固定的boolean</li><li>函数型接口： Function&lt; T，R&gt; R apply(T t)有参有返回值的抽象方法；</li></ol></blockquote><h4 id="5-新日期时间API-补充"><a href="#5-新日期时间API-补充" class="headerlink" title="5. 新日期时间API(补充)"></a>5. 新日期时间API(补充)</h4><blockquote><h4 id="1-LocalDate-只有年月日"><a href="#1-LocalDate-只有年月日" class="headerlink" title="1. LocalDate(只有年月日)"></a>1. LocalDate(只有年月日)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDate_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(date.getYear()+<span class="string">&quot; &quot;</span>+date.getMonthValue()+<span class="string">&quot; &quot;</span>+date.getDayOfMonth());</span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-LocalTime-只有时分秒"><a href="#2-LocalTime-只有时分秒" class="headerlink" title="2 . LocalTime(只有时分秒)"></a>2 . LocalTime(只有时分秒)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(time.getHour()+<span class="string">&quot; &quot;</span>+time.getMinute()+<span class="string">&quot; &quot;</span>+time.getSecond());</span><br><span class="line">        System.out.println(time.toString());</span><br><span class="line">        System.out.println(time.toSecondOfDay());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-LocalDateTime-年月日和时分秒"><a href="#3-LocalDateTime-年月日和时分秒" class="headerlink" title="3. LocalDateTime(年月日和时分秒)"></a>3. LocalDateTime(年月日和时分秒)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDateTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(dateTime.getYear()+<span class="string">&quot; &quot;</span>+dateTime.getMonthValue()+<span class="string">&quot; &quot;</span>+dateTime.getDayOfMonth()+</span><br><span class="line">                            dateTime.getHour()+<span class="string">&quot; &quot;</span>+dateTime.getMinute()+<span class="string">&quot; &quot;</span>+dateTime.getSecond());</span><br><span class="line">        System.out.println(dateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-DateTimeFormatter"><a href="#4-DateTimeFormatter" class="headerlink" title="4. DateTimeFormatter"></a>4. DateTimeFormatter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTimeFormatter_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd:HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2017-12-15:19:15:01&quot;</span>,formatter);</span><br><span class="line">        System.out.println(dateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-ZonedDateTime-有时区"><a href="#5-ZonedDateTime-有时区" class="headerlink" title="5. ZonedDateTime(有时区)"></a>5. ZonedDateTime(有时区)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZonedDateTime_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;MM/dd/yyyy:HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> zonedDateTime.format(formatter);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是Lambda表达式？&quot;&gt;&lt;a href=&quot;#什么是Lambda表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是Lambda表达式？&quot;&gt;&lt;/a&gt;什么是Lambda表达式？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;可以将Lambda表达式理</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Stream流</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Stream%E6%B5%81/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%B5%85%E8%B0%88Stream%E6%B5%81/</id>
    <published>2022-09-14T08:52:23.000Z</published>
    <updated>2022-09-14T09:59:40.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Stream流"><a href="#什么是Stream流" class="headerlink" title="什么是Stream流"></a>什么是Stream流</h2><blockquote><p><code>Stream</code>被翻译为流，它的工作过程像将一瓶水导入有很多过滤阀的管道一样，水每经过一个过滤阀，便被操作一次，比如过滤，转换等，最后管道的另外一头有一个容器负责接收剩下的水。</p><p><code>Stream</code>作为Java 8的一大亮点，它专门针对集合的各种操作提供各种非常便利，简单，高效的API,<code>Stream API</code>主要是通过<code>Lambda</code>表达式完成，极大的提高了程序的效率和可读性，同时<code>Stram API</code>中自带的并行流使得并发处理集合的门槛再次降低，使用<code>Stream API</code>编程无需多写一行多线程的大门就可以非常方便的写出高性能的并发程序。使用<code>Stream API</code>能够使你的代码更加优雅。</p><p>流的另一特点是可无限性，使用<code>Stream</code>，你的数据源可以是无限大的。</p></blockquote><h2 id="如何使用流"><a href="#如何使用流" class="headerlink" title="如何使用流"></a>如何使用流</h2><blockquote><ul><li>获取流</li><li>对流操作</li><li>结束对流操作</li></ul></blockquote><h3 id="获取流"><a href="#获取流" class="headerlink" title="-  获取流"></a>-  获取流</h3><blockquote><p>获取流的方式有多种，对于常见的容器(<code>Collection</code>)可以直接<code>.stream()</code>获取 例如：</p><ul><li><code>Collection.stream()</code></li><li><code>Collection.parallelStream()</code></li><li><code>Arrays.stream(T array) or Stream.of()</code></li></ul><p>对于<code>IO</code>，我们也可以通过<code>lines()</code>方法获取流：</p><ul><li><code>java.nio.file.Files.walk()</code></li><li><code>java.io.BufferedReader.lines()</code></li></ul><p>最后，我们还可以从无限大的数据源中产生流：</p><ul><li><code>Random.ints()</code></li></ul><p>值得注意的是，<code>JDK</code>中针对基本数据类型的昂贵的装箱和拆箱操作，提供了基本数据类型的流：</p><ul><li><p><code>IntStream</code></p></li><li><p><code>LongStream</code></p></li><li><p><code>DoubleStream</code></p><p>这三种基本数据类型和普通流差不多，不过他们流里面的数据都是指定的基本数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intstream.of(new int[]&#123;1,2,3&#125;);</span><br><span class="line">Intstream.range(1,3);</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这边有个parallelStream和stream的区别</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为parallelstream是并行流,所以执行效率比较高</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并行流并不会按照原本的顺序轨迹执行, 而是 随机执行</span></span><br><span class="line">可以从以下三点入手考虑是否使用parallelstream</span><br><span class="line">是否需要并行？  </span><br><span class="line">任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class="line">结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure><blockquote><p>获取流的方式有多种，对于常见的容器(<code>Collection</code>)可以直接<code>.stream()</code>获取 例如：</p><ul><li><code>Collection.stream()</code></li><li><code>Collection.parallelStream()</code></li><li><code>Arrays.stream(T array) or Stream.of()</code></li></ul><p>对于<code>IO</code>，我们也可以通过<code>lines()</code>方法获取流：</p><ul><li><code>java.nio.file.Files.walk()</code></li><li><code>java.io.BufferedReader.lines()</code></li></ul><p>最后，我们还可以从无限大的数据源中产生流：</p><ul><li><code>Random.ints()</code></li></ul><p>值得注意的是，<code>JDK</code>中针对基本数据类型的昂贵的装箱和拆箱操作，提供了基本数据类型的流：</p><ul><li><p><code>IntStream</code></p></li><li><p><code>LongStream</code></p></li><li><p><code>DoubleStream</code></p><p>这三种基本数据类型和普通流差不多，不过他们流里面的数据都是指定的基本数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intstream.of(new int[]&#123;1,2,3&#125;);</span><br><span class="line">Intstream.rang(1,3);</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这边有个parallelStream和stream的区别</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为parallelstream是并行流,所以执行效率比较高</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并行流并不会按照原本的顺序轨迹执行, 而是 随机执行</span></span><br><span class="line">可以从以下三点入手考虑是否使用parallelstream</span><br><span class="line">是否需要并行？  </span><br><span class="line">任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class="line">结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure><h3 id="对流操作"><a href="#对流操作" class="headerlink" title="- 对流操作"></a>- 对流操作</h3><blockquote><p>对于中间操作，所有的<code>API</code>的返回值基本都是<code>Stream&lt;T&gt;</code>,因此以后看见一个陌生的<code>API</code>也能通过返回值判断它的所属类型。</p><h6 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a><strong>map/flatMap</strong></h6><p><code>map</code>顾名思义，就是映射，<code>map</code>操作能够将流中的每一个元素映射为另外的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p>可以看到<code>map</code>接受的是一个<code>Function</code>,也就是接收参数，并返回一个值。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提取 List&lt;Student&gt;  所有student 的名字 </span></span><br><span class="line">List&lt;String&gt; studentNames = students.stream().map(Student::getName)</span><br><span class="line">                                             .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上面的代码等同于以前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; studentNames=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line">    studentNames.add(student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>再比如：将List中所有字母转换为大写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words=Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt; upperWords=words.stream().map(String::toUpperCase)</span><br><span class="line">                                      .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><p><code>flatMap</code>顾名思义就是扁平化映射，它具体的操作是将多个<code>stream</code>连接成一个<code>stream</code>，这个操作是针对类似多维数组的，比如容器里面包含容器等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ints=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">                                          Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)));</span><br><span class="line">List&lt;Integer&gt; flatInts=ints.stream().flatMap(Collection::stream).</span><br><span class="line">                                       collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>可以看到，相当于降维。</p><hr><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filter`顾名思义，就是过滤，通过测试的元素会被留下来并生成一个新的`Stream</span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure><p>同理，我们可以<code>filter</code>接收的参数是<code>Predicate</code>，也就是推断型函数式接口，接收参数，并返回<code>boolean</code>值。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有大于18岁的学生</span></span><br><span class="line">List&lt;Student&gt; studentNames = students.stream().filter(s-&gt;s.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">                                              .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a><strong>distinct</strong></h6><p><code>distinct</code>是去重操作,它没有参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><hr><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a><strong>sorted</strong></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sorted`排序操作，默认是从小到大排列，sorted方法包含一个重载，使用sorted方法，如果没有传递参数，那么流中的元素就需要实现Comparable&lt;T&gt;方法，也可以在使sorted方法的时候传入一个`Comparator&lt;T&gt;</span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>值得一说的是这个<code>Comparator</code>在<code>Java 8</code>之后被打上了<code>@FunctionalInterface</code>,其他方法都提供了<code>default</code>实现，因此我们可以在<code>sort</code>中使用<code>Lambda</code>表达式</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以年龄排序</span></span><br><span class="line">students.stream().sorted((s,o)-&gt;Integer.compare(s.getAge(),o.getAge()))</span><br><span class="line">                                  .forEach(System.out::println);;</span><br></pre></td></tr></table></figure><p>然而还有更方便的，<code>Comparator</code>默认也提供了实现好的方法引用，使得我们更加方便的使用：</p><p>例如上面的代码可以改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以年龄排序 </span></span><br><span class="line">students.stream().sorted(Comparator.comparingInt(Student::getAge))</span><br><span class="line">                            .forEach(System.out::println);;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以姓名排序</span></span><br><span class="line">students.stream().sorted(Comparator.comparing(Student::getName)).</span><br><span class="line">                          forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>是不是更加简洁。</p><hr><h6 id="peek"><a href="#peek" class="headerlink" title="peek"></a><strong>peek</strong></h6><p><code>peek</code>有遍历的意思，和<code>forEach</code>一样，但是它是一个中间操作。</p><p><code>peek</code>接受一个消费型的函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去重以后打印出来，然后再归并为List</span></span><br><span class="line">List&lt;Student&gt; sortedStudents= students.stream().distinct().peek(System.out::println).</span><br><span class="line">                                                collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h6 id="limit"><a href="#limit" class="headerlink" title="limit"></a><strong>limit</strong></h6><p><code>limit</code>裁剪操作，和<code>String::subString(0,x)</code>有点先沟通，<code>limit</code>接受一个<code>long</code>类型参数，通过<code>limit</code>之后的元素只会剩下<code>min(n,size)</code>个元素，<code>n</code>表示参数，<code>size</code>表示流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只留下前6个元素并打印</span></span><br><span class="line">students.stream().limit(<span class="number">6</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><hr><h6 id="skip"><a href="#skip" class="headerlink" title="skip"></a><strong>skip</strong></h6><p><code>skip</code>表示跳过多少个元素，和<code>limit</code>比较像，不过<code>limit</code>是保留前面的元素，<code>skip</code>是保留后面的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳过前3个元素并打印 </span></span><br><span class="line">students.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></blockquote><h3 id="终结操作"><a href="#终结操作" class="headerlink" title="- 终结操作"></a>- 终结操作</h3><blockquote><p>一个流处理中，有且只能有一个终结操作，通过终结操作之后，流才真正被处理，终结操作一般都返回其他的类型而不再是一个流,一般来说，终结操作都是将其转换为一个容器。</p><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><strong>forEach</strong></h6><p><code>forEach</code>是终结操作的遍历，操作和<code>peek</code>一样，但是<code>forEach</code>之后就不会再返回流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历打印</span></span><br><span class="line">students.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的代码和一下代码效果相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line">    System.out.println(sudents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a><strong>toArray</strong></h6><p><code>toArray</code>和<code>List##toArray()</code>用法差不多，包含一个重载。</p><p>默认的<code>toArray()</code>返回一个<code>Object[]</code>，</p><p>也可以传入一个<code>IntFunction&lt;A[]&gt; generator</code>指定数据类型</p><p>一般建议第二种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student[] studentArray = students.stream().skip(<span class="number">3</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><hr><h6 id="max-min"><a href="#max-min" class="headerlink" title="max/min"></a><strong>max/min</strong></h6><p><code>max/min</code>即使找出最大或者最小的元素。<code>max/min</code>必须传入一个<code>Comparator</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure><hr><h6 id="count"><a href="#count" class="headerlink" title="count"></a><strong>count</strong></h6><p><code>count</code>返回流中的元素数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span>  <span class="variable">count</span> <span class="operator">=</span> students.stream().skip(<span class="number">3</span>).count();</span><br></pre></td></tr></table></figure><hr><h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><strong>reduce</strong></h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce为归纳操作，主要是将流中各个元素结合起来，它需要提供一个起始值，然后按一定规则进行运算，比如相加等，它接收一个二元操作 <span class="code">`BinaryOperator`</span>函数式接口。从某种意义上来说，<span class="code">`sum,min,max,average`</span>都是特殊的reduce</span><br></pre></td></tr></table></figure><p><code>reduce</code>包含三个重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"></span><br><span class="line"> &lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity,</span></span><br><span class="line"><span class="params">                 BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">        </span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> integers.stream().reduce(<span class="number">0</span>,(x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure><p>以上代码等同于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> integers.stream().reduce(Integer::sum).get();</span><br></pre></td></tr></table></figure><p><code>reduce</code>两个参数和一个参数的区别在于有没有提供一个起始值，</p><p>如果提供了起始值，则可以返回一个确定的值，如果没有提供起始值，则返回<code>Opeational</code>防止流中没有足够的元素。</p><hr><h6 id="anyMatch-allMatch-noneMatch"><a href="#anyMatch-allMatch-noneMatch" class="headerlink" title="anyMatch\ allMatch\ noneMatch"></a><strong>anyMatch\ allMatch\ noneMatch</strong></h6><p>测试是否有任意元素\所有元素\没有元素匹配表达式</p><p>他们都接收一个推断类型的函数式接口：<code>Predicate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">noneMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> integers.stream().anyMatch(x-&gt;x&gt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h6 id="findFirst、-findAny"><a href="#findFirst、-findAny" class="headerlink" title="findFirst、 findAny"></a><strong>findFirst、 findAny</strong></h6><p>获取元素，这两个<code>API</code>都不接受任何参数，<code>findFirt</code>返回流中第一个元素，<code>findAny</code>返回流中任意一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">findFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">findAny</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><blockquote><p>也有有人会问<code>findAny()</code>这么奇怪的操作谁会用？这个<code>API</code>主要是为了在并行条件下想要获取任意元素，以最大性能获取任意元素</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> integers.stream().findAny().get();</span><br></pre></td></tr></table></figure><hr><h6 id="collect"><a href="#collect" class="headerlink" title="collect"></a><strong>collect</strong></h6><p><code>collect</code>收集操作，这个<code>API</code>放在后面将是因为它太重要了，基本上所有的流操作最后都会使用它。</p><p>我们先看<code>collect</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br></pre></td></tr></table></figure><p>可以看到，<code>collect</code>包含两个重载：</p><p>一个参数和三个参数，</p><p>三个参数我们很少使用，因为<code>JDK</code>提供了足够我们使用的<code>Collector</code>供我们直接使用,我们可以简单了解下这三个参数什么意思：</p><ul><li><code>Supplier</code>:用于产生最后存放元素的容器的生产者</li><li><code>accumulator</code>:将元素添加到容器中的方法</li><li><code>combiner</code>：将分段元素全部添加到容器中的方法</li></ul><p>前两个元素我们都很好理解，第三个元素是干嘛的呢？因为流提供了并行操作，因此有可能一个流被多个线程分别添加，然后再将各个子列表依次添加到最终的容器中。</p><p>↓ - - - - - - - - -</p><p>↓ — — —</p><p>↓ ———</p><p>如上图，分而治之。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = stream.collect(ArrayList::<span class="keyword">new</span>, List::add, List::addAll);</span><br></pre></td></tr></table></figure><hr><p>接下来看只有一个参数的<code>collect</code></p><p>一般来说，只有一个参数的<code>collect</code>，我们都直接传入<code>Collectors</code>中的方法引用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; = integers.stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><code>Collectors</code>中包含很多常用的转换器。<code>toList()</code>,<code>toSet()</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collectors`中还包括一个`groupBy()`，他和`Sql`中的`groupBy`一样都是分组，返回一个`Map</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按学生年龄分组</span></span><br><span class="line">Map&lt;Integer,List&lt;Student&gt;&gt; map= students.stream().</span><br><span class="line">                                collect(Collectors.groupingBy(Student::getAge));</span><br></pre></td></tr></table></figure><p><code>groupingBy</code>可以接受3个参数，分别是</p><ol><li>第一个参数：分组按照什么分类</li><li>第二个参数：分组最后用什么容器保存返回（当只有两个参数是，此参数默认为<code>HashMap</code>）</li><li>第三个参数：按照第一个参数分类后，对应的分类的结果如何收集</li></ol><p>有时候单参数的<code>groupingBy</code>不满足我们需求的时候，我们可以使用多个参数的<code>groupingBy</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生以年龄分组，每组中只存学生的名字而不是对象</span></span><br><span class="line">Map&lt;Integer,List&lt;String&gt;&gt; map =  students.stream().</span><br><span class="line">  collect(Collectors.groupingBy(Student::getAge,Collectors.mapping(Student::getName,Collectors.toList())));</span><br></pre></td></tr></table></figure><p><code>toList</code>默认生成的是<code>ArrayList</code>,<code>toSet</code>默认生成的是<code>HashSet</code>，如果想要指定其他容器，可以如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> students.stream().collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">Collectors`还包含一个`toMap`，利用这个`API`我们可以将`List`转换为`Map</span><br><span class="line">  Map&lt;Integer,Student&gt; map=students.stream().</span><br><span class="line">                           collect(Collectors.toMap(Student::getAge,s-&gt;s));</span><br></pre></td></tr></table></figure><p>值得注意的一点是，<code>IntStream</code>，<code>LongStream</code>,<code>DoubleStream</code>是没有<code>collect()</code>方法的，因为对于基本数据类型，要进行装箱，拆箱操作，SDK并没有将它放入流中，对于基本数据类型流，我们只能将其<code>toArray()</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Stream流&quot;&gt;&lt;a href=&quot;#什么是Stream流&quot; class=&quot;headerlink&quot; title=&quot;什么是Stream流&quot;&gt;&lt;/a&gt;什么是Stream流&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt;被翻译为流，</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数据库大数据量问题</title>
    <link href="https://gwtt.github.io/2022/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%8F%92%E5%85%A5/"/>
    <id>https://gwtt.github.io/2022/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E6%8F%92%E5%85%A5/</id>
    <published>2022-09-14T03:27:23.000Z</published>
    <updated>2022-09-14T07:53:01.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大批量插入数据优化"><a href="#大批量插入数据优化" class="headerlink" title="大批量插入数据优化"></a>大批量插入数据优化</h2><blockquote><h3 id="1-一条SQL语句插入多条数据"><a href="#1-一条SQL语句插入多条数据" class="headerlink" title="1.一条SQL语句插入多条数据"></a>1.一条SQL语句插入多条数据</h3><p>常用的插入语句如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>修改后的插入操作能够提高程序的插入效率。这里第二种SQL执行效率高的主要原因是合并后日志量（MySQL的binlog和innodb的事务让日志）减少了， <strong>降低日志刷盘的数据量和频率，从而提高效率</strong>。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传输的IO 。</p><p>可以显著提高效率</p><h3 id="2-在事务中进行插入处理。"><a href="#2-在事务中进行插入处理。" class="headerlink" title="2.在事务中进行插入处理。"></a>2.在事务中进行插入处理。</h3><p>把插入修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>使用事务可以提高数据的插入效率，这是因为进行一个INSERT操作时，<strong>MySQL内部会建立一个事务</strong>，在事务内才进行真正插入处理操作。通过使用事务可以减少创建事务的消耗， <code>所有插入都在执行后才进行提交操作</code> 。</p><h3 id="3-数据有序插入。"><a href="#3-数据有序插入。" class="headerlink" title="3.数据有序插入。"></a>3.数据有序插入。</h3><p>数据有序的插入是指插入记录在主键上是有序排列，例如datetime是记录的主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;userid_2&#x27;</span>, <span class="string">&#x27;content_2&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>修改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;userid_0&#x27;</span>, <span class="string">&#x27;content_0&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;userid_1&#x27;</span>, <span class="string">&#x27;content_1&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `insert_table` (`datetime`, `uid`, `content`, `type`) </span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;userid_2&#x27;</span>, <span class="string">&#x27;content_2&#x27;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>由于数据库插入时，需要维护索引数据</strong>，<code>无序的记录会增大维护索引的成本</code>。 我们可以参照InnoDB使用的B+tree索引，如果每次插入记录都在索引的最后面，索引的定位效率很高，并且对索引调整较小；如果插入的记录在索引中间，需要B+tree进行分裂合并等处理，会消耗比较多计算资源，并且插入记录的索引定位效率会下降，数据量较大时会有频繁的磁盘操作。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大批量插入数据优化&quot;&gt;&lt;a href=&quot;#大批量插入数据优化&quot; class=&quot;headerlink&quot; title=&quot;大批量插入数据优化&quot;&gt;&lt;/a&gt;大批量插入数据优化&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;1-一条SQL语句插入多条数据&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引相关</title>
    <link href="https://gwtt.github.io/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://gwtt.github.io/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/</id>
    <published>2022-09-14T02:32:47.141Z</published>
    <updated>2022-09-14T03:12:10.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么用-B-树做索引而不用哈希表做索引"><a href="#为什么用-B-树做索引而不用哈希表做索引" class="headerlink" title="为什么用 B+ 树做索引而不用哈希表做索引?"></a>为什么用 B+ 树做索引而不用哈希表做索引?</h3><blockquote><p>1、哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。</p><p>2、如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。</p><p>3、索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的<strong>链表</strong>，这样的话，查找的时间就会大大增加。</p></blockquote><h3 id="主键索引和非主键索引有什么区别？"><a href="#主键索引和非主键索引有什么区别？" class="headerlink" title="主键索引和非主键索引有什么区别？"></a>主键索引和非主键索引有什么区别？</h3><blockquote><p>例如对于下面这个表(其实就是上面的表中增加了一个k字段),且ID是主键。</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640.png" alt="图片"></p><p>主键索引和非主键索引的示意图如下：</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631230630081.png" alt="图片"></p><p>其中R代表一整行的值。</p><p>从图中不难看出，主键索引和非主键索引的区别是：非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>，其中非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p><p>根据这两种结构我们来进行下查询，看看他们在查询上有什么区别。</p><p>1、如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p><p>2、如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为回表。</p></blockquote><h3 id="为什么建议使用主键自增的索引？"><a href="#为什么建议使用主键自增的索引？" class="headerlink" title="为什么建议使用主键自增的索引？"></a>为什么建议使用主键自增的索引？</h3><blockquote><p>对于这颗主键索引的树</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631245106466.png" alt="图片"></p><p>如果我们插入 ID = 650 的一行数据，那么直接在最右边插入就可以了</p><p><img src="/2022/09/14/Mysql%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/640-16631245106467.png" alt="图片"></p><p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行<strong>页分裂</strong>操作，这样会更加糟糕。</p><p>但是，如果我们的主键是自增的，每次插入的 ID 都会比前面的大，那么我们每次只需要在后面插入就行， 不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么用-B-树做索引而不用哈希表做索引&quot;&gt;&lt;a href=&quot;#为什么用-B-树做索引而不用哈希表做索引&quot; class=&quot;headerlink&quot; title=&quot;为什么用 B+ 树做索引而不用哈希表做索引?&quot;&gt;&lt;/a&gt;为什么用 B+ 树做索引而不用哈希表做索引?&lt;/</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="MySQL" scheme="https://gwtt.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MySQL慢查询</title>
    <link href="https://gwtt.github.io/2022/09/11/%E6%B5%85%E8%B0%88Mysql%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <id>https://gwtt.github.io/2022/09/11/%E6%B5%85%E8%B0%88Mysql%E6%85%A2%E6%9F%A5%E8%AF%A2/</id>
    <published>2022-09-11T11:44:18.000Z</published>
    <updated>2022-09-11T15:42:07.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="慢查询是什么"><a href="#慢查询是什么" class="headerlink" title="慢查询是什么"></a>慢查询是什么</h3><blockquote><p>MySQL的慢查询，全名是<strong>慢查询日志</strong>，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。</p><p>具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。</p><p>long_query_time的默认值为10，意思是记录运行10秒以上的语句。</p><p>默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>慢查询日志支持将日志记录写入文件和数据库表。</p></blockquote><h3 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h3><blockquote><p><strong>mysql并不启动慢查询日志</strong>，需要我们手动开启</p><ul><li>1、输入命令开启慢查询（临时），在MySQL服务重启后会自动关闭；</li><li>2、配置my.cnf（windows是my.ini）系统文件开启，修改配置文件是持久化开启慢查询的方式</li></ul></blockquote><blockquote><h3 id="命令开启"><a href="#命令开启" class="headerlink" title="命令开启"></a>命令开启</h3><p>查询慢查询是否开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>开启慢查询命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>; </span><br></pre></td></tr></table></figure><p>指定记录慢查询日志SQL执行时间得阈值（long_query_time 单位：秒，默认10秒）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><p>查询 “慢查询日志文件存放位置”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log_file%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="配置文件开启"><a href="#配置文件开启" class="headerlink" title="配置文件开启"></a>配置文件开启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启慢查询功能</span></span><br><span class="line">slow_query_log=ON</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定记录慢查询日志SQL执行时间得阈值</span></span><br><span class="line">long_query_time=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选填，默认数据文件路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slow_query_log_file=/var/lib/mysql/localhost-slow.log</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="慢查询经验"><a href="#慢查询经验" class="headerlink" title="慢查询经验"></a>慢查询经验</h2><h3 id="LIMIT分页"><a href="#LIMIT分页" class="headerlink" title="LIMIT分页"></a>LIMIT分页</h3><blockquote><h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><p>  在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by 子句。如果有对应的索引，通常效率会不错，否则MySQL需要做大量的文件排序操作。</p><p>  一个非常令人头疼问题就是当偏移量非常大的时候，例如可能是limit 1000000,10这样的查询，这是mysql需要查询1000000条然后只返回最后10条，前面的1000000条记录都将被舍弃，这样的代价很高，会造成慢查询。</p><p>  优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p><p>对于下面的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行耗时：1.379s</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info LIMIT <span class="number">1000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p> 该语句存在的最大问题在于limit M,N中偏移量M太大，导致每次查询都要先从整个表中找到满足条件 的前M条记录，之后舍弃这M条记录并从第M+1条记录开始再依次找到N条满足条件的记录。如果表非常大，且筛选字段没有合适的索引，且M特别大那么这样的代价是非常高的。</p><p>  那么如果我们下一次的查询能从前一次查询结束后标记的位置开始查找，找到满足条件的10条记录，并记下下一次查询应该开始的位置，以便于下一次查询能直接从该位置 开始，这样就不必每次查询都先从整个表中先找到满足条件的前M条记录，舍弃掉，再从M+1开始再找到10条满足条件的记录了。</p><h3 id="思路一：构造覆盖索引"><a href="#思路一：构造覆盖索引" class="headerlink" title="思路一：构造覆盖索引"></a>思路一：构造覆盖索引</h3><p>  通过修改SQL，使用上覆盖索引，比如我需要只查询表中的app_name、createTime等少量字段，那么我秩序在app_name、createTime字段设置联合索引，即可实现覆盖索引，无需全表扫描。适用于查询列较少的场景，查询列数过多的不推荐。</p><p>耗时：<code>0.390s</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> app_name,createTime <span class="keyword">from</span> vio_basic_domain_info LIMIT <span class="number">1000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="思路二：优化offset"><a href="#思路二：优化offset" class="headerlink" title="思路二：优化offset"></a>思路二：优化offset</h3><p>  无法用上覆盖索引，那么重点是想办法快速过滤掉前100w条数据。我们可以利用自增主键有序的条件，先查询出第1000001条数据的id值，再往后查10行；适用于主键id自增的场景。<br>耗时：<code>0.471s</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">where</span> </span><br><span class="line">  id <span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> id <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> id limit <span class="number">1000000</span>,<span class="number">1</span>) limit <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法三：“延迟关联”"><a href="#方法三：“延迟关联”" class="headerlink" title="方法三：“延迟关联”"></a>方法三：“延迟关联”</h3><p>耗时：<code>0.439s</code><br>延迟关联适用于数量级较大的表，SQL如下；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> vio_basic_domain_info <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">1000000</span>,<span class="number">10</span>) <span class="keyword">as</span> myNew <span class="keyword">using</span>(id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们利用到了<code>覆盖索引+延迟关联查询</code>，相当于先只查询id列，利用覆盖索引快速查到该页的10条数据id，然后再把返回的10条id拿到表中通过主键索引二次查询。（表数据增速快的情况对该方法影响较小。）</p></blockquote><h3 id="索引没起作用"><a href="#索引没起作用" class="headerlink" title="索引没起作用"></a>索引没起作用</h3><blockquote><h3 id="1-模糊查询尽量避免用通配符’-’开头，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#1-模糊查询尽量避免用通配符’-’开头，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="1.模糊查询尽量避免用通配符’%’开头，会导致数据库引擎放弃索引进行全表扫描。如下："></a>1.模糊查询尽量避免用通配符’%’开头，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%MIKE%&#x27;</span> #不推荐</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;MIKE%&#x27;</span> #推荐</span><br></pre></td></tr></table></figure><p>如果需求是要在前面使用模糊查询，</p><p>使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置。<br>使用FullText全文索引，用match against 检索<br>数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级<br>当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like ‘%xx%’。<br>  但不得不说，MySQL模糊匹配大字段是硬伤，毕竟保证事务的ACID特性耗费了太多性能，因此，如果实际场景中有类似业务需求，建议果断更换大数据存储引擎如<strong>ElasticSearch</strong>、<strong>Hbase</strong>等。</p><h3 id="2-尽量避免使用-not-in，会导致引擎走全表扫描。建议用-not-exists-代替，如下："><a href="#2-尽量避免使用-not-in，会导致引擎走全表扫描。建议用-not-exists-代替，如下：" class="headerlink" title="2.尽量避免使用 not in，会导致引擎走全表扫描。建议用 not exists 代替，如下："></a>2.尽量避免使用 not in，会导致引擎走全表扫描。建议用 not exists 代替，如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> name <span class="keyword">not</span> <span class="keyword">IN</span> (<span class="string">&#x27;提莫&#x27;</span>,<span class="string">&#x27;队长&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">as</span> t1 <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">as</span> t2 <span class="keyword">where</span> name <span class="keyword">IN</span> (<span class="string">&#x27;提莫&#x27;</span>,<span class="string">&#x27;队长&#x27;</span>) <span class="keyword">and</span> t1.id <span class="operator">=</span> t2.id);</span><br></pre></td></tr></table></figure><h3 id="3-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#3-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="3.尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下："></a>3.尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优化方式：可以用<span class="keyword">union</span>代替<span class="keyword">or</span>。如下：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="4-尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下："><a href="#4-尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：" class="headerlink" title="4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下："></a>4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">优化方式：可以给字段添加默认值<span class="number">0</span>，对<span class="number">0</span>值进行判断。如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> score <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="5-尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下："><a href="#5-尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下：" class="headerlink" title="5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下："></a>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全表扫描</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> score<span class="operator">/</span><span class="number">10</span> <span class="operator">=</span> <span class="number">9</span></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> score <span class="operator">=</span> <span class="number">10</span><span class="operator">*</span><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="6-当数据量大时，避免使用where-1-1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下："><a href="#6-当数据量大时，避免使用where-1-1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：" class="headerlink" title="6.当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下："></a>6.当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username, age, sex <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">优化方式：用代码拼装<span class="keyword">sql</span>时进行判断，没 <span class="keyword">where</span> 条件就去掉 <span class="keyword">where</span>，有<span class="keyword">where</span>条件就加 <span class="keyword">and</span>。</span><br></pre></td></tr></table></figure><h3 id="7-查询条件不要用-lt-gt-或者"><a href="#7-查询条件不要用-lt-gt-或者" class="headerlink" title="7.查询条件不要用 &lt;&gt; 或者 !="></a>7.查询条件不要用 &lt;&gt; 或者 !=</h3><p>使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</p><h3 id="8-where条件仅包含复合索引非前导列"><a href="#8-where条件仅包含复合索引非前导列" class="headerlink" title="8.where条件仅包含复合索引非前导列"></a>8.where条件仅包含复合索引非前导列</h3><p>如：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> key_part2<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part3<span class="operator">=</span><span class="number">2</span></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> key_part1 <span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part2<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> key_part3<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="9-隐式类型转换造成不使用索引"><a href="#9-隐式类型转换造成不使用索引" class="headerlink" title="9.隐式类型转换造成不使用索引"></a>9.隐式类型转换造成不使用索引</h3><p>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> col_varchar<span class="operator">=</span><span class="number">123</span>; </span><br></pre></td></tr></table></figure></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>你对MySQL的慢查询优化有了解吗 </p><blockquote><p><strong>标准回答</strong></p><p>​    慢查询优化的前提是定位到响应慢的SQL，这可以通过启用慢查询日志来实现。默认情况下，MySQL并不启用慢查询日志，我们需要手动开启这个参数。通过日志定位到慢查询的SQL之后，我们可以使用EXPLAIN语句来分析这个SQL，进而发现问题所在。导致慢查询的原因有很多，下面列举几种常见的原因，以及对应的解决方案：</p><ol><li><p>向数据库请求了多余的数据：</p><p>很多时候，我们的SQL返回的结果会超出我们的需要，例如实际上它返回了更多的行，而我们只要其中的一部分。又或者我们要求返回所有的列，实际上却只有其中少数的列。对于这类问题，我们可以通过LIMIT控制返回的行数，尽量不用<code>SELECT *</code>避免查询到过多的列。</p></li><li><p>SQL复杂导致无法利用缓存：</p><p>处于业务的需要，我们经常会写出比较复杂的SQL，这自然包括复杂的关联查询。由于复杂SQL返回的结果涉及多张表、多个条件、甚至各种函数，这样的SQL每次返回的结果势必不同，所以很难利用到数据库的缓存。如果我们将复杂SQL进行拆分，变成若干简单的SQL，那么其中有些SQL由于条件不变，就可以利用到数据库的缓存了，从而让查询效率得以提升。</p></li><li><p>没有选择正确的索引：</p><p>我们都知道，创建索引是提高查询效率的一个常用手段，事实上我们也经常会这样做。但是，很多时候我们创建了索引，通过EXPLAIN查看会发现并没有走这个索引，最终导致SQL执行变慢。所以，不是把索引创建出来就算完成任务，还要分析索引的选择性，根据业务条件不断的优化索引，从而增加索引的命中率。</p><p><strong>加分回答</strong></p><p>​    除上述优化的方向之外，SQL中还有很多地方都有优化的空间，例如COUNT()、关联查询、子查询、GROUP BY、LIMIT、UNION等。总体来说，不同的情况要区别对待，但所有优化的背后是基于慢查询日志的定位。另外，为了能够发现问题的本质，还需要对MySQL执行查询的过程有所了解：</p><ol><li>客户端发送一条查询SQL给服务器。 </li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。 </li><li>服务器进行SQL解析和预处理，再由优化器生成对应的执行计划。 </li><li>服务器根据优化器生成的执行计划，调用存储引擎的API来执行查询。 </li><li>将结果返回给客户端。 </li></ol><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p>​    B+树索引是基于B+树构建出来的有序结构，只有利用上它的有序性才能提高查询的效率。若不满足有序性这个前提，则在这个索引中的查询是离散的，其效率反而更低。查询优化器对索引的选择性，被称为最左前缀原则。</p><p>​    假设有如下一张表：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (</span><br><span class="line">  a <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  b <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  c <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  KEY idx_union(a,b,c)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB;</span><br></pre></td></tr></table></figure><p>​    假设idx_union的叶子节点数据如下：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>), (<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>), (<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>), (<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>), (<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>), (<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>), (<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>​    该索引的选择性示例如下：</p><p><a href="#">复制代码</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 匹配左前缀</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 匹配列前缀</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;x%&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">like</span> <span class="string">&#x27;%x&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b <span class="keyword">like</span> <span class="string">&#x27;x%&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 全值匹配</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> c<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="comment">-- 匹配范围值</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="comment">-- 全值匹配 + 范围匹配</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- Y</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> c <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> a <span class="keyword">between</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;    <span class="comment">-- N</span></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;慢查询是什么&quot;&gt;&lt;a href=&quot;#慢查询是什么&quot; class=&quot;headerlink&quot; title=&quot;慢查询是什么&quot;&gt;&lt;/a&gt;慢查询是什么&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL的慢查询，全名是&lt;strong&gt;慢查询日志&lt;/strong&gt;，是MySQ</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL面试</title>
    <link href="https://gwtt.github.io/2022/09/05/SQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95/"/>
    <id>https://gwtt.github.io/2022/09/05/SQL%E8%AF%AD%E5%8F%A5%E9%9D%A2%E8%AF%95/</id>
    <published>2022-09-05T10:43:55.628Z</published>
    <updated>2022-09-05T10:49:52.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL的执行顺序"><a href="#1-SQL的执行顺序" class="headerlink" title="1.SQL的执行顺序"></a>1.SQL的执行顺序</h2><blockquote><p> from&gt;join&gt;where&gt;group by&gt;聚合函数&gt;having&gt;select&gt;order by&gt;limit </p><h3 id="1、最先执行from-table；"><a href="#1、最先执行from-table；" class="headerlink" title="1、最先执行from table；"></a>1、最先执行from table；</h3><p> 需要先确定从哪个表中取<a href>数据</a>，所以最先执行from table。 </p><h3 id="2、join连接"><a href="#2、join连接" class="headerlink" title="2、join连接"></a>2、join连接</h3><p> 用于把来自两个或多个表的行结合起来，简单补充一下连接的类型 </p><ul><li> 自然连接（natural join） </li><li> 内连接（inner join）：内连接查询能将左表和右表中能关联起来的<a href>数据</a>连接后返回，返回的结果就是两个表中所有相匹配的<a href>数据</a>。 </li><li> 外连接（outer join）：外连接分为左外连接（LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行）、右外连接（RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行）、还有一个FULL JOIN(全连接)，不过MYSQL不支持全连接 </li><li> 交叉连接（cross join）即笛卡尔连接 </li></ul><h3 id="3、where语句；"><a href="#3、where语句；" class="headerlink" title="3、where语句；"></a>3、where语句；</h3><p> where语句是对条件加以限定 </p><h3 id="4、分组语句【group-by……-having】；"><a href="#4、分组语句【group-by……-having】；" class="headerlink" title="4、分组语句【group by…… having】；"></a>4、分组语句【group by…… having】；</h3><p> group by是分组语句 </p><p> having是和group by配合使用的，用来作条件限定 </p><h3 id="5、聚合函数；"><a href="#5、聚合函数；" class="headerlink" title="5、聚合函数；"></a>5、聚合函数；</h3><p> 常用的聚合函数有max，min， count，sum，聚合函数的执行在group by之后，having之前 </p><p> 举例：count函数查询分组后，每一组分别有多少条<a href>数据</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="title function_">count</span><span class="params">(*)</span> from user group by gender</span><br></pre></td></tr></table></figure><p> 值得注意的是：<strong>聚合函数的执行在group by之后，having之前</strong> </p><h3 id="6、select语句；"><a href="#6、select语句；" class="headerlink" title="6、select语句；"></a>6、select语句；</h3><p> 对分组聚合完的表挑选出需要查询的<a href>数据</a> </p><h3 id="7、Distinct"><a href="#7、Distinct" class="headerlink" title="7、Distinct"></a>7、Distinct</h3><p> distinct对<a href>数据</a>进行去重 </p><p> 如果sql语句存在聚合函数，例如count、max等，会<strong>先执行聚合函数再去重</strong> </p><h3 id="8、order-by排序语句。"><a href="#8、order-by排序语句。" class="headerlink" title="8、order by排序语句。"></a>8、order by<a href>排序</a>语句。</h3><p> order by<a href>排序</a>语句 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id  升序排序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> 降序排序</span><br></pre></td></tr></table></figure><h3 id="9、limit"><a href="#9、limit" class="headerlink" title="9、limit"></a>9、limit</h3><p> limit用于指定返回的<a href>数据</a>条数 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">2</span></span><br><span class="line">从<span class="keyword">user</span>表中查询前两条数据</span><br><span class="line">该<span class="keyword">sql</span>等同于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">0</span>,<span class="number">2</span></span><br><span class="line">表示从第<span class="number">0</span>条开始取两条数据</span><br></pre></td></tr></table></figure><p> limit常配合order by使用 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">3</span></span><br><span class="line">根据id排序，选出id排序前三的数据</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <strong>from&gt;join&gt;where&gt;group by&gt;聚合函数&gt;having&gt;select&gt;order by&gt;limit</strong> </p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">distinct</span> user.name </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">join</span> vip <span class="keyword">on</span> user.id<span class="operator">=</span>vip.id </span><br><span class="line"><span class="keyword">where</span> user.id<span class="operator">&gt;</span><span class="number">10</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user.mobile </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> user.id</span><br><span class="line">limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol><li> from user </li><li> join vip on user.id=vip.id ，join是表示要关联的表，on是连接的条件 </li><li> where user.id&gt;10  </li><li> group by user.mobile 根据user.mobile分组 </li><li> 然后先执行count(*)在执行having，查询分组之后数量大于2的分组<a href>数据</a> </li><li> select 对分组聚合完的表挑选出需要查询的<a href>数据</a> </li><li> distinct查询出来的<a href>数据</a>去重 </li><li> order by user.id 对去重后的<a href>数据</a><a href>排序</a> </li><li> limit 3对<a href>排序</a>后的<a href>数据</a>选出前面3条</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-SQL的执行顺序&quot;&gt;&lt;a href=&quot;#1-SQL的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;1.SQL的执行顺序&quot;&gt;&lt;/a&gt;1.SQL的执行顺序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; from&amp;gt;join&amp;gt;where&amp;gt</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux防火墙</title>
    <link href="https://gwtt.github.io/2022/09/05/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E5%90%AF/"/>
    <id>https://gwtt.github.io/2022/09/05/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E5%90%AF/</id>
    <published>2022-09-05T10:32:23.000Z</published>
    <updated>2022-09-05T10:35:55.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-防火墙开启指定端口"><a href="#Linux-防火墙开启指定端口" class="headerlink" title="Linux 防火墙开启指定端口"></a>Linux 防火墙开启指定端口</h3><p>通常情况下，CentOS 系统部署完成后，关闭并禁用防火墙。但有些特殊情况需要保持防火墙的启用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启用防火墙</span></span><br><span class="line">systemctl enable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看已经开放的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启指定端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=[端口号]/[协议] --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line">--zone=&lt;zone&gt; # 指定 zone</span><br><span class="line">--add-port=&lt;portid&gt;]/&lt;protocol&gt; # 端口id / 协议</span><br><span class="line">--permanent # 永久开启，不添加则重启失效</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭指定端口</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public –remove-port=[端口号]/[协议] --permanent</span><br><span class="line">firewall-cmd --zone=public –remove-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新加载防火墙</span></span><br><span class="line">systemctl reload firewalld</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux-防火墙开启指定端口&quot;&gt;&lt;a href=&quot;#Linux-防火墙开启指定端口&quot; class=&quot;headerlink&quot; title=&quot;Linux 防火墙开启指定端口&quot;&gt;&lt;/a&gt;Linux 防火墙开启指定端口&lt;/h3&gt;&lt;p&gt;通常情况下，CentOS 系统部署完</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="运维" scheme="https://gwtt.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Mysql代码例子</title>
    <link href="https://gwtt.github.io/2022/09/05/Mysql%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90/"/>
    <id>https://gwtt.github.io/2022/09/05/Mysql%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90/</id>
    <published>2022-09-05T10:21:18.000Z</published>
    <updated>2022-09-05T10:29:11.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立一个用户允许远程连接，并赋予对应库的权限"><a href="#建立一个用户允许远程连接，并赋予对应库的权限" class="headerlink" title="建立一个用户允许远程连接，并赋予对应库的权限"></a>建立一个用户允许远程连接，并赋予对应库的权限</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p;#用密码登录mysql数据库</span><br><span class="line">use mysql;#使用对应的数据库</span><br><span class="line">select host,user,password from user;#查看数据库所有用户和密码</span><br><span class="line"></span><br><span class="line">修改host：update user set host = &#x27;%&#x27; where user = &#x27;用户名&#x27;;</span><br><span class="line">刷新数据：flush privileges;</span><br><span class="line">#或者</span><br><span class="line">添加用户：grant all privileges on *.* to 用户名@&#x27;%&#x27; identified by &quot;用户密码&quot;;</span><br><span class="line">刷新数据：flush privileges;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建立一个用户允许远程连接，并赋予对应库的权限&quot;&gt;&lt;a href=&quot;#建立一个用户允许远程连接，并赋予对应库的权限&quot; class=&quot;headerlink&quot; title=&quot;建立一个用户允许远程连接，并赋予对应库的权限&quot;&gt;&lt;/a&gt;建立一个用户允许远程连接，并赋予对应库的</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="https://gwtt.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>gitlab自动部署</title>
    <link href="https://gwtt.github.io/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://gwtt.github.io/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2022-09-03T02:29:18.000Z</published>
    <updated>2022-09-05T05:08:22.295Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于GItlab CI/CD的自动部署方案</p><h3 id="GitLabCI-CD工作原理"><a href="#GitLabCI-CD工作原理" class="headerlink" title="GitLabCI/CD工作原理"></a>GitLabCI/CD工作原理</h3><blockquote><ul><li>将代码托管到Git存储库</li><li>在项目根目录创建ci文件.gitlab-ci.yml,在文件中指定构建、测试和部署脚本</li><li>GitLab将检测到它并使用名为GitLab Runner的工具运行脚本</li><li>脚本被分组为作业，它们共同组成一个管道 </li></ul><p>运行效果:</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904095646489.png" alt="image-20220904095646489"></p></blockquote><h3 id="首先什么我们要知道Gitlab是什么"><a href="#首先什么我们要知道Gitlab是什么" class="headerlink" title="首先什么我们要知道Gitlab是什么"></a>首先什么我们要知道Gitlab是什么</h3><blockquote><p>是一种类似github的服务，组织可以使用它来提供git存储库的内部管理。 它是一个自我托管的Git-repository管理系统，可以保持用户代码的私密性，并且可以轻松地部署代码的更改。</p></blockquote><h3 id="GitLab安装"><a href="#GitLab安装" class="headerlink" title="GitLab安装"></a>GitLab安装</h3><blockquote><ul><li>检查配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The following is the recommended minimum CPU hardware guidance for a handful of example GitLab user base sizes.</span><br><span class="line"></span><br><span class="line">4 cores is the recommended minimum number of cores and supports up to 500 users</span><br><span class="line">8 cores supports up to 1000 users</span><br><span class="line"></span><br><span class="line">The following is the recommended minimum Memory hardware guidance for a handful of example GitLab user base sizes.</span><br><span class="line"></span><br><span class="line">4GB RAM is the required minimum memory size and supports up to 500 users</span><br><span class="line">8GB RAM supports up to 1000 users</span><br><span class="line"></span><br><span class="line">一般来说，两核八GB就够用了</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查询cpu指令</span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line">查询内存指令</span><br><span class="line">cat /proc/meminfo</span><br><span class="line">查询Linux内核版本</span><br><span class="line">cat /proc/version</span><br><span class="line">友情提示：如果是一核两G不用试了</span><br></pre></td></tr></table></figure><ul><li>使用rpm包安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/e17/gitlab-ce-15.3.2-ce.0.el7.x86_64.rpm</span><br><span class="line">rpm -ivh gitlab-ce-15.3.2-ce.0.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">vim /etc/gitlab.rb #编辑站点地址</span><br><span class="line"></span><br><span class="line">gitlab-ctl reconfigure #配置</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">启动</span></span><br><span class="line">gitlab-ctl start</span><br><span class="line">状态</span><br><span class="line">gitlab-ctl status</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">停止</span></span><br><span class="line">gitlab-ctl stop</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">重启</span></span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><p>另外docker安装和kubernetes安装就不赘述了</p></blockquote><h3 id="GitLab-Runner介绍相关"><a href="#GitLab-Runner介绍相关" class="headerlink" title="GitLab Runner介绍相关"></a>GitLab Runner介绍相关</h3><blockquote><h3 id="GitLab-Runner简介"><a href="#GitLab-Runner简介" class="headerlink" title="GitLab Runner简介:"></a>GitLab Runner简介:</h3><ul><li>GitLab Runner是一个开源项目，用于运行作业并将结果发送GitLab</li><li>与GitLabCI结合使用，GitLabCI是GitLab随附的用于协调作业的开源持续集成服务</li><li>GitLab Runner是用Go编写的，可以在Linux,macOS和Windos操作系统上运行</li><li>容器部署需使用最新Docker版本。</li><li>可以根据配置需要配置任意数量的Runner</li></ul><h3 id="Runner特点"><a href="#Runner特点" class="headerlink" title="Runner特点:"></a>Runner特点:</h3><ul><li><p>作业运行控制：同时执行多个作业</p></li><li><p>作业运行环境:</p><ol><li>在本地、使用Docker容器、使用Docker容器并通过SSH执行作业</li><li>使用Docker容器在不同的云和虚拟化管理程序上自动缩放</li><li>连接到远程SSH服务器</li></ol></li><li><p>自动重新加载配置，无需重启</p></li><li><p>易于安装，可作为Linux,macOS和Windos的服务</p></li></ul><h3 id="GitLab-Runner类型与状态"><a href="#GitLab-Runner类型与状态" class="headerlink" title="GitLab Runner类型与状态"></a>GitLab Runner类型与状态</h3><ul><li>类型:<ul><li>shared 共享类型,运行整个平台项目的作业</li><li>group项目组类型，运行特定group下所有项目的作业</li><li>specific项目类型，运行指定的项目作业</li></ul></li><li>状态<ul><li>locked：锁定状态，无法运行项目作业</li><li>paused：暂停状态，暂时不会接受新的作业</li></ul></li></ul><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220903215422460.png" alt="image-20220903215422460"></p></blockquote><h3 id="GitLab-Runner安装相关"><a href="#GitLab-Runner安装相关" class="headerlink" title="GitLab Runner安装相关"></a>GitLab Runner安装相关</h3><blockquote><p>包管理工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Add the official GitLab repository 添加官方仓库</span><br><span class="line">curl -L &quot;https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh&quot; | sudo bash</span><br><span class="line"></span><br><span class="line">Install the latest version of GitLab Runner, or skip to the next step to install a specific version 安装最新版本或者下一步</span><br><span class="line">sudo yum install gitlab-runner</span><br><span class="line"></span><br><span class="line">To install a specific version of GitLab Runner:安装指定版本</span><br><span class="line">yum list gitlab-runner --showduplicates | sort -r</span><br><span class="line">sudo yum install gitlab-runner-10.0.0-1</span><br><span class="line"></span><br><span class="line">更新runner</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install gitlab-runner</span><br></pre></td></tr></table></figure></blockquote><h3 id="GitLab-Runner注册"><a href="#GitLab-Runner注册" class="headerlink" title="GitLab Runner注册"></a>GitLab Runner注册</h3><blockquote><p>获取shared类型runnertoken</p><p>进入系统设置-&gt;Runners</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904160532695.png" alt="image-20220904160532695"></p><p>同理也可以找到对应得group CI/CD Runner和单项目得CI/CD Runner</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/gitlab-runner register --locked=&quot;false&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向GitLab-CI注册一个Runner需要两样东西：</span></span><br><span class="line">GitLab-CI的url和注册token。 其中，token是为了确定你这个Runner是所有工程都能够使用的Shared Runner还是具体某一个工程才能使用的Specific Runner。 如果要注册Shared Runner，你需要到管理界面的Runners页面里面去找注册token。如下图所示</span><br></pre></td></tr></table></figure><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220903215549856.png" alt="image-20220903215549856"></p><p>GitLab CI/CD支持的执行器有很多种，最常用的是Docker， shell，Kubernets三种。</p><p>Shell 是最易于配置的执行器。构建中所需的依赖得你手工装在 Runner 所在机器上。</p><p>更好的方式是使用 Docker，它让你拥有干净的构建环境，以及简易的依赖管理——所有的编译项目所需的依赖都可以放进 Docker 镜像中。Docker 执行器很容易就能创建带有依赖服务的编译环境，比如 MySQL。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -v v/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor &quot;docker&quot; \</span><br><span class="line">  --docker-image alpine:latest \</span><br><span class="line">  --url &quot;url&quot; \# 网页端域名 </span><br><span class="line">  --registration-token &quot;token&quot; \# gitlab提供的token</span><br><span class="line">  --description &quot;first-register-runner&quot; \</span><br><span class="line">  --tag-list &quot;test-cicd1,dockercicd1&quot; \</span><br><span class="line">  --run-untagged=&quot;true&quot; \</span><br><span class="line">  --locked=&quot;false&quot; \</span><br><span class="line">  --access-level=&quot;not_protected&quot;</span><br></pre></td></tr></table></figure></blockquote><h3 id="gitlab-ci-yml文件"><a href="#gitlab-ci-yml文件" class="headerlink" title=".gitlab-ci.yml文件"></a>.gitlab-ci.yml文件</h3><blockquote><p>如何检查你的yml文件是否符合,可以用CI Lint</p><p><img src="/2022/09/03/gitlab%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/image-20220904164146671-16623544839293.png" alt="image-20220904164146671"></p></blockquote><h2 id="Pipeline语法"><a href="#Pipeline语法" class="headerlink" title="Pipeline语法"></a>Pipeline语法</h2><h3 id="1-Job"><a href="#1-Job" class="headerlink" title="1.Job"></a>1.Job</h3><blockquote><p>在.gitlab-ci.yml的文件中，可以定义一个或多个作业（job）。每个作业必须具有唯一的名称（不能使用关键字），每个作业是独立执行。作业定义了在约束条件下进行相关操作，每一个作业至少要包含至少一个script</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">&quot;execute-script-for-job1&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-script"><a href="#2-script" class="headerlink" title="2.script"></a>2.script</h3><blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure><p>有时，script命令将需要用单引号或双引号引起来。例如，包含冒号命令(:)需要加引号，以便被包裹的YAML解析器知道来解释整个事情作为一个字符串，而不是一个”键:值”对.使用特殊字符时要小心<code>:</code> ,<code>&#123;</code>,<code>&#125;</code>,<code>[</code>,<code>]</code>, <code>,</code> 等等</p></blockquote><h3 id="3-before-script"><a href="#3-before-script" class="headerlink" title="3.before_script"></a>3.before_script</h3><blockquote><p>跟script差不多，只不过在作业之前运行，如果失败则整个任务失败，作业失败不会影响after_sciprt</p></blockquote><h3 id="4-stages"><a href="#4-stages" class="headerlink" title="4.stages"></a>4.stages</h3><blockquote><p>用于定义作业可以使用的阶段，并且是全局定义的。同一阶段的作业并行运行，不同阶段按顺序执行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">codescan</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="5-pre-amp-post"><a href="#5-pre-amp-post" class="headerlink" title="5. .pre&amp;.post"></a>5. .pre&amp;.post</h3><blockquote><p>.pre始终是整个管道的第一个运行阶段, .post始终是整个管道的最后一个运行阶段。用户定义的阶段都在两者之间运行。.pre和.post的顺序无法更改。如果管道仅包含.pre或.post阶段的作业，则不会创建管道</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codescan:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">.pre</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;codescan&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="6-tags-指定runner"><a href="#6-tags-指定runner" class="headerlink" title="6.tags(指定runner)"></a>6.tags(指定runner)</h3><blockquote><p>用于从允许运行该项目的所有Runner列表中选择特定的Runner，在Runner注册期间，您可以指定Runner标签</p></blockquote><h3 id="7-allow-failure允许失败"><a href="#7-allow-failure允许失败" class="headerlink" title="7.allow_failure允许失败"></a>7.allow_failure允许失败</h3><blockquote><p>allow_failure允许作业失败，默认值为false。启用后，如果作业失败，将会在用户界面中显示橙色警告。但是，管道的逻辑流程将认为作业成功/通过，并且不会阻塞。假设所有其他作业均成功，则该作业的阶段及其管道将显示相同的橙色警告。但是，关联的提交将被标记”通过”,而不会发出警告。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">execute</span></span><br><span class="line">  <span class="attr">allow_failure:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">MAVEN_CLI_OPTS:</span> <span class="string">&quot;--batch-mode --errors --fail-at-end --show-version -s .m2/settings.xml&quot;</span></span><br><span class="line">  <span class="attr">MAVEN_OPTS:</span> <span class="string">&quot;-Dmaven.repo.local=.m2/repository&quot;</span></span><br><span class="line">  <span class="attr">PACKAGE_NAME:</span> <span class="string">&quot;certificate.jar&quot;</span></span><br><span class="line">  <span class="attr">PACKAGE_BACK_NAME:</span> <span class="string">&quot;certificateBack.jar&quot;</span></span><br><span class="line">  <span class="attr">PROD_ENV_1:</span> <span class="string">&quot;10.166.41.101&quot;</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">maven:3.8.1-openjdk-11</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">$&#123;CI_COMMIT_REF_SLUG&#125;</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.m2/repository</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sacc/target/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;cd sacc&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mvn $MAVEN_CLI_OPTS package -Dmaven.test.skip=true -Pprod&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al target&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-prod:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh/&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;echo &quot;$SSH_PRIVATE_KEY&quot; &gt;&gt; ./id_rsa &amp;&amp; chmod 600 ./id_rsa&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;echo -e &quot;Host *\n\tStrictHostKeyChecking no\n\n&quot; &gt; ~/.ssh/config&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ls -al sacc/target&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;yum install net-tools&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;/bin/cp -rf /opt/webapps/certificate/$PACKAGE_NAME \&quot;/opt/webapps/certificate/$PACKAGE_NAME.$(date +\&quot;%y%m%d\&quot;)\&quot;&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;scp -i ./id_rsa -r sacc/target/$PACKAGE_NAME root@$PROD_ENV_1:/opt/webapps/certificate/$PACKAGE_NAME&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;cp /dev/null /opt/webapps/certificate/nohup.out&quot;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;ssh -i ./id_rsa root@$PROD_ENV_1 \&quot;pkill -f certificate.jar\&quot;&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;ssh -i ./id_rsa root@$PROD_ENV_1 &quot;nohup java -jar /opt/webapps/certificate/certificate.jar &amp;&gt; /opt/webapps/certificate/nohup.out &amp;&quot;&#x27;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是关于GItlab CI/CD的自动部署方案&lt;/p&gt;
&lt;h3 id=&quot;GitLabCI-CD工作原理&quot;&gt;&lt;a href=&quot;#GitLabCI-CD工作原理&quot; class=&quot;headerlink&quot; title=&quot;GitLabCI/CD工作原理&quot;&gt;&lt;/a&gt;GitLabCI/</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="运维" scheme="https://gwtt.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>五种IO模型</title>
    <link href="https://gwtt.github.io/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gwtt.github.io/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-09-01T10:54:21.938Z</published>
    <updated>2022-09-01T11:45:02.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的三大IO模型"><a href="#Java中的三大IO模型" class="headerlink" title="Java中的三大IO模型"></a>Java中的三大IO模型</h2><p>在JDK1.4之前，基于Java所有的socket通信都采用了同步阻塞模型（BIO），这种模型性能低下，当时大型的服务均采用C或C++开发，因为它们可以直接使用操作系统提供的异步IO或者AIO，使得性能得到大幅提升。</p><p>2002年，JDK1.4发布，新增了java.nio包，提供了许多异步IO开发的API和类库。新增的NIO，极大的促进了基于Java的异步非阻塞的发展和应用。</p><p>2011年，JDK7发布，将原有的NIO进行了升级，称为NIO2.0，其中也对AIO进行了支持。</p><h3 id="BIO模型"><a href="#BIO模型" class="headerlink" title="BIO模型"></a>BIO模型</h3><blockquote><p>java中的BIO是blocking I/O的简称，它是同步阻塞型IO，其相关的类和接口在java.io下。</p><p>BIO模型简单来讲，就是服务端为每一个请求都分配一个线程进行处理，如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/e8e029a04700e7f4523e63108c6c771992b4b1be.png@942w_497h_progressive.webp" alt="img"></p><p>示例代码：</p><p>public class BIOServer {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等待客户端连接。。。。&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">//阻塞</span></span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream(); <span class="comment">//阻塞</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                    <span class="keyword">if</span>(length == -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, length, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}<br>这种模式存在的问题：</p><p>客户端的并发数与后端的线程数成1:1的比例，线程的创建、销毁是非常消耗系统资源的，随着并发量增大，服务端性能将显著下降，甚至会发生线程堆栈溢出等错误。</p><p>当连接创建后，如果该线程没有操作时，会进行阻塞操作，这样极大的浪费了服务器资源。</p></blockquote><h3 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h3><blockquote><p>NIO，称之为New IO 或是 non-block IO （非阻塞IO），这两种说法都可以，其实称之为非阻塞IO更恰当一些。</p><p>NIO相关的代码都放在了java.nio包下，其三大核心组件：Buffer（缓冲区）、Channel（通道）、Selector（选择器/多路复用器）</p><p>Buffer</p><p>在NIO中，所有的读写操作都是基于缓冲区完成的，底层是通过数组实现的，常用的缓冲区是ByteBuffer，每一种java基本类型都有对应的缓冲区对象（除了Boolean类型），如：CharBuffer、IntBuffer、LongBuffer等。</p><p>Channel</p><p>在BIO中是基于Stream实现，而在NIO中是基于通道实现，与流不同的是，通道是双向的，既可以读也可以写。</p><p>Selector</p><p>Selector是多路复用器，它会不断的轮询注册在其上的Channel，如果某个Channel上发生读或写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey获取就绪Channel的集合，进行IO的读写操作。</p><p>基本示意图如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/262bc99c60a8dacc1116aff1585ec53655e1c44b.png@942w_509h_progressive.webp" alt="img"></p><p>可以看出，NIO模型要优于BIO模型，主要是：</p><p>通过多路复用器就可以实现一个线程处理多个通道，避免了多线程之间的上下文切换导致系统开销过大。</p><p>NIO无需为每一个连接开一个线程处理，并且只有通道真正有有事件时，才进行读写操作，这样大大的减少了系统开销。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectorDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Selector <span class="title function_">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取selector对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取通道并且绑定端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6677</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册感兴趣的事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="built_in">this</span>.getSelector();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select(); <span class="comment">//该方法会阻塞，直到至少有一个事件的发生</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                process(selectionKey, selector);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable())&#123; <span class="comment">//新连接请求</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel)key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123; <span class="comment">//读数据</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel)key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;form 客户端 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(), <span class="number">0</span>, byteBuffer.position()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SelectorDemo</span>().listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="AIO模型"><a href="#AIO模型" class="headerlink" title="AIO模型"></a>AIO模型</h3><blockquote><p>在NIO中，Selector多路复用器在做轮询时，如果没有事件发生，也会进行阻塞，如何能把这个阻塞也优化掉呢？那么AIO就在这样的背景下诞生了。</p><p>AIO是asynchronous I/O的简称，是异步IO，该异步IO是需要依赖于操作系统底层的异步IO实现。</p><p>AIO的基本流程是：用户线程通过系统调用，告知kernel内核启动某个IO操作，用户线程返回。kernel内核在整个IO操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。</p><ul><li><p>kernel的数据准备</p><p>将数据从网络物理设备（网卡）读取到内核缓冲区。</p></li><li><p>kernel的数据复制</p><p>将数据从内核缓冲区拷贝到用户程序空间的缓冲区。</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/583df5514d2c98bf09ae08637144d8e96e47704f.png@731w_681h_progressive.webp" alt="img"></p><p>目前AIO模型存在的不足：</p><ol><li><p>需要完成事件的注册与传递，这里边需要底层操作系统提供大量的支持，去做大量的工作。</p></li><li><p>Windows 系统下通过 IOCP 实现了真正的异步 I/O。但是，就目前的业界形式来说，Windows 系统，很少作为百万级以上或者说高并发应用的服务器操作系统来使用。</p></li><li><p>而在 Linux 系统下，异步IO模型在2.6版本才引入，目前并不完善。所以，这也是在 Linux 下，实现高并发网络编程时都是以 NIO 多路复用模型模式为主。</p></li></ol></li></ul></blockquote><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><blockquote><p>Reactor线程模型不是Java专属，也不是Netty专属，它其实是一种并发编程模型，是一种思想，具有指导意义。比如，Netty就是结合了NIO的特点，应用了Reactor线程模型所实现的。</p><p>Reactor模型中定义的三种角色：</p><ul><li>Reactor：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li>Acceptor：处理客户端新连接，并分派请求到处理器链中。</li><li>Handler：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。</li></ul><p>常见的Reactor线程模型有三种，如下：</p><ul><li>Reactor单线程模型</li><li>Reactor多线程模型</li><li>主从Reactor多线程模型</li></ul><h4 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/9d48bbccca4988a42fceda53b7faef999a4593c0.png@942w_381h_progressive.webp" alt="img"></p><p>说明:</p><ul><li>Reactor充当多路复用器角色，监听多路连接的请求，由单线程完成</li><li>Reactor收到客户端发来的请求时，如果是新建连接通过Acceptor完成，其他的请求Handler完成。</li><li>Handler完成业务逻辑的处理，基本的流程是：Read –&gt; 业务处理 –&gt; Send 。</li></ul><p>这种模型优点:</p><ul><li>结构简单，由单线程完成，没有多线程、进程通信等问题</li><li>适合在一些业务逻辑比较简单、对于性能要求不高的应用场景</li></ul><p>缺点：</p><ul><li>由于是单线程操作、不能充分发挥多核CPU的性能</li><li>当Reactor线程负载过重之后、处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重Reactor线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈。</li><li>可靠性差，如果该线程进入死循环或意外终止，就会导致整个通信系统不可用，容易造成单点故障。 </li></ul><h4 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/0a19c9de9af761ed990068f2f48871268bd0cb02.png@942w_576h_progressive.webp" alt="img"></p><p>说明:</p><ul><li>在Reactor多线程模型相比较单线程模型而言，不同点在于，Handler不会处理业务逻辑，只是负责响应用户请求，真正的业务逻辑，在另外的线程中完成。</li><li>这样可以降低Reactor的性能开销，充分利用CPU资源，从而更专注的做事件分发工作了，提升整个应用的吞吐。 </li></ul><p>但是这个模型存在的问题：</p><ul><li><p>多线程数据共享和访问比较复杂。如果子线程完成业务处理后，把结果传递给主线程Reactor进行发送，就会涉及共享数据的互斥和保护机制。</p></li><li><p>Reactor承担所有事件的监听和响应，只在主线程中运行，可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。</p></li></ul><p>为了解决性能问题，产生了第三种主从Reactor多线程模型。</p><h4 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h4><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/348b425d88ffbce6873196c1ca299f07320f70ac.png@942w_432h_progressive.webp" alt="img"></p><p>在主从模型中，将Reactor分成2部分：</p><ul><li>MainReactor负责监听server socket，用来处理网络IO连接建立操作，将建立的socketChannel指定注册给SubReactor。</li><li>SubReactor主要完成和建立起来的socket的数据交互和事件业务处理操作。</li></ul><p>该模型的优点：</p><ul><li><p>响应快，不必为单个同步事件所阻塞，虽然Reactor本身依然是同步的。</p></li><li><p>可扩展性强，可以方便地通过增加SubReactor实例个数来充分利用CPU资源。</p></li><li><p>可复用性高，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性。</p></li></ul></blockquote><h3 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h3><blockquote><p>Netty模型是基于Reactor模型实现的，对于以上三种模型都有非常好的支持，也非常的灵活，一般情况，在服务端会采用主从架构模型，基本示意图如下：</p><p><img src="/2022/09/01/%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/a463c8eb5c2ebd4db875eed66346404d55c741b6.png@942w_369h_progressive.webp" alt="img"></p><p>说明：</p><ul><li><p>在Netty模型中，负责处理新连接事件的是BossGroup，负责处理其他事件的是WorkGroup。Group就是线程池的概念。</p></li><li><p>NioEventLoop表示一个不断循环的执行处理任务的线程，用于监听绑定在其上的读/写事件。</p></li><li><p>通过Pipeline（管道）执行业务逻辑的处理，Pipeline中会有多个ChannelHandler，真正的业务逻辑是在ChannelHandler中完成的。</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java中的三大IO模型&quot;&gt;&lt;a href=&quot;#Java中的三大IO模型&quot; class=&quot;headerlink&quot; title=&quot;Java中的三大IO模型&quot;&gt;&lt;/a&gt;Java中的三大IO模型&lt;/h2&gt;&lt;p&gt;在JDK1.4之前，基于Java所有的socket通信都采用</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Linux" scheme="https://gwtt.github.io/tags/Linux/"/>
    
    <category term="IO" scheme="https://gwtt.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>浅谈AQS</title>
    <link href="https://gwtt.github.io/2022/09/01/%E6%B5%85%E8%B0%88AQS/"/>
    <id>https://gwtt.github.io/2022/09/01/%E6%B5%85%E8%B0%88AQS/</id>
    <published>2022-09-01T09:53:23.000Z</published>
    <updated>2022-09-01T10:43:11.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h3><blockquote><p>AQS:全称是AbstractQuenedSynchronizer（抽象队列同步器）。是除了java自带的synchronized关键字之外的锁机制。</p></blockquote><h3 id="AQS的核心思想是"><a href="#AQS的核心思想是" class="headerlink" title="AQS的核心思想是:"></a><strong>AQS的核心思想</strong>是:</h3><blockquote><p> 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH（Craig，Landin，and Hagersten locks）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p><p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p><p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p><p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong></p></blockquote><p><img src="/2022/09/01/%E6%B5%85%E8%B0%88AQS/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211bGluc2VuNzc=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>如图示，AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line"></span><br><span class="line">setState()</span><br><span class="line"></span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure><p>AQS 定义了两种资源共享方式：<br>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(<span class="type">int</span>)：独占方式。尝试获取资源，成功则返回<span class="literal">true</span>，失败则返回<span class="literal">false</span>。</span><br><span class="line">tryRelease(<span class="type">int</span>)：独占方式。尝试释放资源，成功则返回<span class="literal">true</span>，失败则返回<span class="literal">false</span>。</span><br><span class="line">tryAcquireShared(<span class="type">int</span>)：共享方式。尝试获取资源。负数表示失败；<span class="number">0</span>表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(<span class="type">int</span>)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure><h3 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h3><p>AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; write.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用实现"><a href="#应用实现" class="headerlink" title="应用实现"></a>应用实现</h3><ul><li><p>Lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>通过注释我们知道，acquire方法是一种互斥模式，且忽略中断。该方法至少执行一次tryAcquire(int)方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。函数流程如下：</p><ul><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ul><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>1.判断状态位是否为0,0是可以占用,如果是0的话占用,不是0的话返回false</p><p>2.判断当前线程是否为得到位置的线程,比如如果前一个线程走了,然后又回来有点事情的话,那么返回false</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;AQS的原理&quot;&gt;&lt;a href=&quot;#AQS的原理&quot; class=&quot;headerlink&quot; title=&quot;AQS的原理&quot;&gt;&lt;/a&gt;AQS的原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;AQS:全称是AbstractQuenedSynchronizer（抽象队列同步器</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Juc" scheme="https://gwtt.github.io/tags/Juc/"/>
    
  </entry>
  
  <entry>
    <title>手动实现栈和队列</title>
    <link href="https://gwtt.github.io/2022/09/01/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://gwtt.github.io/2022/09/01/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-09-01T04:55:57.000Z</published>
    <updated>2022-09-01T09:41:55.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-手动实现栈"><a href="#1-手动实现栈" class="headerlink" title="1. 手动实现栈"></a>1. 手动实现栈</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[]stack;<span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;<span class="comment">//当前可以存放数据元素的下标——&gt;栈顶指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用构造函数给定一个初始容量10的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">( )</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.stack = (T[])<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];<span class="comment">//泛型不能实例化对象，但是可以类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否满了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (stack.length == <span class="built_in">this</span>.top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.top == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//判断栈是否已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="built_in">this</span>.stack = Arrays.copyOf(stack,<span class="number">2</span>*stack.length);<span class="comment">//满了就扩容成原来容量的两倍</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.stack[<span class="built_in">this</span>.top] = value;<span class="comment">//给top位置添加元素</span></span><br><span class="line">        <span class="built_in">this</span>.top++;<span class="comment">//top指针指向下一可用空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈操作，并返回弹出（删除）栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.top-<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.top--;</span><br><span class="line">        <span class="keyword">return</span> ret;<span class="comment">//返回删除的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到栈顶元素，但是不删除</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回栈顶元素，不删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stack[top-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示栈元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top-<span class="number">1</span>; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            System.out.print(stack[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-手动实现队列"><a href="#2-手动实现队列" class="headerlink" title="2.手动实现队列"></a>2.手动实现队列</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">//队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.first == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//尾插法，要判断是否第一次插入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.first == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.first = node;</span><br><span class="line">            <span class="built_in">this</span>.last = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.last.setNext(node);</span><br><span class="line">            <span class="built_in">this</span>.last = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="built_in">this</span>.first.getVal();</span><br><span class="line">        <span class="built_in">this</span>.first = <span class="built_in">this</span>.first.getNext();</span><br><span class="line">        <span class="keyword">return</span> ret;<span class="comment">//返回出队元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到队头元素但是不删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不要移动first</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.first.getVal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>.first;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.getVal()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-手动实现栈&quot;&gt;&lt;a href=&quot;#1-手动实现栈&quot; class=&quot;headerlink&quot; title=&quot;1. 手动实现栈&quot;&gt;&lt;/a&gt;1. 手动实现栈&lt;/h3&gt;&lt;blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="java知识" scheme="https://gwtt.github.io/categories/java%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="java基础" scheme="https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的MVCC</title>
    <link href="https://gwtt.github.io/2022/08/30/Mysql%E7%9A%84MVCC/"/>
    <id>https://gwtt.github.io/2022/08/30/Mysql%E7%9A%84MVCC/</id>
    <published>2022-08-30T07:06:22.000Z</published>
    <updated>2022-08-30T09:32:54.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><blockquote><p><strong><code>MVCC</code><strong>，全称 <code>Multi-Version Concurrency Control</code> ，即多版本并发控制。</strong>mvcc</strong>，它是一种并发控制方法，一般在数据库管理系统中，实现数据库的并发访问，在编程语言中实现事务内存。</p><p><strong>总结：</strong>主要为了提升并发性能</p></blockquote><h3 id="为什么需要MVCC"><a href="#为什么需要MVCC" class="headerlink" title="为什么需要MVCC"></a>为什么需要MVCC</h3><blockquote><p><strong>数据库原生的锁</strong><br>        最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。</p><p><strong>读写锁的出现</strong><br>        读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够</p><p><strong>mvcc概念出现</strong><br>        能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能</p></blockquote><h3 id="MVCC适用于的事务隔离级别"><a href="#MVCC适用于的事务隔离级别" class="headerlink" title="MVCC适用于的事务隔离级别"></a>MVCC适用于的事务隔离级别</h3><blockquote><p>MVCC只在 READ COMMITTED (读取已提交) 和 REPEATABLE READ (可重复读) 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED (读取未提交) 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE (可串行化) 则会对所有读取的行都加锁。</p></blockquote><h3 id="MVCC实现原理✔"><a href="#MVCC实现原理✔" class="headerlink" title="MVCC实现原理✔"></a>MVCC实现原理✔</h3><blockquote><p><strong>MVCC</strong>的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <strong><code>3个隐式字段</code><strong>，</strong><code>undo日志</code></strong> ，**<code>Read View</code>** 来实现的。</p><h3 id="3个隐式字段"><a href="#3个隐式字段" class="headerlink" title="3个隐式字段"></a>3个隐式字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`DB_TRX_ID`, `DB_ROLL_PTR`, `DB_ROW_ID</span><br></pre></td></tr></table></figure><table><thead><tr><th>列名</th><th>长度（字节）</th><th>作用</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>6</td><td>插入或更新行的最后一个事务的事务标识符。（删除视为更新，将其标记为已删除）</td></tr><tr><td>DB_ROLL_PTR</td><td>7</td><td>写入回滚段的撤销日志记录（若行已更新，则撤销日志记录包含在更新之前重建行内容所需的信息）</td></tr><tr><td>DB_ROW_ID</td><td>6</td><td>行标识（隐藏单调自增id）</td></tr></tbody></table><p>比如:</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><p> <code>DB_ROW_ID</code> 是数据库默认为该行记录生成的唯一隐式主键，<code>DB_TRX_ID</code> 是当前操作该记录的事务 ID ,而 <code>DB_ROLL_PTR</code> 是一个回滚指针，用于配合 undo日志，指向上一个旧版本</p><p> <strong>事务A：</strong>对数据进行了修改（将name中的张三改为李四）</p><ul><li>第一步：用<strong>排他锁</strong>锁定这一条记录</li></ul><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><ul><li> 第二步：UNDOLOG会记录日志，作为旧记录，既在 <code>undo log</code> 中有当前行的拷贝副本</li></ul><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><ul><li> 第三步：将回滚指针的值copy到UNDOLOG中</li></ul><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR(这就是存储回滚指针的值)</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>ox29349384</td></tr></tbody></table><ul><li>第四步：修改当前的name值并且修改隐藏字段的事务 ID 为当前<code>事务 1</code>的 ID, 我们默认从 <code>1</code> 开始，之后递增，回滚指针指向拷贝到 <code>undo log</code> 的副本记录，既表示我的上一个版本就是它</li></ul><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR(这就是存储回滚指针的值)</th></tr></thead><tbody><tr><td>1</td><td>李四</td><td>18</td><td>1</td><td>1</td><td>ox29349384</td></tr></tbody></table><p><strong>事务B：</strong>事务A修改但未提交，同时对事务B也对该行数据做了修改</p><p>下表就是事务B做出的改变（改变的是年龄）</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td><strong>30</strong></td><td>1</td><td>2</td><td>ox23874982</td></tr></tbody></table><p>  上表的ox23874982指的地址是下表的地址</p><table><thead><tr><th>UNDO_LOG</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>id</td><td>name</td><td>age</td><td>DB_ROW_ID</td><td>DB_TRX_ID</td><td>DB_ROLL_PTR</td></tr><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>1</td><td>ox29349384</td></tr></tbody></table><p>上表的ox29349384指的地址是下表的地址</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>DB_ROW_ID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>18</td><td>1</td><td>空</td><td>空</td></tr></tbody></table><p>所以总结:</p><p>如果有当前事务，最早事务，最晚事务</p><p>最早事务ID&lt;当前事务ID&lt;最晚事务ID</p><ul><li>事务的排他锁形式修改数据</li><li>修改之前先把数据放到undolog，通过回滚指针关联</li><li>失败了从undolog回滚</li></ul></blockquote><h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><blockquote><p>insert undo log<br>代表事务在 insert 新记录时产生的 undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>update undo log<br>事务在进行 update 或 delete 时产生的 undo log ; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除<br>在不考虑redo log 的情况下利用undo log工作的简化过程为：</p><table><thead><tr><th>序号</th><th>动作</th></tr></thead><tbody><tr><td>1</td><td>开始事务</td></tr><tr><td>2</td><td>记录数据行数据快照到undolog</td></tr><tr><td>3</td><td>更新数据</td></tr><tr><td>4</td><td>将undolog写到磁盘</td></tr><tr><td>5</td><td>将数据写到磁盘</td></tr><tr><td>6</td><td>提交事务</td></tr></tbody></table><p> 1）为了保证数据的持久性数据要在事务提交之前持久化</p><p> 2）undo log的持久化必须在在数据持久化之前，这样才能保证系统崩溃时，可以用undo log来回滚事务</p></blockquote><h3 id="执行流程如下："><a href="#执行流程如下：" class="headerlink" title="执行流程如下："></a><strong>执行流程如下：</strong></h3><blockquote><p>*<em>一、比如一个有个事务插入 persion 表插入了一条新记录，记录如下，<code>name</code> 为 小明 , <code>age</code> 为 10 岁，*</em><code>隐式主键</code>*<em>是 1，*</em><code>事务 ID</code>*<em>和*</em><code>回滚指针</code>*<em>，我们假设为 NULL</em>*</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830171156856.png" alt="image-20220830171156856"></p><p><strong>二、 现在来了一个事务 1对该记录的 name 做出了修改，改为 小红</strong></p><ul><li>在<code>事务 1</code>修改该行(记录)数据时，数据库会先对该行加<code>排他锁</code></li></ul><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830171325637.png" alt="image-20220830171325637"></p><ul><li>然后把该行数据拷贝到 <code>undo log</code> 中，作为旧记录，既在 <code>undo log</code> 中有当前行的拷贝副本</li></ul><p>Undo日志</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172747995.png" alt="image-20220830172747995"></p><ul><li><p>拷贝完毕后，修改该行<code>name</code>为小红，并且修改隐藏字段的事务 ID 为当前<code>事务 1</code>的 ID, 我们默认从 <code>1</code> 开始，之后递增，回滚指针指向拷贝到 <code>undo log</code> 的副本记录，既表示我的上一个版本就是它</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172826227.png" alt="image-20220830172826227"></p><p>上个表的回滚指针地址指的是下个表</p><p><img src="/2022/08/30/Mysql%E7%9A%84MVCC/image-20220830172852127.png" alt="image-20220830172852127"></p></li><li><p>事务提交后，释放锁</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是MVCC&quot;&gt;&lt;a href=&quot;#什么是MVCC&quot; class=&quot;headerlink&quot; title=&quot;什么是MVCC&quot;&gt;&lt;/a&gt;什么是MVCC&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;MVCC&lt;/code&gt;&lt;strong&gt;，全称 </summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>聚集索引和非聚集索引</title>
    <link href="https://gwtt.github.io/2022/08/29/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
    <id>https://gwtt.github.io/2022/08/29/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/</id>
    <published>2022-08-29T08:51:49.429Z</published>
    <updated>2022-08-29T09:10:55.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><h3 id="什么是聚集索引"><a href="#什么是聚集索引" class="headerlink" title="什么是聚集索引"></a>什么是聚集索引</h3><blockquote><p>聚集索引是将<strong>索引列字段</strong>和<strong>行记录数据</strong>维护在了一起,它的叶子节点存储的是 <strong>索引列字段 + 完整的行记录数据</strong>,通过聚集索引能直接获取到整行数据</p><p>Innodb 的主键索引就是基于聚集索引实现的</p><p>通俗点讲:利用聚集索引可以<strong>直接</strong>获取对应的元素数据</p><p><img src="https://img2022.cnblogs.com/blog/1636535/202204/1636535-20220427020132699-1363305095.png" alt="img"></p></blockquote><h3 id="什么是非聚集索引"><a href="#什么是非聚集索引" class="headerlink" title="什么是非聚集索引"></a>什么是非聚集索引</h3><blockquote><p>非聚集索引是相比较于聚集索引来说,它是把<strong>索引和行数据分开维护</strong>,叶子节点并没有包含完整的数据记录(叶子节点的数据区存储的是聚集索引的 id 或 数据的磁盘地址)Mysql 非聚集索引底层的数据结构也是 b+ 树,例如 Myisam 的索引、Innodb 的辅助索引</p><p><img src="https://img2022.cnblogs.com/blog/1636535/202204/1636535-20220428224329312-1207567303.png" alt="img"></p><p>比如在搜索年龄为41的数据时，会找到13，然后再去找利用聚集索引找主键为13的数据</p></blockquote><h3 id="回表（尽量去减少回表的产生）"><a href="#回表（尽量去减少回表的产生）" class="headerlink" title="回表（尽量去减少回表的产生）"></a>回表（尽量去减少回表的产生）</h3><blockquote><p>当通过非聚集索引来查询数据时,存储引擎会根据索引字段定位到最底层的叶子节点,并通过叶子节点获得指向主键索引的主键 id,然后通过主键 id 去主键索引(聚集索引)上找到一个完整的行记录.这个过程被称为 <strong>回表</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;聚集索引和非聚集索引&quot;&gt;&lt;a href=&quot;#聚集索引和非聚集索引&quot; class=&quot;headerlink&quot; title=&quot;聚集索引和非聚集索引&quot;&gt;&lt;/a&gt;聚集索引和非聚集索引&lt;/h2&gt;&lt;h3 id=&quot;什么是聚集索引&quot;&gt;&lt;a href=&quot;#什么是聚集索引&quot; class</summary>
      
    
    
    
    <category term="数据库" scheme="https://gwtt.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://gwtt.github.io/tags/Mysql/"/>
    
    <category term="索引" scheme="https://gwtt.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>jdk动态代理和cglib动态代理</title>
    <link href="https://gwtt.github.io/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://gwtt.github.io/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2022-08-28T08:32:02.000Z</published>
    <updated>2022-08-28T11:54:16.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两者有何区别"><a href="#两者有何区别" class="headerlink" title="两者有何区别"></a>两者有何区别</h2><p>1、<strong>Jdk动态代理</strong>：利用拦截器（必须实现InvocationHandler接口）加上<strong>反射机制</strong>生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理</p><blockquote><p>JDK动态代理主要是通过，反射包中的Porxy类和InvokationHandler接口。它们结合在一起后可以创建动态代理类。Porxy类基于传递的参数创建动态代理类。InvokationHandler则用于激发动态代理类的方法。这个过程是在程序执行过程中动态生成与处理的，所以叫动态代理。</p></blockquote><p>2、 <strong>Cglib动态代理</strong>：利用ASM框架，对代理对象类生成的class文件加载进来，通过<strong>修改其字节码生成子类来进行代理</strong></p><p><strong>所以：</strong></p><ul><li><strong>如果想要实现JDK动态代理那么代理类必须实现接口，否则不能使用;</strong></li><li><strong>如果想要使用CGlib动态代理，那么代理类不能使用final修饰类和方法；</strong></li></ul><p>还有： 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理。</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="JDk动态代理例子"><a href="#JDk动态代理例子" class="headerlink" title="JDk动态代理例子"></a>JDk动态代理例子</h2><blockquote><p><strong>UserService接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新用户信息&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserProxy代理类，实现InvocationHandler接口重写invoke方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;记录日志&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserProxy</span> <span class="variable">userProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProxy</span>(impl);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(impl.getClass().getClassLoader(),impl.getClass().getInterfaces(),userProxy);</span><br><span class="line">        userService.addUser();</span><br><span class="line">        userService.updateUser(<span class="string">&quot;：我是滚韬&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/28/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccgib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20220828185237100.png" alt="image-20220828185237100"></p></blockquote><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><blockquote><p>首先要加入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(<span class="type">boolean</span> throwException)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello everyone!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(throwException)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;test exception&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现MethodInterceptor接口"><a href="#实现MethodInterceptor接口" class="headerlink" title="实现MethodInterceptor接口"></a>实现MethodInterceptor接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">     <span class="comment">//要代理的原始对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = target;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(<span class="built_in">this</span>.obj.getClass());<span class="comment">// 设置代理目标</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);<span class="comment">// 设置回调</span></span><br><span class="line">        enhancer.setClassLoader(target.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 前置通知</span></span><br><span class="line">            before();</span><br><span class="line">            result = proxy.invokeSuper(obj, args);</span><br><span class="line">            <span class="comment">// 后置通知</span></span><br><span class="line">            after();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            exception();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            beforeReturning();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after method invoke&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exception</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method invoke exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">beforeReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before returning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) cglibProxy.createProxy(hello);</span><br><span class="line">        String result=proxy.sayHello(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="两个动态代理的使用场景是哪里"><a href="#两个动态代理的使用场景是哪里" class="headerlink" title="两个动态代理的使用场景是哪里"></a>两个动态代理的使用场景是哪里</h2><blockquote><p>我们主要是在Spring Aop项目中去使用它们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt;<span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">     Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">     <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">              <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果</span></span><br><span class="line">     <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="number">1</span>、如果目标对象实现了接口，默认情况下会采用JDK的动态代理</span><br><span class="line">&gt;<span class="number">2</span>、如果目标对象实现了接口，也可以强制使用CGLIB</span><br><span class="line">&gt;<span class="number">3</span>、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</span><br></pre></td></tr></table></figure><h4 id="如果需要强制使用CGLIB来实现AOP，需要配置spring-aop-proxy-target-class-true或-EnableAspectJAutoProxy-proxyTargetClass-true"><a href="#如果需要强制使用CGLIB来实现AOP，需要配置spring-aop-proxy-target-class-true或-EnableAspectJAutoProxy-proxyTargetClass-true" class="headerlink" title="如果需要强制使用CGLIB来实现AOP，需要配置spring.aop.proxy-target-class=true或**@EnableAspectJAutoProxy(proxyTargetClass = true**"></a>如果需要强制使用CGLIB来实现AOP，需要配置<strong>spring.aop.proxy-target-class=true</strong>或**@EnableAspectJAutoProxy(proxyTargetClass = true**</h4></blockquote><h2 id="补充-Porxy类"><a href="#补充-Porxy类" class="headerlink" title="(补充)Porxy类"></a>(补充)Porxy类</h2><p>Porxy类提供了一个静态方法创建动态代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,           </span></span><br><span class="line"><span class="params">    Class&lt;?&gt;[] interfaces,                                      </span></span><br><span class="line"><span class="params">    InvocationHandler h)</span></span><br><span class="line"><span class="keyword">throws</span> IllegalArgumentException</span><br></pre></td></tr></table></figure><p>1、ClassLoader：</p><blockquote><p>ClassLoader会定义动态代理类，ClassLoader可以通过类或者接口获得，如果我们想通过接口获得，调用方法如下。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.class.getClassLoader()</span><br></pre></td></tr></table></figure><p>如果通过类来获得，加入我们有一个类TaskImpl实现了Task接口，我们有个TaskImpl的对象ob，然后ClassLoader获取方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob.getClassLoader()</span><br></pre></td></tr></table></figure><p>2、 Class&lt;?&gt;[] interfaces：动态代理类需要实现的接口</p><p>3、InvocationHandler：传递一个实现了InvokationHandler接口的类的实例</p><blockquote><p>InvokationHandler是Java 反射包里面的一个接口。InvokationHandler通过用户类来实现，来激发一个动态代理类的方法。它只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>    <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure><p>1、Object：实现方法的代理对象 </p><p>2、Method：代理实例激发的方法，Porxy参数中的接口方法 </p><p>3、Object[]：传递给方法的一系列参数</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两者有何区别&quot;&gt;&lt;a href=&quot;#两者有何区别&quot; class=&quot;headerlink&quot; title=&quot;两者有何区别&quot;&gt;&lt;/a&gt;两者有何区别&lt;/h2&gt;&lt;p&gt;1、&lt;strong&gt;Jdk动态代理&lt;/strong&gt;：利用拦截器（必须实现InvocationHandler</summary>
      
    
    
    
    <category term="Java" scheme="https://gwtt.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="动态代理" scheme="https://gwtt.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>手写生产者消费者模式</title>
    <link href="https://gwtt.github.io/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwtt.github.io/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-27T11:47:36.000Z</published>
    <updated>2022-08-28T08:27:27.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生产者-消费者模式设计要求"><a href="#生产者-消费者模式设计要求" class="headerlink" title="生产者-消费者模式设计要求"></a>生产者-消费者模式设计要求</h3><p>这种模式满足三点要求：<br>（1）生产者生产数据到缓冲区中，消费者从缓冲区中取数据。<br>（2）缓冲区满时，生产者线程阻塞，进入等待状态。这期间消费者一旦取走数据，队列未满，就会唤醒阻塞的生产者。<br>（3）缓冲区空时，消费者线程阻塞，进入等待状态。这期间生产者一旦往队列中放入数据，就会唤醒阻塞的消费者。</p><blockquote><p>模式组成：<br>公共的缓存队列（给予缓存上限）+ 生产者线程 + 消费者线程。<br>特点：<br>1.实现了生产者、消费者的解耦：通过共享的数据缓冲区域，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。<br>2.实现了线程间的并发协作：如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；如果共享数据区为空的话，阻塞消费者继续消费数据。<br>应用场景：<br>模式解耦、消息队列、分布式场景中很常见。</p></blockquote><p>通常情况下，有5种方式来实现</p><ul><li>synchronized + wait() + notify() 方式</li><li>可重入锁ReentrantLock （配合Condition）</li><li>BlockingQueue 阻塞队列方式</li><li>信号量Semaphore 方式</li><li>管道输入输出流PipedInputStream和PipedOutputStream 方式</li></ul><h3 id="第一种方式（synchronized-）"><a href="#第一种方式（synchronized-）" class="headerlink" title="第一种方式（synchronized ）"></a>第一种方式（synchronized ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.maxSize = size;</span><br><span class="line">queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == maxSize) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列已满，生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;队列未满，生产者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;放入数据&quot;</span> + i);</span><br><span class="line"><span class="keyword">if</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列为空，消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == maxSize) &#123;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;队列有数据，消费者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;取出数据&quot;</span> + queue.remove());<span class="comment">//删除第一个数据，最早放入的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueue myBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(MyBlockingQueue myBlockingQueue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueue = myBlockingQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueue.put();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueue myBlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(MyBlockingQueue myBlockingQueue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueue = myBlockingQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueue.take();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">producer_consumer_1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyBlockingQueue</span> <span class="variable">myBlockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBlockingQueue</span>(<span class="number">8</span>);</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(myBlockingQueue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(myBlockingQueue);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();<span class="comment">//生产者线程1，Thread-0</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer2).start();<span class="comment">//生产者线程2，Thread-1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();<span class="comment">//消费者线程1，Thread-3</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer2).start();<span class="comment">//消费者线程2，Thread-4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgwNzgw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><blockquote><p>补充说明：<br>1.使用Linkedlist+等待唤醒机制（wait、notify/notifyAll）+Synchronized实现线程安全。</p><p>2.为什么使用while不是if？</p><p>判断线程是否进入等待状态时，判断需要while，不能用if。在生产者、消费者线程只有一个时，if可以使用。但是多个线程的情况时就会出现问题。</p><p>例如：假设有两个消费者线程，一个生产者线程。队列为空时，消费者1进入等待状态，释放锁。消费者2抢到锁，进去后判断也进入等待，释放锁。这时生产者抢到锁生产数据，队列中有数据了，反过来唤醒两个消费者。<br>消费者1抢到锁执行wait()的逻辑，取出数据并释放锁。这时消费者2拿到锁，执行wait()后的逻辑取数据，但是此时队列中的数据已经被消费者1取出了，没有数据，这时就会出现线程不安全的情况。<br>利用while实现多次判断，不管消费者1还是2抢到锁，执行循环体的逻辑之前，会再一次判断条件是否成立，而if不会，所以使用while。</p></blockquote><h3 id="第二种方式（ReentrantLock-）"><a href="#第二种方式（ReentrantLock-）" class="headerlink" title="第二种方式（ReentrantLock ）"></a>第二种方式（ReentrantLock ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueueForCondition</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyBlockingQueueForCondition</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.max = max;</span><br><span class="line">queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == max) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列已满，生产者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">notFull.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">notEmpty.signalAll();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;队列未满，生产者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;放入数据&quot;</span> + i);</span><br><span class="line">queue.add(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;队列为空，消费者：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">notEmpty.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(queue.size() == max) &#123;</span><br><span class="line">notFull.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">System.out.println(<span class="string">&quot;队列有数据，消费者：&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;取出数据&quot;</span> + i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerForCondition</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueueForCondition myBlockingQueueForCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerForCondition</span><span class="params">(MyBlockingQueueForCondition myBlockingQueueForCondition)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueueForCondition = myBlockingQueueForCondition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueueForCondition.put(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerForCondition</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> MyBlockingQueueForCondition myBlockingQueueForCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConsumerForCondition</span><span class="params">(MyBlockingQueueForCondition myBlockingQueueForCondition)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.myBlockingQueueForCondition = myBlockingQueueForCondition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myBlockingQueueForCondition.take();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">producer_consumer_2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">MyBlockingQueueForCondition</span> <span class="variable">myBlockingQueueForCondition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBlockingQueueForCondition</span>(<span class="number">8</span>);</span><br><span class="line"><span class="type">ProducerForCondition</span> <span class="variable">producerForCondition1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ProducerForCondition</span> <span class="variable">producerForCondition2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ConsumerForCondition</span> <span class="variable">consumerForCondition1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="type">ConsumerForCondition</span> <span class="variable">consumerForCondition2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerForCondition</span>(myBlockingQueueForCondition);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producerForCondition1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producerForCondition2).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumerForCondition1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumerForCondition2).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgwNzgw,size_16,color_FFFFFF,t_70-16616110494823.png" alt="在这里插入图片描述"></p><h3 id="第三种方式（BlockingQueue-）"><a href="#第三种方式（BlockingQueue-）" class="headerlink" title="第三种方式（BlockingQueue ）"></a>第三种方式（BlockingQueue ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueueTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Producer</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer1).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer1).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;生产数据：&quot;</span> + element);</span><br><span class="line">queue.put(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> BlockingQueue queue;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">element</span> <span class="operator">=</span> (Integer) queue.take();</span><br><span class="line">System.out.println(<span class="string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;消费数据：&quot;</span> + element);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;生产者-消费者模式设计要求&quot;&gt;&lt;a href=&quot;#生产者-消费者模式设计要求&quot; class=&quot;headerlink&quot; title=&quot;生产者-消费者模式设计要求&quot;&gt;&lt;/a&gt;生产者-消费者模式设计要求&lt;/h3&gt;&lt;p&gt;这种模式满足三点要求：&lt;br&gt;（1）生产者生产数据到</summary>
      
    
    
    
    <category term="面试" scheme="https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://gwtt.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
