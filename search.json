[{"title":"Git面试","url":"/2022/07/02/Git%E9%9D%A2%E8%AF%95/","content":"<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><h3 id=\"1-什么是git\"><a href=\"#1-什么是git\" class=\"headerlink\" title=\"1.什么是git?\"></a>1.什么是git?</h3><blockquote>\n<p>git是一个常用的分布式版本管理工具。</p>\n</blockquote>\n<h3 id=\"2-git常用的命令\"><a href=\"#2-git常用的命令\" class=\"headerlink\" title=\"2.git常用的命令\"></a>2.git常用的命令</h3><blockquote>\n<ul>\n<li>git add 添加文件到暂存区</li>\n<li>git commit 提交文件到本地仓库</li>\n<li>git pull 从远程仓库拉取项目到本地</li>\n<li>git push 将本地仓库的新的改变推送到远程仓库</li>\n<li>git clone 将远程仓库复制到本地</li>\n<li>git fetch 抓取</li>\n<li>git merge 合并</li>\n</ul>\n</blockquote>\n<h3 id=\"3-git-pull、git-merge、git-fetch三个命令的区别？\"><a href=\"#3-git-pull、git-merge、git-fetch三个命令的区别？\" class=\"headerlink\" title=\"3.git pull、git merge、git fetch三个命令的区别？\"></a>3.<code>git pull</code>、<code>git merge</code>、<code>git fetch</code>三个命令的区别？</h3><blockquote>\n<p>git clone：是在本地没有版本库的情况下，从远程仓库克隆一份到本地，是一个本地版本库从无到有的过程</p>\n<p>git pull：是在本地仓库已经存在的情况下，将远程最新的commits抓取并合并到本地版本库的过程</p>\n<p>git fetch： 从远程版本库抓取最新的commits，不会进行合并</p>\n<p>git merge：合并</p>\n<p>所以git pull = git fetch + git merge</p>\n</blockquote>\n<h3 id=\"4-push之前一定要进行哪个操作？\"><a href=\"#4-push之前一定要进行哪个操作？\" class=\"headerlink\" title=\"4.push之前一定要进行哪个操作？\"></a>4.push之前一定要进行哪个操作？</h3><blockquote>\n<p>push之前一定要进行本地更新操作。使用<code>git pull</code>命令或者使用<code>git fetch</code>和<code>git merge</code>的命令组合。这时候，可能会出现版本冲突，如果出现的话，需要解决完冲突再进行代码push。</p>\n</blockquote>\n<h3 id=\"5-如何解决版本冲突\"><a href=\"#5-如何解决版本冲突\" class=\"headerlink\" title=\"5.如何解决版本冲突\"></a>5.如何解决版本冲突</h3><blockquote>\n<p>版本冲突多出现在合并操作(合并远程仓库代码或者合并分支代码)中。如果出现版本冲突，需要具体分析出现冲突的代码区，手动进行代码合并，然后再进行提交。</p>\n</blockquote>\n<h3 id=\"6-别人在远程推送的新分支怎么合并在自己上面\"><a href=\"#6-别人在远程推送的新分支怎么合并在自己上面\" class=\"headerlink\" title=\"6.别人在远程推送的新分支怎么合并在自己上面\"></a>6.别人在远程推送的新分支怎么合并在自己上面</h3><blockquote>\n<p>假设别人分支是A，我是B</p>\n<p>git checkout B;//到自己分区</p>\n<p>git merge A;//合并分支</p>\n<p>git push;//提交</p>\n</blockquote>\n","categories":["面试"],"tags":["Git","面试"]},{"title":"HashMap为什么线程不安全","url":"/2022/08/08/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/","content":"<h4 id=\"HashMap原理\"><a href=\"#HashMap原理\" class=\"headerlink\" title=\"HashMap原理\"></a>HashMap原理</h4><p>数据结构上：数组+(链表和红黑树)</p>\n<h4 id=\"HashMap线程不安全问题\"><a href=\"#HashMap线程不安全问题\" class=\"headerlink\" title=\"HashMap线程不安全问题\"></a>HashMap线程不安全问题</h4><blockquote>\n<p>HashMap 是线程不安全的，原因就在于 HashMap 的 <strong>rehash</strong>。<strong>rehash</strong> 是 HashMap 扩容过程种的一个步骤。 HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。 这时候，HashMap 需要扩展它的长度，也就是进行 Resize。 影响发生 Resize 的因素有两个：</p>\n<p>1.<strong>Capacity</strong></p>\n<p>HashMap 的当前长度。上一期曾经说过，HashMap 的长度是 2 的幂。</p>\n<p>2.<strong>LoadFactor</strong></p>\n<p>HashMap 负载因子，默认值为 0.75f。</p>\n<p>衡量 HashMap 是否进行 Resize 的 条件如下：</p>\n<p>HashMap.Size  &gt;= Capacity * LoadFactor</p>\n<p>HashMap 的扩容主要分为两步：</p>\n<ol>\n<li><p>扩容</p>\n<p>创建一个新的 Entry 空数组，长度是原数组的 2 倍</p>\n</li>\n<li><p>ReHash</p>\n<p>遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组。为什么要重新 Hash 呢？因为长度扩大以后，Hash 的规则也随之改变。</p>\n<p>让我们回顾一下 Hash 公式：</p>\n<p>index = HashCode（Key） &amp; （Length - 1）**(计算哈希索引)**</p>\n<p>当原数组长度为 8 时，Hash 运算是和 111B 做与运算；新数组长度为 16，Hash 运算是和 1111B 做与运算。Hash 结果显然不同。</p>\n<p>ReHash 的 Java 代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Transfers all entries from current table to newTable.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">transfer</span><span class=\"params\">(Entry[] newTable, <span class=\"type\">boolean</span> rehash)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> newTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">null</span> != e) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rehash) &#123;</span><br><span class=\"line\">                e.hash = <span class=\"literal\">null</span> == e.key ? <span class=\"number\">0</span> : hash(e.key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, newCapacity);</span><br><span class=\"line\">            e.next = newTable[i];</span><br><span class=\"line\">            newTable[i] = e;</span><br><span class=\"line\">            e = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上过程单线程下不会出现问题，但是当两个线程同时触发resize的时候就有可能出现问题</p>\n<p>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：</p>\n<p><img src=\"https://static.oschina.net/uploads/space/2017/1229/171705_8KHj_1860759.png\" alt=\"img\"></p>\n<p>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：</p>\n<p><img src=\"https://static.oschina.net/uploads/space/2017/1229/171730_nKJe_1860759.png\" alt=\"img\"></p>\n<p>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure>\n\n<p>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：</p>\n<p>e = Entry3</p>\n<p>next = Entry2</p>\n<p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：</p>\n<p><img src=\"https://static.oschina.net/uploads/space/2017/1229/174539_nVJj_1860759.png\" alt=\"img\"></p>\n<p>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。线程B刚才的状态是：</p>\n<p>e = Entry3</p>\n<p>next = Entry2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> indexFor(e.hash, newCapacity);</span><br></pre></td></tr></table></figure>\n\n<p>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">newTable[i] = e;</span><br><span class=\"line\">e = next;</span><br></pre></td></tr></table></figure>\n\n<p>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：</p>\n<p>e = Entry2</p>\n<p>next = Entry2</p>\n<p>整体情况如图所示：</p>\n<p><img src=\"https://static.oschina.net/uploads/space/2017/1229/174637_jMIL_1860759.png\" alt=\"img\"></p>\n<p>接着是新一轮循环，又执行到红框内的代码行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure>\n\n<p>e = Entry2</p>\n<p>next = Entry3</p>\n<p>整体情况如图所示：</p>\n<p><img src=\"https://static.oschina.net/uploads/space/2017/1229/174707_4fJ8_1860759.png\" alt=\"img\"></p>\n<p>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">e.next = newTable[i];</span><br><span class=\"line\">newTable[i] = e;</span><br><span class=\"line\">e = next;</span><br></pre></td></tr></table></figure>\n\n<p>整体情况如图所示：</p>\n<p><img src=\"https://static.oschina.net/uploads/space/2017/1229/174732_ZDEZ_1860759.png\" alt=\"img\"></p>\n<p>第三次循环开始，又执行到红框的代码：</p>\n<p>e = Entry3</p>\n<p>next = Entry3.next = null</p>\n<p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">e.next = newTable[i];</span><br></pre></td></tr></table></figure>\n\n<p>newTable[i] = Entry2</p>\n<p>e = Entry3</p>\n<p>Entry2.next = Entry3</p>\n<p>Entry3.next = Entry2</p>\n<p>链表出现了环形！</p>\n<p>整体情况如图所示：</p>\n<p><img src=\"https://static.oschina.net/uploads/space/2017/1229/174818_kap6_1860759.png\" alt=\"img\"></p>\n<p>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！</p>\n</li>\n</ol>\n</blockquote>\n<p>[ ]转载:<a href=\"https://my.oschina.net/muziH/blog/1596801\">HashMap原理及线程不安全详解 - 木子H的个人空间 - OSCHINA - 中文开源技术交流社区</a></p>\n","categories":["java知识"],"tags":["面试","Java"]},{"title":"Java面试基础（1）","url":"/2022/06/11/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(1)/","content":"<h2 id=\"java基础-1\"><a href=\"#java基础-1\" class=\"headerlink\" title=\"java基础(1)\"></a>java基础(1)</h2><h3 id=\"1-int和interger的区别\"><a href=\"#1-int和interger的区别\" class=\"headerlink\" title=\"1.int和interger的区别\"></a>1.int和interger的区别</h3><blockquote>\n<ul>\n<li><p>Integer是int的包装类；int是基本数据类型；</p>\n</li>\n<li><p>Integer变量必须实例化后才能使用；int变量不需要；</p>\n</li>\n<li><p>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</p>\n</li>\n<li><p>Integer的默认值是null；int的默认值是0。</p>\n<p>延伸：<br>关于Integer和int的比较<br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">System.out.print(i == j); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>2、Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> i <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"type\">Integer</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> j <span class=\"operator\">=</span> <span class=\"number\">100</span>；</span><br><span class=\"line\">System.out.print(i <span class=\"operator\">=</span><span class=\"operator\">=</span> j); <span class=\"operator\">/</span><span class=\"operator\">/</span><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为 ①当变量值在-128到127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②当变量值不在-128到127之间时，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">System.out.print(i == j); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">System.out.print(i == j); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">System.out.print(i == j); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>对于第4条的原因：<br>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> IntegerCache.high &gt;= <span class=\"number\">127</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"2-什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array\"><a href=\"#2-什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array\" class=\"headerlink\" title=\"2.什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array\"></a>2.什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array</h3><blockquote>\n<ul>\n<li><p>当数据量固定时或者多维度时，我们可以使用数组，而当我们可以根据需要自动扩充，修改数据时，应该使用list</p>\n<p>linklist和arraylist的区别</p>\n</li>\n<li><p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 </p>\n</li>\n<li><p>对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。</p>\n<p>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"3-集合有哪些接口，他们有什么区别\"><a href=\"#3-集合有哪些接口，他们有什么区别\" class=\"headerlink\" title=\"3.集合有哪些接口，他们有什么区别\"></a>3.集合有哪些接口，他们有什么区别</h3><blockquote>\n<p> Collection接口：单列集合，两个子接口<br> ①List接口：有序可重复<br> LinkedList：基于链表实现，每个元素储存本身内存地址还储存下一个元素的地址。（增删快，查找慢）</p>\n<p> ArrayList：基于数组实现，每次增删都要重新创建新的数组，但数组有索引。（增删慢，查找快）</p>\n<p> Vector：基于数组，线程安全相关，效率低。</p>\n<p> ②Set接口：不可重复<br> HashSet: 储存的元素无序，不可重复，底层是哈希表</p>\n<p> LinkedHashSet：储存元素有序，不可重复，底层是哈希表和链表的结合</p>\n<p> TreeSet：可以指定一个顺序，对象存入之后会按照指定的顺序排序。</p>\n<p> 2 . Map接口：双列集合<br> HashMap：非线程安全，高效，支持null</p>\n<p> LinkedHashMap：是HashMap的一个子类，保存了记录的插入顺序</p>\n<p> HashTable：线程安全，低效，不支持null</p>\n<p> TreeMap：能够把他保存的记录根据键排序，默认是键值的升序排序</p>\n</blockquote>\n<h3 id=\"4-重载和重写的区别\"><a href=\"#4-重载和重写的区别\" class=\"headerlink\" title=\"4.重载和重写的区别\"></a>4.重载和重写的区别</h3><blockquote>\n<p>方法重载Overload：</p>\n<p>1、同一个类中</p>\n<p>2、方法名相同，参数列表不同（参数顺序、个数、类型）</p>\n<p>3、方法返回值、访问修饰符任意</p>\n<p>4、与方法的参数名无关</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;我是干饭人&quot;</span> );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    public int eat()&#123;  会报错</span></span><br><span class=\"line\"><span class=\"comment\">//        return 4;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"> <span class=\"comment\">//报错原因：参数类型和个数一样,返回值类型不同是不算重载的</span></span><br><span class=\"line\"> <span class=\"comment\">//因为在调用方法的时候,我们还不知道方法的返回值类型,所以编译器无法区分你调用的是哪个方法。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;我是干饭人:&quot;</span>+name );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">(String name,<span class=\"type\">int</span> age)</span>&#123;</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;我是干饭人:&quot;</span>+name+<span class=\"string\">&quot;我今年&quot;</span>+age );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>方法重写Override：</p>\n<p>1、有继承关系的子类中</p>\n<p>2、方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值相同</p>\n<p>3、访问修饰符，访问范围需要大于等于父类的访问范围</p>\n<p>4、与方法的参数名无关</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重载</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Father</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">walk</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">         System.out.println(<span class=\"string\">&quot;我是父亲&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span> &#123;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span><span class=\"comment\">//方法重写</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">walk</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;我是儿子&quot;</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"5-接口和抽象类的区别\"><a href=\"#5-接口和抽象类的区别\" class=\"headerlink\" title=\"5.接口和抽象类的区别\"></a>5.接口和抽象类的区别</h3><blockquote>\n<p>A:成员的区别<br>抽象类：<br>构造方法：有构造方法，用于子类实例化使用。<br>成员变量：可以是变量，也可以是常量。<br>成员方法：可以是抽象的，也可以是非抽象的。</p>\n<p>接口：<br>构造方法：没有构造方法<br>成员变量：只能是常量。默认修饰符：public static final<br>成员方法：jdk1.7只能是抽象的。默认修饰符：public abstract (推荐：默认修饰符请自己永远手动给出)<br>jdk1.8可以写以default和static开头的具体方法</p>\n<p>B:类和接口的关系区别<br>类与类：<br>继承关系,只能单继承。可以多层继承。</p>\n<p>类与接口：<br>实现关系,可以单实现,也可以多实现。<br>类还可以在继承一个类的同时实现多个接口。</p>\n<p>接口与接口：<br>继承关系,可以单继承,也可以多继承。</p>\n<p>C:体现的理念不同<br>抽象类里面定义的都是一个继承体系中的共性内容。<br>接口是功能的集合,是一个体系额外的功能，是暴露出来的规则。</p>\n</blockquote>\n<h3 id=\"6-字符串转为json用什么接口\"><a href=\"#6-字符串转为json用什么接口\" class=\"headerlink\" title=\"6.字符串转为json用什么接口\"></a>6.字符串转为json用什么接口</h3><blockquote>\n<p>JSONObject jsonObject = JSON.parseObject(tt);</p>\n<p>fastjson</p>\n</blockquote>\n<h3 id=\"7-hashmap和hashset的区别及原理\"><a href=\"#7-hashmap和hashset的区别及原理\" class=\"headerlink\" title=\"7.hashmap和hashset的区别及原理\"></a>7.hashmap和hashset的区别及原理</h3><blockquote>\n<p>HashSet是通过HasMap来实现的，HashMap的输入参数有Key、Value两个组成，在实现HashSet的时候，保持HashMap的Value为常量，相当于在HashMap中只对Key对象进行处理。<br>HashMap的底层是一个数组结构，数组中的每一项对应了一个链表，这种结构称“链表散列”的数据结构，即数组和链表的结合体；也叫散列表、哈希表。</p>\n<p>HahMap存储对象的过程如下<br>①、对HahMap的Key调用hashCode()方法，返回int值，即对应的hashCode；</p>\n<p>②、把此hashCode作为哈希表的索引，查找哈希表的相应位置，若当前位置内容为NULL，则把hashMap的Key、Value包装成Entry数组，放入当前位置；</p>\n<p>③、若当前位置内容不为空，则继续查找当前索引处存放的链表，利用equals方法，找到Key相同的Entry数组，则用当前Value去替换旧的Value；</p>\n<p>④、若未找到与当前Key值相同的对象，则把当前位置的链表后移（Entry数组持有一个指向下一个元素的引用），把新的Entry数组放到链表表头；</p>\n<p>HashSet存储对象的过程<br>往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，</p>\n<p>然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。</p>\n<p>情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。</p>\n<p>情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次</p>\n<p>，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。</p>\n<p>注意:现在Hashmap不是数组加链表实现，而是数组，链表，红黑树，链表节点数大于8时会从链表结构变成树结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;ConcurrentHashMap线程安全，锁部分</span><br><span class=\"line\">Hashtable线程安全，锁全部</span><br><span class=\"line\">上者效率更高</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"8-io有哪些类型\"><a href=\"#8-io有哪些类型\" class=\"headerlink\" title=\"8.io有哪些类型\"></a>8.io有哪些类型</h3><blockquote>\n<p>Java IO方式大体上可以分为三类，基于不同的io模型可以简单分为同步阻塞的BIO,同步非阻塞的NIO和异步非阻塞的AIO.</p>\n<p>BIO：Block IO 同步阻塞式 IO，就是咱们日常使用的传统 IO，它的特色是模式简单使用方便，并发处理能力低。</p>\n<p>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端经过 Channel(通道)通信，实现了多路复用。</p>\n<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操做基于事件和回调机制。</p>\n</blockquote>\n<h3 id=\"9-说说对耦合的理解\"><a href=\"#9-说说对耦合的理解\" class=\"headerlink\" title=\"9.说说对耦合的理解\"></a>9.说说对耦合的理解</h3><blockquote>\n<p>耦合就是模块与模块之间的联系程度</p>\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">高内聚，低耦合有什么好处呢？</span><br><span class=\"line\"></span><br><span class=\"line\">事实上，你会发现，短期来看，并没有很明显的好处，甚至会有一些人抱怨，“我这样写不行吗？有舍么问题？” “我写了十几年代码都是这样写的也没见有什么问题。”等等；还有个最重要的，这样甚至在短期内会影响系统的开发进度，因为高内聚，低耦合的系统对开发设计人员提出了更高的要求。高内聚，低耦合的好处体现在系统持续发展的过程中，高内聚，低耦合的系统具有更好的重用性，维护性，扩展性，可以更高效的完成系统的维护开发，持续的支持业务的发展，而不会成为业务发展的障碍。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">高内聚，低耦合是否意味着内聚越高越好，耦合越低越好？</span><br><span class=\"line\">(内聚性，又称块内联系，指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。)</span><br><span class=\"line\">（1）并不是内聚越高越好，耦合越低越好，真正好的设计是在高内聚和低耦合间进行平衡，也就是说高内聚和低耦合是冲突的。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）最强的内聚莫过于一个类只写一个函数，这样内聚性绝对是最高的。但这会带来一个明显的问题：类的数量急剧增多，这样就导致了其它类的耦合特别多，于是整个设计就变成了“高内聚高耦合”了。由于高耦合，整个系统变动同样非常频繁。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）对于耦合来说，最弱的耦合是一个类将所有的函数都包含了，这样类完全不依赖其它类，耦合性是最低的。但这样会带来一个明显的问题：内聚性很低，于是整个设计就变成了“低耦合低内聚”了。由于低内聚，整个类的变动同样非常频繁。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）真正做到高内聚、低耦合是很难的，很多时候未必一定要这样，更多的时候“最适合”的才是最好的，不过、审时度势、融会贯通、人尽其才、物尽其用，才是设计的王道。</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"10-8大基本数据类型\"><a href=\"#10-8大基本数据类型\" class=\"headerlink\" title=\"10.8大基本数据类型\"></a>10.8大基本数据类型</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">byte</span><br><span class=\"line\"></span><br><span class=\"line\">byte属于Java中的整型，长度为1字节8bit，取值10000000（-128）到 01111111（127），变量初始化默认值为0，包装类Byte</span><br><span class=\"line\"></span><br><span class=\"line\">short</span><br><span class=\"line\"></span><br><span class=\"line\">short属于Java中的整型，长度为2字节16bit，取值10000000 00000000（-32768）到 01111111 11111111（32767），变量初始化默认值为0，包装类Short</span><br><span class=\"line\"></span><br><span class=\"line\">int</span><br><span class=\"line\"></span><br><span class=\"line\">int属于Java中的整型，长度为4字节32bit，取值-2^31 （-2,147,483,648）到 2^31-1（2,147,483,647），变量初始化默认值为0，包装类Integer</span><br><span class=\"line\"></span><br><span class=\"line\">long</span><br><span class=\"line\"></span><br><span class=\"line\">long属于Java中的整型，长度为8字节64bit，取值-2^63 （-9,223,372,036,854,775,808‬）到 2^63-1（9,223,372,036,854,775,8087），变量初始化默认值为0或0L，包装类Long</span><br><span class=\"line\"></span><br><span class=\"line\">float</span><br><span class=\"line\"></span><br><span class=\"line\">float属于Java中的浮点型，也叫单精度浮点型，长度为4字节32bit，变量初始化默认值0.0f，包装类Float</span><br><span class=\"line\"></span><br><span class=\"line\">double</span><br><span class=\"line\"></span><br><span class=\"line\">double属于Java中的浮点型，也叫双精度浮点型，长度为8字节64bit，变量初始化默认值0.0d，包装类Double</span><br><span class=\"line\"></span><br><span class=\"line\">char</span><br><span class=\"line\"></span><br><span class=\"line\">char属于java中的字符型，占2字节16bit，可以赋值单字符以及整型数值, 变量初始化无默认值，包装类Character。</span><br><span class=\"line\"></span><br><span class=\"line\">boolean</span><br><span class=\"line\"></span><br><span class=\"line\">在JVM中并没有提供boolean专用的字节码指令，而boolean类型数据在经过编译后在JVM中会通过int类型来表示，此时boolean数据4字节32位，而boolean数组将会被编码成Java虚拟机的byte数组，此时每个boolean数据1字节占8bit.</span><br><span class=\"line\"></span><br><span class=\"line\">--Java虚拟机规范</span><br><span class=\"line\"></span><br><span class=\"line\">仅有两个值true, false，变量初始化默认值false</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"11-和equal的区别\"><a href=\"#11-和equal的区别\" class=\"headerlink\" title=\"11.==和equal的区别\"></a>11.==和equal的区别</h3><blockquote>\n<p>equal与==</p>\n<p>1.最大的区别是，==是运算符，equal是方法</p>\n<p>简述几种情况下的equal与==</p>\n<p>java基本类型<br>比较包装类型<br>比较String类型<br>比较对象<br>1.java基本类型（short，int，long，byte，char，float，double，boolean）</p>\n<p>比较基本类型，只能用==，不能用equal，这里的==比较的是两个变量的值</p>\n<p>2.比较包装类型</p>\n<p>==比较的是内存地址，因为a和b是new出来的，是两个不同的对象，所以地址肯定是不同的，而equal比较的是值.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> Integer) &#123;</span><br><span class=\"line\">      <span class=\"type\">return</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span>= ((Integer)obj).intValue();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.比较String类型</p>\n<p>==比较的是内存地址，equal比较的是值</p>\n<p>4.比较对象</p>\n<p>==和equal比较的都是内存地址，因为equal没有被重写，没有被重写的equal都是object的equal方法</p>\n</blockquote>\n<h3 id=\"12-String-与-StringBuffer-和-StringBuilder-的区别\"><a href=\"#12-String-与-StringBuffer-和-StringBuilder-的区别\" class=\"headerlink\" title=\"12.String 与 StringBuffer 和 StringBuilder 的区别\"></a>12.String 与 StringBuffer 和 StringBuilder 的区别</h3><blockquote>\n<ul>\n<li>String 是不可变的，而 StringBuffer 和 StringBuilder 是可变类。</li>\n<li>StringBuffer 是线程安全和同步的，而 StringBuilder 不是。这就是 StringBuilder 比 StringBuffer 快的原因。</li>\n<li>字符串连接运算符 (+) 在内部使用 StringBuilder 类。</li>\n<li>对于非多线程环境中的字符串操作，我们应该使用 StringBuilder 否则使用 StringBuffer 类。</li>\n</ul>\n</blockquote>\n<h3 id=\"13-CopyOnWriteArrayList的底层原理\"><a href=\"#13-CopyOnWriteArrayList的底层原理\" class=\"headerlink\" title=\"13.CopyOnWriteArrayList的底层原理\"></a>13.CopyOnWriteArrayList的底层原理</h3><blockquote>\n<p><strong>CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</strong></p>\n<p><strong>优点：</strong></p>\n<p>　　读操作性能很高，因为无需任何同步措施，比较适用于<strong>读多写少</strong>的并发场景。Java的list在遍历时，若中途有别的线程对list容器进行修改，则会抛出<strong>ConcurrentModificationException</strong>异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的list容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了</p>\n<p><strong>缺点：</strong></p>\n<p>　　缺点也很明显，<strong>一是内存占用问题</strong>，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；<strong>二是无法保证实时性</strong>，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//ReentrantLock加锁，保证线程安全</span></span><br><span class=\"line\">     <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.lock;</span><br><span class=\"line\">     lock.lock();</span><br><span class=\"line\">     <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">         Object[] elements = getArray();</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> elements.length;</span><br><span class=\"line\">         <span class=\"comment\">//拷贝原容器，长度为原容器长度加一</span></span><br><span class=\"line\">         Object[] newElements = Arrays.copyOf(elements, len + <span class=\"number\">1</span>);</span><br><span class=\"line\">         <span class=\"comment\">//在新副本上执行添加操作</span></span><br><span class=\"line\">         newElements[len] = e;</span><br><span class=\"line\">         <span class=\"comment\">//将原容器引用指向新副本</span></span><br><span class=\"line\">         setArray(newElements);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">//解锁</span></span><br><span class=\"line\">         lock.unlock();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n</blockquote>\n<h3 id=\"14-深拷贝和浅拷贝的区别\"><a href=\"#14-深拷贝和浅拷贝的区别\" class=\"headerlink\" title=\"14.深拷贝和浅拷贝的区别\"></a>14.深拷贝和浅拷贝的区别</h3><p>对于基本数据类型，两者都是值传递</p>\n<p>对于引用数据类型，浅拷贝是地址拷贝，而深拷贝是创建一个新的对象，将值复制进去</p>\n","categories":["面试"],"tags":["面试","java基础"]},{"title":"Juc面试(1)","url":"/2022/06/11/Juc%E9%9D%A2%E8%AF%95(1)/","content":"<h2 id=\"juc-1\"><a href=\"#juc-1\" class=\"headerlink\" title=\"juc(1)\"></a>juc(1)</h2><h3 id=\"1-了解线程吗，他和进程有什么区别\"><a href=\"#1-了解线程吗，他和进程有什么区别\" class=\"headerlink\" title=\"1.了解线程吗，他和进程有什么区别\"></a>1.了解线程吗，他和进程有什么区别</h3><blockquote>\n<p>线程的基本概念<br>　　线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程基本上自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。</p>\n<p>好处 ：</p>\n<p>​        （1）易于调度。</p>\n<p>​        （2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。</p>\n<p>​        （3）开销少。创建线程比创建进程要快，所需开销很少。</p>\n<p>​        （4）利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行</p>\n<p>线程和进程的区别一</p>\n<p>　　简单地讲,任何的一个程序都必须有且有一个以上的进程,而相对于一个进程而言也必须要有且有一个以上的线程。相对于进程而言，对线程进行划分的尺度一般要小很多，这就导致了多线程的一些程序能够出现更高的并发性。</p>\n<p><strong>（线程相比进程划分尺度小，迸发性更高）</strong></p>\n<p>线程和进程的区别二</p>\n<p>　　在执行进程的时候，一般会具有相互独立的多个内存单元。但是多个线程是可以共享内存的，这样运行效率就很大的程度上被提高了。相对于单个的独立进程而言都会有相应程序的运行入口以及一些程序等出口。线程就不一样了，它不能独立的去执行而必须要依附在相应的应用程序里面。这样的话应用程序就可以执行多个线程并进行相应的控制。</p>\n<p><strong>（同一进程的线程共享内存，运行效率高）</strong></p>\n<p>线程和进程的区别三</p>\n<p>　　通过了解逻辑角度我们可以得知，多线程这样的意义是相对于在一个应用程序里面的，能够同时的执行。而操作系统不会认为多个线程就是多个独立应用，因此也就不会使其调度以及管理实现资源的分配。</p>\n<p><strong>(线程没有资源分配</strong>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">了解的，线程时进程中执行运算的最小单位，是被系统独立调度和分派的基本单位。可以创建线程或者撤销另一个线程，可以迸发执行。</span><br><span class=\"line\">区别：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</span><br><span class=\"line\"></span><br><span class=\"line\">（<span class=\"number\">2</span>）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</span><br><span class=\"line\"></span><br><span class=\"line\">（<span class=\"number\">3</span>）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.</span><br><span class=\"line\"></span><br><span class=\"line\">（<span class=\"number\">4</span>）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。  </span><br></pre></td></tr></table></figure>\n\n<p><strong>进程和线程的区别是什么？</strong></p>\n<p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>\n</blockquote>\n<h3 id=\"2-线程和进程的通信方式了解吗\"><a href=\"#2-线程和进程的通信方式了解吗\" class=\"headerlink\" title=\"2.线程和进程的通信方式了解吗\"></a>2.线程和进程的通信方式了解吗</h3><blockquote>\n<p><strong>进程间通信方式</strong><br>进程间通信主要包括<strong>管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket</strong>。</p>\n<p>　　（1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。<br>　　（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。<br>　　（3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身。<br>　　（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。<br>　　（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。<br>　　（6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。<br>　　（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。<br>　　（8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。</p>\n<p><strong>线程间通信的方式</strong></p>\n<p><strong>临界区</strong>：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；<br><strong>互斥量</strong>: Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问<br><strong>信号量</strong>: Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。<br><strong>事件</strong>(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较</p>\n</blockquote>\n<h3 id=\"3-线程的创建方式\"><a href=\"#3-线程的创建方式\" class=\"headerlink\" title=\"3.线程的创建方式\"></a>3.线程的创建方式</h3><blockquote>\n<p>四种方式</p>\n<p>（1）通过继承Thread类来创建新的线程。</p>\n<p>（2）通过实现Runnable接口来创建线程。</p>\n<p><strong>Thread和Runnable区别：</strong></p>\n<ul>\n<li>Thread 是类，需要继承，但是一个类只能继承一个类，一旦继承 Thread 之后，无法在继承其他的类。</li>\n<li>Runnable 是接口，一个类可以实现多个接口，所以实现Runnable接口可拓展性更好</li>\n<li>Thread是Runnable接口的实现类</li>\n</ul>\n<p>（3）通过实现Callable接口来创建线程。</p>\n<p><strong>Runnable和Callable的区别</strong></p>\n<ul>\n<li>Runnable没有返回值。</li>\n<li>Callable可以返回值。</li>\n</ul>\n<p>（4）自定义线程池（推荐）,从中获取线程。</p>\n</blockquote>\n<h3 id=\"4-sleep和wait的区别\"><a href=\"#4-sleep和wait的区别\" class=\"headerlink\" title=\"4.sleep和wait的区别\"></a>4.sleep和wait的区别</h3><blockquote>\n<p>(1)限制</p>\n<p>使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。</p>\n<p>而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。</p>\n<p>(2)使用场景</p>\n<p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>\n<p>(3)类不同</p>\n<p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>\n<p>(4)释放锁</p>\n<p>wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。</p>\n<p>(5)线程切换</p>\n<p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p>\n</blockquote>\n<h3 id=\"5-run和start的区别\"><a href=\"#5-run和start的区别\" class=\"headerlink\" title=\"5.run和start的区别\"></a>5.run和start的区别</h3><blockquote>\n<p>1.线程中的start()方法和run()方法的主要区别在于，当程序调用start()方法，将会创建一个新线程去执行run()方法中的代码。但是如果直接调用run()方法的话，会直接在当前线程中执行run()中的代码，注意，这里不会创建新线程。这样run()就像一个<strong>普通方法</strong>一样。</p>\n<p>2.另外当一个线程启动之后，不能重复调用start()，否则会报IllegalStateException异常。但是可以重复调用run()方法。</p>\n<p>总结起来就是run()就是一个普通的方法，而start()会创建一个新线程去执行run()的代码。</p>\n</blockquote>\n<h3 id=\"6-了解synchronize吗\"><a href=\"#6-了解synchronize吗\" class=\"headerlink\" title=\"6.了解synchronize吗\"></a>6.了解synchronize吗</h3><blockquote>\n<ol>\n<li>修饰实例方法，对于普通同步方法，锁是当前的实例对象</li>\n<li>修饰静态方法，对于静态同步方法，锁是当前的Class对象</li>\n<li>修饰方法代码块，对于同步方法块，锁是synchronized括号里面配置的对象！</li>\n</ol>\n</blockquote>\n<h3 id=\"7-创建线程池的核心参数有哪些？多讲几个\"><a href=\"#7-创建线程池的核心参数有哪些？多讲几个\" class=\"headerlink\" title=\"7.创建线程池的核心参数有哪些？多讲几个?\"></a>7.创建线程池的核心参数有哪些？多讲几个?</h3><blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">int</span> maximumPoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">long</span> keepAliveTime,</span></span><br><span class=\"line\"><span class=\"params\">                        TimeUnit unit,</span></span><br><span class=\"line\"><span class=\"params\">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class=\"line\"><span class=\"params\">                        ThreadFactory threadFactory,</span></span><br><span class=\"line\"><span class=\"params\">                        RejectedExecutionHandler handler)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">      maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">      maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">      keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (workQueue == <span class=\"literal\">null</span> || threadFactory == <span class=\"literal\">null</span> || handler == <span class=\"literal\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.acc = System.getSecurityManager() == <span class=\"literal\">null</span> ?</span><br><span class=\"line\">          <span class=\"literal\">null</span> :</span><br><span class=\"line\">          AccessController.getContext();</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>corePoolSize：线程池的核心线程数。核心线程会一直存活，即便没有任务需要执行，当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理。设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。</p>\n</li>\n<li><p>maximumPoolSize：线程池允许的最大线程数。当线程数&gt;=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务。当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常。</p>\n</li>\n<li><p>keepAliveTime：线程空闲时间。当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize。如果allowCoreThreadTimeout=true，则会直到线程数量=0。</p>\n</li>\n<li><p>unit：keepAliveTime的时间单位。</p>\n</li>\n<li><p>workQueue：当核心线程数达到最大时，新任务会放在队列中排队等待执行。</p>\n</li>\n<li><p>threadFactory：线程工厂，ThreadFactory是一个接口，只有一个方法，即newThread(Runnable r)。从这个方法名字就可以知道，这接口是用来创建新的线程的。其使用也很简单，仅仅只需要实现newThread方法，根据自己的需要进行线程的创建即可。</p>\n</li>\n<li><p>handler：任务拒绝处理器。两种情况会拒绝处理任务：</p>\n<p>1）、当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务；</p>\n<p>2）、当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常。拒绝策略有如下几种：</p>\n<ul>\n<li><p>AbortPolicy 丢弃任务，抛运行时异常。</p>\n</li>\n<li><p>CallerRunsPolicy 如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务</p>\n</li>\n<li><p>DiscardPolicy 丢弃任务，不抛出异常</p>\n</li>\n<li><p>DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务，重新提交被拒绝的任务。</p>\n</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"8-线程同步\"><a href=\"#8-线程同步\" class=\"headerlink\" title=\"8.线程同步\"></a>8.线程同步</h3><blockquote>\n<p>线程同步主要包括四种方式：</p>\n<ul>\n<li>互斥量<code>pthread_mutex_</code></li>\n<li>读写锁<code>pthread_rwlock_</code></li>\n<li>条件变量<code>pthread_cond_</code></li>\n<li>信号量<code>sem_</code></li>\n</ul>\n</blockquote>\n<h3 id=\"9-说说你对volatile关键字的理解\"><a href=\"#9-说说你对volatile关键字的理解\" class=\"headerlink\" title=\"9.说说你对volatile关键字的理解\"></a>9.说说你对volatile关键字的理解</h3><blockquote>\n<p>被volatile修饰的共享变量，就具有了以下两点特性：</p>\n<p>1 . 保证了不同线程对该变量操作的内存可见性;</p>\n<p>2 . 禁止指令重排序</p>\n<h2 id=\"连环问-1-能不能详细说下什么是内存可见性，什么又是重排序呢？\"><a href=\"#连环问-1-能不能详细说下什么是内存可见性，什么又是重排序呢？\" class=\"headerlink\" title=\"连环问(1)能不能详细说下什么是内存可见性，什么又是重排序呢？\"></a>连环问(1)能不能详细说下什么是内存可见性，什么又是重排序呢？</h2><blockquote>\n<p><strong>内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。 也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。</strong></p>\n<p><strong>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</strong></p>\n</blockquote>\n</blockquote>\n<h3 id=\"10-说一下公平锁和非公平锁区别\"><a href=\"#10-说一下公平锁和非公平锁区别\" class=\"headerlink\" title=\"10.说一下公平锁和非公平锁区别\"></a>10.说一下公平锁和非公平锁区别</h3><blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</span><br><span class=\"line\"></span><br><span class=\"line\">优点：所有的线程都能得到资源，不会饿死在队列中。</span><br><span class=\"line\">缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</span><br><span class=\"line\"></span><br><span class=\"line\">优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</span><br><span class=\"line\">缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"11-ReentrantLock的trylock和lock区别\"><a href=\"#11-ReentrantLock的trylock和lock区别\" class=\"headerlink\" title=\"11.ReentrantLock的trylock和lock区别\"></a>11.ReentrantLock的trylock和lock区别</h3><blockquote>\n<p>1: lock拿不到锁会一直等待，并且没有返回值。tryLock是去尝试，<strong>拿不到就返回false，拿到返回true。</strong></p>\n<p>2: tryLock是可以被打断的，被中断的，lock是不可以。</p>\n</blockquote>\n<h3 id=\"12-CountDownLatch和Semaphore的区别和底层原理\"><a href=\"#12-CountDownLatch和Semaphore的区别和底层原理\" class=\"headerlink\" title=\"12.CountDownLatch和Semaphore的区别和底层原理\"></a>12.CountDownLatch和Semaphore的区别和底层原理</h3><blockquote>\n<p>CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用CountDownLatch的await()将会阻塞，其他线程可以调用CountDownLatch的countDown()方法来对CountDownLatch中的数字减一，当数字被减成o后，所有await的线程都将被唤醒.</p>\n<p>对应的底层原理就是，调用await()方法的线程会利用AQS排队，一旦数字被减为O，则会将AQS中排队的线程依次唤醒。</p>\n<p>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过acquire()来获取许可，如果没有许可可用则线程阻塞，并通过AQS来排队，可以通过release()方法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第一个线程开始依次唤醒，直到没有空闲许可。</p>\n</blockquote>\n<h3 id=\"13-Sychronized的偏向锁、轻量级锁、重量级锁\"><a href=\"#13-Sychronized的偏向锁、轻量级锁、重量级锁\" class=\"headerlink\" title=\"13.Sychronized的偏向锁、轻量级锁、重量级锁\"></a>13.Sychronized的偏向锁、轻量级锁、重量级锁</h3><blockquote>\n<p>1.<strong>偏向锁</strong>:在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了</p>\n<p>⒉<strong>轻量级锁</strong>:由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁,之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程</p>\n<p>3.如果自旋次数过多仍然没有获取到锁，则会升级为<strong>重量级锁</strong>，重量级锁会导致线程阻塞</p>\n<p>4.<strong>自旋锁</strong>:自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程。阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。</p>\n</blockquote>\n<h3 id=\"14-Sychronized和ReentrantLock的区别\"><a href=\"#14-Sychronized和ReentrantLock的区别\" class=\"headerlink\" title=\"14.Sychronized和ReentrantLock的区别\"></a>14.Sychronized和ReentrantLock的区别</h3><blockquote>\n<ol>\n<li>sychronized是一个关键字，ReentrantLock是一个类</li>\n<li>sychronized会自动的加锁与释放锁,ReentrantLock需要程序员手动加锁与释放锁</li>\n<li>sychronized的底层是JVM层面的锁，ReentrantLock是APl层面的锁</li>\n<li>sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁</li>\n<li>sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识来标识锁的状态</li>\n<li>sychronized底层有一个锁升级的过程</li>\n</ol>\n</blockquote>\n<h3 id=\"15-线程池的底层工作原理\"><a href=\"#15-线程池的底层工作原理\" class=\"headerlink\" title=\"15.线程池的底层工作原理\"></a>15.线程池的底层工作原理</h3><blockquote>\n<p>线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时:</p>\n<p>1.如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</p>\n<p>⒉.如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</p>\n<p>3.如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</p>\n<p>4.如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。</p>\n<p>5.当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数</p>\n</blockquote>\n<h3 id=\"16-BIO-NIO-AIO分别是什么\"><a href=\"#16-BIO-NIO-AIO分别是什么\" class=\"headerlink\" title=\"16.BIO,NIO,AIO分别是什么\"></a>16.BIO,NIO,AIO分别是什么</h3><blockquote>\n<p>1.BIO:同步阻塞lO，使用BIO读取数据时，线程会阻塞住，并且需要线程主动去查询是否有数据可读，并且需要处理完一个Socket之后才能处理下一个Socket</p>\n<p>2.NIO:同步非阻塞lO，使用NIO读取数据时，线程不会阻塞，但需要线程主动的去查询是否有IO事件</p>\n<p>3.AlO:也叫做NIO 2.0，异步非阻塞lO，使用AIO读取数据时，线程不会阻塞，并且当有数据可读时会通知给线程，不需要线程主动去查询</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","juc"]},{"title":"Java面试基础（2）","url":"/2022/07/02/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(2)/","content":"<h2 id=\"java基础-2\"><a href=\"#java基础-2\" class=\"headerlink\" title=\"java基础(2)\"></a>java基础(2)</h2><h3 id=\"1-java你用过的jdk版本\"><a href=\"#1-java你用过的jdk版本\" class=\"headerlink\" title=\"1..java你用过的jdk版本\"></a>1..java你用过的jdk版本</h3><blockquote>\n<p>jdk1.8或者jdk11</p>\n<p>关键问:</p>\n<h3 id=\"你知道jdk1-8相较于1-7有什么新特性吗\"><a href=\"#你知道jdk1-8相较于1-7有什么新特性吗\" class=\"headerlink\" title=\"你知道jdk1.8相较于1.7有什么新特性吗\"></a>你知道jdk1.8相较于1.7有什么新特性吗</h3><ul>\n<li>新增<strong>Lambda表达式</strong> ：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>\n<li>新增<strong>Stream API</strong>:对容器功能加强，可以对容器进行高效操作</li>\n<li>新增<strong>方法引用</strong>:通过方法的名字来指向一个方法，用::</li>\n<li>新增<strong>Optional类</strong>:解决空指针异常</li>\n<li>新增default:接口可以有具体方法</li>\n<li>新增<strong>日期API</strong></li>\n</ul>\n<p>(接下来可能会问Lambda表达式和StreamAPI)</p>\n<h3 id=\"你知道jdk11有什么新特性吗\"><a href=\"#你知道jdk11有什么新特性吗\" class=\"headerlink\" title=\"你知道jdk11有什么新特性吗\"></a>你知道jdk11有什么新特性吗</h3><ul>\n<li>新增本地类型推断:用var直接定义变量，编译器能自动推断类型</li>\n<li>Optianal类增强，可以转换成流使用</li>\n<li>字符类增加一些功能API</li>\n</ul>\n</blockquote>\n<h3 id=\"2-用过final关键字吗？它有什么作用\"><a href=\"#2-用过final关键字吗？它有什么作用\" class=\"headerlink\" title=\"2.用过final关键字吗？它有什么作用\"></a>2.用过final关键字吗？它有什么作用</h3><blockquote>\n<p> final关键字表示不可变，它可以修饰在类、方法、成员变量中。</p>\n<ol>\n<li>如果修饰在类上，则表示该类不允许被继承</li>\n<li>修饰在方法上，表示该方法无法被重写</li>\n<li>修饰在变量上，表示该变量无法被修改，而且JVM会隐性定义为一个常量。(但是可以通过反射去破坏，但是<strong>反射无法修改被final和static同时修饰的变量</strong>)</li>\n</ol>\n<p> 另外，<code>final</code>修饰的关键字，还可以避免因为指令重排序带来的可见性问题，原因是，final遵循两个重排序规则</p>\n<ol>\n<li>构造函数内，对一个 final 变量的写入，与随后把这个被构造对象的引用赋值给一个变量，这两个操作之间不可重排序。</li>\n<li>首次读一个包含 final 变量的对象，与随后首次读这个 final 变量，这两个操作之间不可以重排序。</li>\n</ol>\n</blockquote>\n<h3 id=\"3-反射知道吗-通过反射可以获取到一些什么东西\"><a href=\"#3-反射知道吗-通过反射可以获取到一些什么东西\" class=\"headerlink\" title=\"3.反射知道吗 通过反射可以获取到一些什么东西\"></a>3.反射知道吗 通过反射可以获取到一些什么东西</h3><blockquote>\n<p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n<p><strong>① 通过反射获取类中的属性和属性值</strong></p>\n<p><strong>② 通过反射获取反射类中的构造方法</strong></p>\n<p><strong>③ 通过反射获取反射类的父类（超类）和接口</strong></p>\n<p><strong>④通过反射获取反射类的方法</strong></p>\n</blockquote>\n<h3 id=\"4-序列化ID有什么作用？怎么生成的？\"><a href=\"#4-序列化ID有什么作用？怎么生成的？\" class=\"headerlink\" title=\"4.序列化ID有什么作用？怎么生成的？\"></a>4.序列化ID有什么作用？怎么生成的？</h3><blockquote>\n<p>作用:验证版本一致性</p>\n<p>反序列化时，程序会比较磁盘中的序列化版本号ID是否与当前类结构生成的版本号ID一致，如果一致，则反序列化成功</p>\n<p>下图就是反序列化异常情况</p>\n<p><img src=\"/2022/07/02/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(2)/image-20220709221426112.png\" alt=\"image-20220709221426112\"></p>\n<p>生成方式：</p>\n<p>首先，相关的类要实现Serializable接口</p>\n<ul>\n<li><p>手动生成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">好处就是即使在原来类上加字段，也不会发生上图的反序列化失败，老版本兼容</span><br></pre></td></tr></table></figure></li>\n<li><p>代码调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ObjectStreamClass c = ObjectStreamClass.lookup(Student.class);</span><br><span class=\"line\">long serialVersionUID = c.getSerialVersionUID();</span><br></pre></td></tr></table></figure></li>\n<li><p>ide快捷工具</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"5-为什么重写-equals-的同时必须重写-hashCode\"><a href=\"#5-为什么重写-equals-的同时必须重写-hashCode\" class=\"headerlink\" title=\"5.为什么重写 equals 的同时必须重写 hashCode\"></a>5.为什么重写 equals 的同时必须重写 hashCode</h3><blockquote>\n<p>程序先进行 hashcode 的比较，如果不同，那没就不必在进行 equals 的比较了，这样就大大减少了 equals 比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用</p>\n<p>hashCode 和 equals 两个方法是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，如果在重写 equals 时，不重写 hashCode，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。</p>\n<p>回答:因为程序会先进行hashcode，我们希望Set集合能过滤相同数值的对象，因为涉及对象的值比较，我们重写equals，但我们要保证两个对象 equals 相等，那么hashcode也要相同，所以要重写hashcode，否则还是不能去重。（hashcode不是内存地址，跟内存地址相关）</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","java基础"]},{"title":"Juc面试(2)","url":"/2022/07/02/Juc%E9%9D%A2%E8%AF%95(2)/","content":"<h2 id=\"juc-2\"><a href=\"#juc-2\" class=\"headerlink\" title=\"juc(2)\"></a>juc(2)</h2><h3 id=\"1-线程的生命周期\"><a href=\"#1-线程的生命周期\" class=\"headerlink\" title=\"1.线程的生命周期\"></a>1.线程的生命周期</h3><blockquote>\n<p>线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。</p>\n<ul>\n<li>新建：就是刚使用new方法，new出来的线程；</li>\n<li>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li>\n<li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</li>\n<li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li>\n<li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;</li>\n</ul>\n<p><img src=\"/2022/07/02/Juc%E9%9D%A2%E8%AF%95(2)/1223046-20190722214114154-276488899.png\" alt=\"img\"></p>\n<hr>\n<p>那么处于Running状态的线程能发生哪些状态转变？</p>\n<ul>\n<li><p>被转换成Terminated状态，比如调用 stop() 方法;</p>\n</li>\n<li><p>被转换成Blocked状态，比如调用了sleep, wait 方法被加入 waitSet 中；</p>\n</li>\n<li><p>被转换成Blocked状态，如进行 IO 阻塞操作，如查询数据库进入阻塞状态；</p>\n</li>\n<li><p>被转换成Blocked状态，比如获取某个锁的释放，而被加入该锁的阻塞队列中；</p>\n</li>\n<li><p>该线程的时间片用完，CPU 再次调度，进入Runnable状态；</p>\n</li>\n<li><p>线程主动调用 yield 方法，让出 CPU 资源，进入Runnable状态</p>\n</li>\n</ul>\n<p>Blocked状态的线程能够发生哪些状态改变？</p>\n<ul>\n<li><p>被转换成Terminated状态，比如调用 stop() 方法，或者是 JVM 意外 Crash;</p>\n</li>\n<li><p>被转换成Runnable状态，阻塞时间结束，比如读取到了数据库的数据后；</p>\n</li>\n<li><p>完成了指定时间的休眠，进入到Runnable状态；</p>\n</li>\n<li><p>正在wait中的线程，被其他线程调用notify/notifyAll方法唤醒，进入到Runnable状态；</p>\n</li>\n<li><p>线程获取到了想要的锁资源，进入Runnable状态；</p>\n</li>\n<li><p>线程在阻塞状态下被打断，如其他线程调用了interrupt方法，进入到Runnable状态；</p>\n</li>\n</ul>\n<p>哪些情况进入终止状态</p>\n<ul>\n<li><p>线程正常运行结束，生命周期结束；</p>\n</li>\n<li><p>线程运行过程中出现意外错误；</p>\n</li>\n<li><p>JVM 异常结束，所有的线程生命周期均被结束。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"2-死锁问题\"><a href=\"#2-死锁问题\" class=\"headerlink\" title=\"2.死锁问题\"></a>2.死锁问题</h3><blockquote>\n<h4 id=\"什么是死锁\"><a href=\"#什么是死锁\" class=\"headerlink\" title=\"什么是死锁\"></a>什么是死锁</h4><p>死锁就是有两个或者多个进程由于竞争资源而造成阻塞的现象，如果无外力作用，这种局面就会一直持续下去</p>\n<h4 id=\"死锁产生的条件\"><a href=\"#死锁产生的条件\" class=\"headerlink\" title=\"死锁产生的条件\"></a>死锁产生的条件</h4><p>死锁产生必须满足四个必要条件：</p>\n<p>1、互斥条件：指在一段时间内某资源只能由一个进程占用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">只有一副钥匙</span><br></pre></td></tr></table></figure>\n\n<p>2、请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，且对自己已获得的其它资源保持不放。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">拿着红钥匙的人在没有归还红钥匙的情况下，又索要蓝钥匙</span><br></pre></td></tr></table></figure>\n\n<p>3、不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">只要人不主动归还钥匙，就可以一直占着钥匙</span><br></pre></td></tr></table></figure>\n\n<p>4、环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链。即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">拿着红钥匙的人在等待蓝钥匙，而拿着蓝钥匙的人又在等待红钥匙</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"如何避免死锁\"><a href=\"#如何避免死锁\" class=\"headerlink\" title=\"如何避免死锁\"></a>如何避免死锁</h4><ul>\n<li><strong>资源一次性分配</strong>：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li>\n<li>每个进程提出申请资源前必须释放已占有的一切资源（破坏保持条件）</li>\n<li><strong>可剥夺资源</strong>：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>\n<li><strong>资源有序分配法</strong>：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>\n</ul>\n<p><strong>编程中的最佳实践：</strong></p>\n<ul>\n<li>使用 Lock 的 tryLock(long timeout, TimeUnit unit)的方法，设置超时时间，超时可以退出防止死锁</li>\n<li>尽量使用并发工具类代替加锁</li>\n<li>尽量降低锁的使用粒度</li>\n<li>尽量减少同步的代码块</li>\n</ul>\n<h4 id=\"死锁检测工具（了解）\"><a href=\"#死锁检测工具（了解）\" class=\"headerlink\" title=\"死锁检测工具（了解）\"></a>死锁检测工具（了解）</h4><p>1、<strong>Jstack命令</strong></p>\n<p>jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。</p>\n<p>2、<strong>JConsole工具</strong></p>\n<p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。</p>\n</blockquote>\n<h3 id=\"3-单例模式\"><a href=\"#3-单例模式\" class=\"headerlink\" title=\"3.单例模式\"></a>3.单例模式</h3><blockquote>\n<h4 id=\"单例模式含义\"><a href=\"#单例模式含义\" class=\"headerlink\" title=\"单例模式含义\"></a>单例模式含义</h4><p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p>\n<p>单例模式主要解决的问题是一个全局使用的类，不会被频繁的创建和销毁，从而提升代码的整体性能。</p>\n<h4 id=\"如何创建单例模式\"><a href=\"#如何创建单例模式\" class=\"headerlink\" title=\"如何创建单例模式\"></a>如何创建单例模式</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">饿汉式</span><br><span class=\"line\">优点：简单，线程安全</span><br><span class=\"line\">缺点：不管有没有使用都会占据空间</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HungrySingleton</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">HungrySingleton</span> <span class=\"variable\">SINGLETON</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HungrySingleton</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 单例模式有一个特点，不允许外部直接创建对象，私有构造不让外部实例化</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">HungrySingleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HungrySingleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SINGLETON;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">懒汉式</span><br><span class=\"line\">优点: 简单</span><br><span class=\"line\">缺点: 线程不安全，要加锁才能解决</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LazySingleton</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LazySingleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(singleton == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">加锁后的</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (LazySingleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singleton == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                singleton = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>()</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">枚举（推荐）</span><br><span class=\"line\">优点：线程安全，防止反射和反序列化</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span>  <span class=\"title class_\">EnumSingleton</span> &#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> EnumSingleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的\"><a href=\"#在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的\" class=\"headerlink\" title=\"在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的\"></a>在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的</h4><p>结论:有写操作的话都是线程不安全的</p>\n<p><strong>静态变量即类变量</strong>，只初始化一次，位于方法区，为所有对象共享，共享一份内存，一旦静态变量被修改，其他对象均对修改可见，故线程非安全。</p>\n<p><strong>全局变量即实例成员变量</strong>。如果线程只是读取变量的值，而不会改变变量的值，则无论是单例还是非单例都是线程安全的；如果有修改变量值的操作，则单例模式因为只有一个对象实例singleton存在，多线程同时操作时是不安全的，而非单例模式下多线程操作是安全的。</p>\n</blockquote>\n<h3 id=\"4-怎么解决高并发问题\"><a href=\"#4-怎么解决高并发问题\" class=\"headerlink\" title=\"4.怎么解决高并发问题\"></a>4.怎么解决高并发问题</h3><blockquote>\n<p>1.优化代码</p>\n<p>2.设置单独的图片服务器，减少访问请求服务器压力</p>\n<p>3.使用缓存</p>\n<p>4.使用数据库集群</p>\n<p>5.DB优化（索引优化，字段类型恰当）</p>\n<p>6.实现负载均衡</p>\n<p>7.限流</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","juc"]},{"title":"Mybatis面试(1)","url":"/2022/06/12/Mybatis%E9%9D%A2%E8%AF%95(1)/","content":"<h2 id=\"Mybatis-1\"><a href=\"#Mybatis-1\" class=\"headerlink\" title=\"Mybatis(1)\"></a>Mybatis(1)</h2><h3 id=\"1-Mybatis的优缺点\"><a href=\"#1-Mybatis的优缺点\" class=\"headerlink\" title=\"1.Mybatis的优缺点\"></a>1.Mybatis的优缺点</h3><blockquote>\n<p>Mybaits 的优点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</span><br><span class=\"line\"></span><br><span class=\"line\">2.与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；</span><br><span class=\"line\"></span><br><span class=\"line\">3.很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。</span><br><span class=\"line\"></span><br><span class=\"line\">4.能够与 Spring 很好的集成；</span><br><span class=\"line\"></span><br><span class=\"line\">5.提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。</span><br></pre></td></tr></table></figure>\n\n<p>MyBatis 框架的缺点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。</span><br><span class=\"line\"></span><br><span class=\"line\">2.SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"2-Mybatis中的-和-区别是什么\"><a href=\"#2-Mybatis中的-和-区别是什么\" class=\"headerlink\" title=\"2.Mybatis中的#{}和${}区别是什么\"></a>2.Mybatis中的#{}和${}区别是什么</h3><blockquote>\n<p>1.#{}是预编译处理、是占位符，${}是字符串替换、是拼接符</p>\n<p>2.Mybatis在处理#{}时，会将sql中的#替换为?号，调用PreparedStatement来赋值</p>\n<p>3.Mybatis在处理${}时，就是把$替换成变量的值，调用Statement来赋值</p>\n<p>4.使用#{}可以很大程度上防止SQL注入，提高系统安全性</p>\n<p>5.#号防止sql注入的原理就是对参数及参数中的特殊字符进行了转义，从而达到防止sql注入的效果。</p>\n</blockquote>\n<h3 id=\"3-ORM框架是什么\"><a href=\"#3-ORM框架是什么\" class=\"headerlink\" title=\"3.ORM框架是什么\"></a>3.ORM框架是什么</h3><blockquote>\n<p>对象关系映射（Object—Relational Mapping，简称ORM）</p>\n<p>是一种为了解决面向对象与面向关系数据库存在的互不匹配的现象的技术；简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将java 程序中的对象自动持久化到关系数据库中；本质上就是将数据从一种形式转换到另外一种形式。</p>\n<p>常见的比如Hibernate, Mybatis,TopLink等框架</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","Mybatis"]},{"title":"MySQL面试(1)","url":"/2022/06/12/Mysql%E9%9D%A2%E8%AF%95(1)/","content":"<h2 id=\"MySQL-1\"><a href=\"#MySQL-1\" class=\"headerlink\" title=\"MySQL(1)\"></a>MySQL(1)</h2><hr>\n<h3 id=\"1-跟-的区别\"><a href=\"#1-跟-的区别\" class=\"headerlink\" title=\"1.$跟#的区别\"></a>1.$跟#的区别</h3><blockquote>\n<p>#相当于对数据 加上 双引号，$相当于直接显示数据。</p>\n</blockquote>\n<h3 id=\"2-MySQL的事务隔离级别有哪些？默认隔离级别是？\"><a href=\"#2-MySQL的事务隔离级别有哪些？默认隔离级别是？\" class=\"headerlink\" title=\"2.MySQL的事务隔离级别有哪些？默认隔离级别是？\"></a>2.MySQL的事务隔离级别有哪些？默认隔离级别是？</h3><blockquote>\n<p>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>\n<p>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p>\n<p>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。(默认)</p>\n<p>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">脏读：一个事务读取另外一个事务还没有提交的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">不可重复读：事务 T1 读到某行；事务 T2 修改或删除这行，提交事务；T1 重新读取发现这行数据已经被修改或删除。</span><br><span class=\"line\"></span><br><span class=\"line\">幻读：事务 T1 读取了 N 行；事务 T2 在事务 T1 读取的条件范围内生成了一行或多行数据；T1 重新读取获得与之前不同集合的行数据。</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"3-explain语句结果各个字段分别表示什么\"><a href=\"#3-explain语句结果各个字段分别表示什么\" class=\"headerlink\" title=\"3.explain语句结果各个字段分别表示什么\"></a>3.explain语句结果各个字段分别表示什么</h3><blockquote>\n<table>\n<thead>\n<tr>\n<th>Column</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>查询序号</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区</td>\n</tr>\n<tr>\n<td>type</td>\n<td>join类型</td>\n</tr>\n<tr>\n<td>prossible_keys</td>\n<td>可能会选择的索引</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际选择的索引</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>索引的长度</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>与索引作比较的列</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>要检索的行数(估算值)</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>查询条件过滤的行数的百分比</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>额外信息</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>id: SQL查询中的序列号。</p>\n</li>\n<li><p>select_type: 查询的类型，可以是下表的任何一种类型：</p>\n<table>\n<thead>\n<tr>\n<th>select_type</th>\n<th>类型说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIMPLE</td>\n<td>简单SELECT(不使用UNION或子查询)</td>\n</tr>\n<tr>\n<td>PRIMARY</td>\n<td>最外层的SELECT</td>\n</tr>\n<tr>\n<td>UNION</td>\n<td>UNION中第二个或之后的SELECT语句</td>\n</tr>\n<tr>\n<td>DEPENDENT UNION</td>\n<td>UNION中第二个或之后的SELECT语句取决于外面的查询</td>\n</tr>\n<tr>\n<td>UNION RESULT</td>\n<td>UNION的结果</td>\n</tr>\n<tr>\n<td>SUBQUERY</td>\n<td>子查询中的第一个SELECT</td>\n</tr>\n<tr>\n<td>DEPENDENT SUBQUERY</td>\n<td>子查询中的第一个SELECT, 取决于外面的查询</td>\n</tr>\n<tr>\n<td>DERIVED</td>\n<td>衍生表(FROM子句中的子查询)</td>\n</tr>\n<tr>\n<td>MATERIALIZED</td>\n<td>物化子查询</td>\n</tr>\n<tr>\n<td>UNCACHEABLE SUBQUERY</td>\n<td>结果集无法缓存的子查询，必须重新评估外部查询的每一行</td>\n</tr>\n<tr>\n<td>UNCACHEABLE UNION</td>\n<td>UNION中第二个或之后的SELECT，属于无法缓存的子查询</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>table</code> 表名或者表的别名。</p>\n</li>\n<li><p><code>partitions</code> 分区信息，非分区表为null。</p>\n</li>\n<li><p><code>type</code> 访问类型，表示找到所查询数据的方法，也是本文重点介绍的属性。该属性的常见值如下，性能从好到差：</p>\n<ul>\n<li><em>NULL</em>：无需访问表或者索引，比如获取一个索引列的最大值或最小值。</li>\n<li><em>system/const</em>：当查询最多匹配一行时，常出现于where条件是＝的情况。system是const的一种特殊情况，既表本身只有一行数据的情况。</li>\n<li><em>eq_ref</em>：多表关联查询时，根据唯一非空索引进行查询的情况。</li>\n<li><em>ref</em>：多表查询时，根据非唯一非空索引进行查询的情况。</li>\n<li><em>range</em>：在一个索引上进行范围查找。</li>\n<li><em>index</em>：遍历索引树查询，通常发生在查询结果只包含索引字段时。</li>\n<li><em>ALL</em>：全表扫描，没有任何索引可以使用时。这是最差的情况，应该避免。</li>\n</ul>\n</li>\n<li><p><code>possible_keys</code> 表示mysql此次查询中可能使用的索引。</p>\n</li>\n<li><p><code>key</code> 表示mysql实际在此次查询中使用的索引。</p>\n</li>\n<li><p><code>key_len</code> 表示mysql使用的索引的长度。该值越小越好。</p>\n</li>\n<li><p><code>ref</code>如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p>\n</li>\n<li><p><code>rows </code>也是一个重要的字段。 这是mysql估算的需要扫描的行数（不是精确值）。这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>extra（重要）</p>\n<p>explain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n<ul>\n<li><strong>distinct</strong>：在select部分使用了distinc关键字</li>\n<li><strong>Using filesort</strong>：当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li>\n<li><strong>Using index</strong><br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明<strong>性能不错</strong></li>\n<li><strong>Using temporary</strong><br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"4-什么是覆盖索引？\"><a href=\"#4-什么是覆盖索引？\" class=\"headerlink\" title=\"4.什么是覆盖索引？\"></a>4.什么是覆盖索引？</h3><blockquote>\n<p>覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</p>\n</blockquote>\n<h3 id=\"5-最左前缀原则是什么\"><a href=\"#5-最左前缀原则是什么\" class=\"headerlink\" title=\"5.最左前缀原则是什么\"></a>5.最左前缀原则是什么</h3><blockquote>\n<p>当一个SQL想要利用索引是，就一定要提供该索引所对应的字段中最左边的字段，也就是排在最前面的字段，比如针对a,b,c三个字段建立了一个联合索引，那么在写一个sql时就一定要提供a字段的条件，这样才能用到联合索引，这是由于在建立a,b,c三个字段的联合索引时，底层的B+树是按照a,b.c三个字段从左往右去比较大小进行排序的，所以如果想要利用B+树进行快速查找也得符合这个规则</p>\n</blockquote>\n<h3 id=\"6-lnnodb是如何实现事务的\"><a href=\"#6-lnnodb是如何实现事务的\" class=\"headerlink\" title=\"6.lnnodb是如何实现事务的\"></a>6.lnnodb是如何实现事务的</h3><blockquote>\n<p>Innodb通过Buffer Pool，LogBuffer，Redo Log, Undo Log来实现事务，以一个update语句为例:</p>\n<ul>\n<li>Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中</li>\n<li>执行update语句，修改Buffer Pool中的数据，也就是内存中的数据</li>\n<li>针对update语句生成一个RedoLog对象，并存入LogBuffer中</li>\n<li>针对update语句生成undolog日志，用于事务回滚</li>\n<li>如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中6．如果事务回滚，则利用undolog日志进行回滚</li>\n</ul>\n</blockquote>\n<h3 id=\"7-B树和B-树的区别，为什么Mysql使用B-树\"><a href=\"#7-B树和B-树的区别，为什么Mysql使用B-树\" class=\"headerlink\" title=\"7.B树和B+树的区别，为什么Mysql使用B+树\"></a>7.B树和B+树的区别，为什么Mysql使用B+树</h3><blockquote>\n<p>B树的特点:</p>\n<p>1．节点排序<br>2.一个节点了可以存多个元素，多个元素也排序了</p>\n<p>B+树的特点:</p>\n<p>1．拥有B树的特点<br>2．叶子节点之间有指针<br>3．非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序</p>\n<p>Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。</p>\n<p>为什么索引采用B+树</p>\n<p>1.索引用来加快查询速度，B+树对数据排序可以加快查询速度</p>\n<p>2.一个节点存储多个元素，B+树不会很高，一个innodb页是一个节点，两层B+树可以存储200万条数据</p>\n<p>3.B+树叶子节点有指针，可以支持全表扫描，范围查找等SQL语句</p>\n<p><img src=\"/2022/06/12/Mysql%E9%9D%A2%E8%AF%95(1)/webp-16550466299441.webp\" alt=\"img\"></p>\n<p><img src=\"/2022/06/12/Mysql%E9%9D%A2%E8%AF%95(1)/webp-16544345372523-16550466299442.webp\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"8-Mysql锁有哪些，如何理解\"><a href=\"#8-Mysql锁有哪些，如何理解\" class=\"headerlink\" title=\"8.Mysql锁有哪些，如何理解\"></a>8.Mysql锁有哪些，如何理解</h3><blockquote>\n<p>按锁粒度分类:</p>\n<ul>\n<li>行锁:锁某行数据，锁粒度最小，并发度高</li>\n<li>表锁:锁整张表，锁粒度最大，并发度低</li>\n<li>间隙锁:锁的是一个区间</li>\n</ul>\n<p>还可以分为:</p>\n<ul>\n<li>共享锁:也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写-</li>\n<li>排它锁:也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写</li>\n</ul>\n<p>还可以分为:</p>\n<ul>\n<li>乐观锁:并不会真正的去锁某行记录，而是通过一个版本号来实现的</li>\n<li>悲观锁:上面所的行锁、表锁等都是悲观锁</li>\n</ul>\n<p>在事务的隔离级别实现中，就需要利用锁来解决幻读</p>\n</blockquote>\n<h3 id=\"9-Mysql慢查询该如何优化\"><a href=\"#9-Mysql慢查询该如何优化\" class=\"headerlink\" title=\"9.Mysql慢查询该如何优化?\"></a>9.Mysql慢查询该如何优化?</h3><blockquote>\n<ul>\n<li>检查是否走了索引，如果没有则优化SQL利用索引</li>\n<li>检查所利用的索引，是否是最优索引</li>\n<li>检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据</li>\n<li>检查表中数据是否过多，是否应该进行分库分表了</li>\n<li>检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源</li>\n</ul>\n</blockquote>\n<h3 id=\"10-mysql有哪些引擎\"><a href=\"#10-mysql有哪些引擎\" class=\"headerlink\" title=\"10.mysql有哪些引擎\"></a>10.mysql有哪些引擎</h3><blockquote>\n<p>所谓的存储引擎是指用于存储、处理和保护数据的核心服务。也就是存储引擎是数据库的底层软件组织。在 MySQL 中可以使用“show engines”来查询数据库的所有存储引擎</p>\n<h2 id=\"InnoDB-存储引擎\"><a href=\"#InnoDB-存储引擎\" class=\"headerlink\" title=\"InnoDB 存储引擎\"></a>InnoDB 存储引擎</h2><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>(1) 支持自动增长列AUTO_INCREMENT。自动增长列的值不能为空，且值必须唯一。MySQL中规定自增列必须为主键。<br>(2) 支持外键，保证数据的完整性和正确性。外键所在表为子表，外键所依赖的表为父表。父表中被子表外键关联的字段必须为主键。<br>(3) DML(数据库操作)操作遵循ACID模型，支持事务。<br>(4) 行级锁 ，提高并发访问性能。</p>\n<h2 id=\"MyISAM-存储引擎\"><a href=\"#MyISAM-存储引擎\" class=\"headerlink\" title=\"MyISAM 存储引擎\"></a>MyISAM 存储引擎</h2><p>MyISAM是MySQL早期的默认存储引擎。</p>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>(1) 不支持事务，不支持外键<br>(2) 支持表锁，不支持行锁<br>(3) 占用空间小，访问速度快</p>\n<h2 id=\"Memory-存储引擎\"><a href=\"#Memory-存储引擎\" class=\"headerlink\" title=\"Memory 存储引擎\"></a>Memory 存储引擎</h2><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p>\n<h3 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>(1) 内存存放<br>(2) hash索引（默认）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/30d7e7b4350b44448627993e73505bb6.png\" alt=\"在这里插入图片描述\"></p>\n</blockquote>\n<h3 id=\"11-索引的作用\"><a href=\"#11-索引的作用\" class=\"headerlink\" title=\"11.索引的作用\"></a>11.索引的作用</h3><blockquote>\n<p>创建索引可以大大提高系统的性能。</p>\n<ul>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的<strong>唯一性</strong>。</li>\n<li>可以大大<strong>加快数据的检索速度</strong>，这也是创建索引的最主要的原因。</li>\n<li>可以<strong>加速表和表之间的连接</strong>，特别是在实现数据的参考完整性方面特别有意义。</li>\n<li>在使用分组和排序子句进行数据检索时，同样可以显著<strong>减少查询中分组和排序的时间</strong>。</li>\n<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>\n</ul>\n</blockquote>\n<h3 id=\"12-索引的类型\"><a href=\"#12-索引的类型\" class=\"headerlink\" title=\"12.索引的类型\"></a>12.索引的类型</h3><blockquote>\n<h2 id=\"存储方式区分\"><a href=\"#存储方式区分\" class=\"headerlink\" title=\"存储方式区分\"></a><strong>存储方式区分</strong></h2><h3 id=\"1-B-树索引\"><a href=\"#1-B-树索引\" class=\"headerlink\" title=\"1. B-树索引\"></a><strong>1. B-树索引</strong></h3><p>目前大多数索引都是采用B-树来存储，其包含组件有：</p>\n<ul>\n<li>叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。</li>\n<li>分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。</li>\n<li>根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。</li>\n</ul>\n<h3 id=\"2-哈希索引\"><a href=\"#2-哈希索引\" class=\"headerlink\" title=\"2. 哈希索引\"></a><strong>2. 哈希索引</strong></h3><p>哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B-树索引和 HASH 索引，且将 HASH 当成默认索引。</p>\n<p>哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：</p>\n<ul>\n<li>MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B-树索引来说，建立哈希索引会耗费更多的时间。</li>\n<li>不能使用 HASH 索引排序。</li>\n<li>HASH 索引只支持等值比较，如”=” “IN()”或”&lt;=&gt;”。</li>\n<li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。</li>\n</ul>\n<h2 id=\"逻辑区分\"><a href=\"#逻辑区分\" class=\"headerlink\" title=\"逻辑区分\"></a><strong>逻辑区分</strong></h2><h3 id=\"1-普通索引\"><a href=\"#1-普通索引\" class=\"headerlink\" title=\"1. 普通索引\"></a><strong>1. 普通索引</strong></h3><p>普通索引是 MySQL 中最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。允许重复值和空值。</p>\n<p>关键字是 <strong>INDEX</strong> 或 <strong>KEY</strong>。</p>\n<h3 id=\"2-唯一索引\"><a href=\"#2-唯一索引\" class=\"headerlink\" title=\"2. 唯一索引\"></a><strong>2. 唯一索引</strong></h3><p>唯一索引列的值必须唯一，允许有空值。如果是组合索引，则列值的组合必须唯一。</p>\n<p>关键字是 <strong>UNIQUE</strong>。</p>\n<h3 id=\"3-主键索引\"><a href=\"#3-主键索引\" class=\"headerlink\" title=\"3. 主键索引\"></a><strong>3. 主键索引</strong></h3><p>主键索引是一种特殊的唯一索引，不允许值重复或者值为空。</p>\n<p>关键字是 <strong>PRIMARY KEY</strong>。</p>\n<h3 id=\"4-空间索引\"><a href=\"#4-空间索引\" class=\"headerlink\" title=\"4. 空间索引\"></a><strong>4. 空间索引</strong></h3><p>空间索引是对空间数据类型的字段建立的索引，不允许空值，只能在存储引擎为 MyISAM 的表中创建。</p>\n<p>关键字是 <strong>SPATIAL</strong>。</p>\n<h3 id=\"5-全文索引\"><a href=\"#5-全文索引\" class=\"headerlink\" title=\"5. 全文索引\"></a><strong>5. 全文索引</strong></h3><p>全文索引主要用来查找文本中的关键字，只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。只有 MyISAM 存储引擎支持，允许重复值和空值。</p>\n<p>关键字是 <strong>FULLTEXT</strong>。</p>\n<h2 id=\"实际使用区分\"><a href=\"#实际使用区分\" class=\"headerlink\" title=\"实际使用区分\"></a><strong>实际使用区分</strong></h2><h3 id=\"1-单列索引\"><a href=\"#1-单列索引\" class=\"headerlink\" title=\"1. 单列索引\"></a><strong>1. 单列索引</strong></h3><p>单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。</p>\n<h3 id=\"2-组合索引\"><a href=\"#2-组合索引\" class=\"headerlink\" title=\"2. 组合索引\"></a><strong>2. 组合索引</strong></h3><p>组合索引也称为复合索引或多列索引。相对于单列索引来说，组合索引是将原表的多个列共同组成一个索引。</p>\n<p>查询时，字段顺序需与索引顺序一致；LIKE时，首字符不能是 ‘%’，否则会影响索引使用。</p>\n</blockquote>\n<h3 id=\"13-Mysql事务是什么，介绍一下\"><a href=\"#13-Mysql事务是什么，介绍一下\" class=\"headerlink\" title=\"13.Mysql事务是什么，介绍一下\"></a>13.Mysql事务是什么，介绍一下</h3><blockquote>\n<h3 id=\"事务：\"><a href=\"#事务：\" class=\"headerlink\" title=\"事务：\"></a><strong>事务</strong>：</h3><p>一个最小的不可再分的单元；可以理解为一个事务对应的是一组完整的业务，并且在这个事务中所作的一切操作要么全部成功，要么全部失败，只要有一个操作没成功，整个事务都将回滚到事务开始前。</p>\n<h3 id=\"事务的四大特征：\"><a href=\"#事务的四大特征：\" class=\"headerlink\" title=\"事务的四大特征：\"></a>事务的四大特征：</h3><p><strong>原子性</strong>：每一个事务都是一个不可再分的工作单位，事务中包括的操作要么都做，要么 都不做。</p>\n<p><strong>一致性</strong>：对于数据的操作从一个一致的状态转变成另一个一致转态。</p>\n<p><strong>隔离性</strong>：指一个事务的执行不能被其他事务干扰，即一个事务内部的操作对并发的其他事务是具有隔离的，并发执行的各个事务之间不能互相干扰。</p>\n<p><strong>持久性</strong>：一个事务一旦提交，他对数据库中的数据的改变就应该是永久性的。提交后的其他操作或故障不会对其具有任何影响。</p>\n</blockquote>\n<h3 id=\"14-Mysql主从了解吗，说说过程和原理\"><a href=\"#14-Mysql主从了解吗，说说过程和原理\" class=\"headerlink\" title=\"14.Mysql主从了解吗，说说过程和原理?\"></a>14.Mysql主从了解吗，说说过程和原理?</h3><blockquote>\n<h4 id=\"MySQL-主从复制概念\"><a href=\"#MySQL-主从复制概念\" class=\"headerlink\" title=\"MySQL 主从复制概念\"></a>MySQL 主从复制概念</h4><p>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>\n<h4 id=\"为什么需要主从复制？\"><a href=\"#为什么需要主从复制？\" class=\"headerlink\" title=\"为什么需要主从复制？\"></a>为什么需要主从复制？</h4><ul>\n<li>在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，<strong>让主库负责写，从库负责读</strong>，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li>\n<li><strong>做数据的热备</strong>，当主数据库有问题，可以切换从数据库</li>\n<li>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</li>\n</ul>\n<h4 id=\"MySQL主从复制原理\"><a href=\"#MySQL主从复制原理\" class=\"headerlink\" title=\"MySQL主从复制原理\"></a>MySQL主从复制原理</h4><p><img src=\"https://img-blog.csdnimg.cn/876363691c3c40e7ad176d6dc0e098fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluXzQwMjI4MjAw,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>从上图可以看出，MySQL主从同步实现主要有以下三个过程：<br>1、当有数据更改语句执行时，MySQL主库要在更新数据的同时，写二进制日志，将数据修改的内容记录进入日志中。<br>2、MySQL从库上运行这一些I/O进程，这个进程会监视MySQL主库上的二进制日志，当发现修改时，会立即同步到自身的中继日志。<br>3、MySQL从库上还会运行一个SQL进程，该进程用于监视自身的中继日志，当发现自身的中继日志发生改变时，立即将该中继日志改变对应的数据更改操作写入自身的数据库。</p>\n<h3 id=\"MySQL主从复制模式\"><a href=\"#MySQL主从复制模式\" class=\"headerlink\" title=\"MySQL主从复制模式\"></a>MySQL主从复制模式</h3><h4 id=\"异步复制\"><a href=\"#异步复制\" class=\"headerlink\" title=\"异步复制\"></a>异步复制</h4><blockquote>\n<p>在异步复制（async replication）中，Master不用关心Slave是否接收到二进制日志，所以Master与Slave没有任何的依赖关系。你可以认为Master和Slave是分别独自工作的两台服务器，数据最终会通过二进制日志达到一致。</p>\n<p>异步复制的性能最好，因为它对数据库本身几乎没有任何开销，除非主从延迟非常大，Dump Thread需要读取大量二进制日志文件。</p>\n<p>如果业务对于数据一致性要求不高，当发生故障时，能容忍<strong>数据的丢失</strong>，甚至大量的丢失，推荐用异步复制，这样性能最好（比如像微博这样的业务，虽然它对性能的要求极高，但对于数据丢失，通常可以容忍）。但往往核心业务系统最关心的就是数据安全，比如监控业务、告警系统。</p>\n</blockquote>\n<h4 id=\"半同步复制\"><a href=\"#半同步复制\" class=\"headerlink\" title=\"半同步复制\"></a>半同步复制</h4><blockquote>\n<p>主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relay log 中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟。<br>半同步复制的出现，就是为了保证在任何时刻主备数据一致的问题。相对于异步复制，半同步复制要求执行的每一个事务，都要求至少有一个备库成功接收后，才返回给用户。实现原理也很简单，主库本地执行完毕后，等待备库的响应消息（包含最新备库接收到的binlog（file，pos）），接收到备库响应消息后，再返回给用户，这样一个事务才算真正完成。在主库实例上，有一个专门的线程（ack_receiver）接收备库的响应消息，并以通知机制告知主库备库已经接收的日志，可以继续执行。</p>\n</blockquote>\n<h4 id=\"增强半同步复制\"><a href=\"#增强半同步复制\" class=\"headerlink\" title=\"增强半同步复制\"></a>增强半同步复制</h4><blockquote>\n<p>解决半同步复制中途数据不一致问题</p>\n<p>半同步的问题是因为等待ACK的点是Commit之后，此时Master已经完成数据变更，用户已经可以看到最新数据，当Binlog还未同步到Slave时，发生主从切换，那么此时从库是没有这个最新数据的，用户又看到老数据。</p>\n<p>增强半同步将等待ACK的点放在提交Commit之前，此时数据还未被提交，外界看不到数据变更，此时如果发送主从切换，新库依然还是老数据，不存在数据不一致的问题。<br><img src=\"https://img-blog.csdnimg.cn/20200721193729244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzMwNjg3,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n</blockquote>\n<h4 id=\"全同步复制\"><a href=\"#全同步复制\" class=\"headerlink\" title=\"全同步复制\"></a>全同步复制</h4><blockquote>\n<p>当主库提交事务之后，所有的从库节点必须收到、APPLY并且提交这些事务，然后主库线程才能继续做后续操作。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p>\n</blockquote>\n</blockquote>\n","categories":["面试"],"tags":["面试","MySQL"]},{"title":"Springboot面试(1)","url":"/2022/06/12/Springboot%E9%9D%A2%E8%AF%95(1)/","content":"<h2 id=\"springboot-1\"><a href=\"#springboot-1\" class=\"headerlink\" title=\"springboot(1)\"></a>springboot(1)</h2><h3 id=\"1-说说对springmvc的理解\"><a href=\"#1-说说对springmvc的理解\" class=\"headerlink\" title=\"1.说说对springmvc的理解\"></a>1.说说对springmvc的理解</h3><blockquote>\n<p><strong>什么是MVC</strong><br>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。</p>\n<p><strong>mvc设计模式的好处</strong></p>\n<p>1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</p>\n<p>2.有利于系统的并行开发，提升开发效率。</p>\n<p><strong>SpringMVC流程</strong></p>\n<p>1、 用户发送请求至前端控制器DispatcherServlet。</p>\n<p>2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>\n<p>3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>\n<p>4、 DispatcherServlet调用HandlerAdapter处理器适配器。</p>\n<p>5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p>\n<p>6、 Controller执行完成返回ModelAndView。</p>\n<p>7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p>\n<p>8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>\n<p>9、 ViewReslover解析后返回具体View。</p>\n<p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p>\n<p>11、 DispatcherServlet响应用户。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200508071612511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nvb2xfc3VtbWVyX21vb24=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><strong>核心组件</strong><br>DispatcherServlet（前端控制器）<br>说明：Spring MVC 的入口函数，接收请求，响应结果，相当于转发器，中央处理器，它就相当于mvc模式中DispatcherServlet的存在降低了组件之间的耦合性。<br>HandlerMapping(处理器映射器）<br>说明：根据请求的url查找Handler（即处理器Controller），映射方式有配置文件方式，实现接口方式，注解方式等。<br>HandlerAdapter(处理器适配器)<br>说明：HandlerAdapter是适配器模式的应用，按照HandlerAdapter要求的规则去执行Handler。<br>Handler（处理器）<br>说明：Handler需要开发工程师按照HandlerAdapter的要求去做，是后端控制器，处理具体的业务逻辑。<br>View resolver（视图解析器）<br>说明：进行视图解析，首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。<br>视图View<br>说明：View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf等）</p>\n<p>springMVC是一个MVC的开源框架，springMVC=struts2+spring，springMVC就相当于是Struts2加上sring的整合，但是这里有一个疑惑就是，springMVC和spring是什么样的关系呢？这个在百度百科上有一个很好的解释：意思是说，springMVC是spring的一个后续产品，其实就是spring在原有基础上，又提供了web应用的MVC模块，可以简单的把springMVC理解为是spring的一个模块（类似AOP，IOC这样的模块），网络上经常会说springMVC和spring无缝集成，其实springMVC就是spring的一个子模块，所以根本不需要同spring进行整合。</p>\n</blockquote>\n<h3 id=\"2-说说ioc和aop理解和原理\"><a href=\"#2-说说ioc和aop理解和原理\" class=\"headerlink\" title=\"2.说说ioc和aop理解和原理\"></a>2.说说ioc和aop理解和原理</h3><blockquote>\n<h1 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h1><p>IOC叫做控制反转，指的是通过Spring来管理对象创建、配置和生命周期，这样相当于把控制权交给了Spring，不需要人工来管理对象之间的复杂的依赖关系，这样做的好处就是解耦！</p>\n<p>在Spring里面，主要提供BeanFactory和ApplicationContext两种IOC容器，通过它们来实现对Bean的管理！</p>\n<h1 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h1><p>叫做面向切面编程，他是一个编程范式，目的就是提高代码的模块性。Spring AOP基于动态代理的方式实现，如果是实现了接口的话就会使用JDK动态代理，反之则使用CGLIB代理。Spring中AOP的应用主要体现在事务、日志、异常处理等方面，通过在代码的前后做一些增强处理，可以实现对业务的逻辑隔离，提高代码的模块化能力，同时也是解耦。Spring主要提供了Aspect切面，JoinPoint连接点、PointCut切入点、Advice增强等实现方式。</p>\n</blockquote>\n<h3 id=\"3-说说springboot的理解\"><a href=\"#3-说说springboot的理解\" class=\"headerlink\" title=\"3.说说springboot的理解\"></a>3.说说springboot的理解</h3><blockquote>\n<p>在使用spring框架的时候,我们需要配置applicationContext.xml的配置文件,并且在pom文件中,我们需要导入相关的依赖jar包以及版本,这样在使用的过程中,就显得有些复杂.</p>\n<p>而springboot利用起步依赖和自动装配就很好的解决了一个问题,首先,我们来说说起步依赖,在springboot的pom文件中,我们依赖<parent>父工程 ,在父工程中,定义了相关的坐标以及版本信息,这样我们继承了这个父工程的时候,就不需要指定版本信息,在我们的项目中.依赖了start-web这个坐标,而这个坐标依赖了spring以及springmvc的坐标,这样,根据依赖传递我们的项目就间接依赖了spring和mvc坐标,所有我们只需要导入start-web这一个坐标就可以了</parent></p>\n<p>接下来我们说说自动装配,在springboot的启动类上有一个@SpringBootApplication注解,这个注解也是springboot项目的核心注解,在@SpringBootApplication注解中,有一个@EnableAutoConfiguration注解,也就是开启自动配置的意思,这个注解的关键功能由@Import提供,其导入的AutoConfigurationImportSelector中的selectImports()方法能够找到META-INF/spring.factories配置文件中的所有启动配置类,并对其进行加载,而这些自动配置类都是以AtuoConfiguration结尾来命名的,它实际上就是一个JavaConfig形式的Spring容器配置类,通过@ConfigurationProperties注解,绑定到对应的以properties结尾的配置实体类上封装为一个bean,然后在通过@EnableAutoConfiguration注解导入到Spring容器中,这样自动装配就完成了.</p>\n</blockquote>\n<h3 id=\"4-使用过过滤器或者拦截器吗，说说拦截器的方法和实现的接口\"><a href=\"#4-使用过过滤器或者拦截器吗，说说拦截器的方法和实现的接口\" class=\"headerlink\" title=\"4.使用过过滤器或者拦截器吗，说说拦截器的方法和实现的接口\"></a>4.使用过过滤器或者拦截器吗，说说拦截器的方法和实现的接口</h3><blockquote>\n<p>使用过</p>\n<p>用过滤器主要做过全局网关配置请求token和跨域问题，实现Filter接口</p>\n<p>用拦截器主要做日志输出，实现HandlerInterceptor 接口，有三个方法，preHandle，postHandle，afterCompletion，分别是请求之前调用，之后调用，结束后调用，然后相比过滤器，它需要在springmvc注入，在启动类添加配置代码。实现WebMvcConfigurer接口添加拦截器。</p>\n</blockquote>\n<h3 id=\"5-aop在什么情况下会使用到\"><a href=\"#5-aop在什么情况下会使用到\" class=\"headerlink\" title=\"5.aop在什么情况下会使用到\"></a>5.aop在什么情况下会使用到</h3><blockquote>\n<p>AOP的应用场景：<br>1.日志处理<br>2.用户登录<br>3.权限（Authentication ）<br>4.性能优化（Performance optimization）<br>5.事务（Transactions ）<br>6.记录跟踪　优化　校准（logging, tracing, profiling and monitoring）<br>7.调试（Debugging）<br>8.懒加载（Lazy loading）<br>9.错误处理（Error handling）<br>10.资源池（Resource pooling）<br>11.同步（Synchronization）</p>\n</blockquote>\n<h3 id=\"6-如果有过滤器和拦截器和aop，他们的执行顺序是什么\"><a href=\"#6-如果有过滤器和拦截器和aop，他们的执行顺序是什么\" class=\"headerlink\" title=\"6.如果有过滤器和拦截器和aop，他们的执行顺序是什么\"></a>6.如果有过滤器和拦截器和aop，他们的执行顺序是什么</h3><blockquote>\n<p>执行顺序依次是过滤器、拦截器、切面</p>\n</blockquote>\n<h3 id=\"7-Spring-中的bean-是线程安全的吗\"><a href=\"#7-Spring-中的bean-是线程安全的吗\" class=\"headerlink\" title=\"7.Spring 中的bean 是线程安全的吗\"></a>7.Spring 中的bean 是线程安全的吗</h3><blockquote>\n<p>Spring本身并没有针对Bean做线程安全的处理，所以:</p>\n<p>1.如果Bean是无状态的，那么Bean则是线程安全的</p>\n<p>2.如果Bean是有状态的，那么Bean则不是线程安全的</p>\n<p>另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。</p>\n<p>(<strong>有状态会话bean</strong>  ：每个用户有自己特有的一个实例，在用户的生存期内，bean保持了用户的信息，即“有状态”；一旦用户灭亡（调用结束或实例结束），bean的生命期也告结束。即每个用户最初都会得到一个初始的bean。简单来说，有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是<strong>非线程安全</strong>的。<br><strong>无状态会话bean</strong>  ：bean一旦实例化就被加进会话池中，各个用户都可以共用。即使用户已经消亡，bean  的生命期也不一定结束，它可能依然存在于会话池中，供其他用户调用。由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean。但无状态会话bean  并非没有状态，如果它有自己的属性（变量），那么这些变量就会受到所有调用它的用户的影响，这是在实际应用中必须注意的。简单来说，无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是<strong>线程安全</strong>的。)</p>\n</blockquote>\n<h3 id=\"8-BeanFactory和ApplicationContext的区别\"><a href=\"#8-BeanFactory和ApplicationContext的区别\" class=\"headerlink\" title=\"8.BeanFactory和ApplicationContext的区别\"></a>8.<strong>BeanFactory和ApplicationContext的区别</strong></h3><blockquote>\n<p><strong>BeanFactory：</strong></p>\n<p>是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；</p>\n<p><strong>ApplicationContext：</strong></p>\n<p>应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能；</p>\n<ol>\n<li><p>国际化（MessageSource）</p>\n</li>\n<li><p>访问资源，如URL和文件（ResourceLoader）</p>\n</li>\n<li><p>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  </p>\n</li>\n<li><p>消息发送、响应机制（ApplicationEventPublisher）</p>\n</li>\n<li><p>AOP（拦截器）</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"9-Transactional-注解的失效场景\"><a href=\"#9-Transactional-注解的失效场景\" class=\"headerlink\" title=\"9.@Transactional 注解的失效场景\"></a>9.@Transactional 注解的失效场景</h3><blockquote>\n<p><strong>1、@Transactional 应用在非 public 修饰的方法上</strong></p>\n<p>如果Transactional注解应用在非public 修饰的方法上，Transactional将会失效。</p>\n<p>注意：protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</p>\n<p><strong>2、@Transactional 注解属性 propagation 设置错误</strong></p>\n<p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p>\n<p>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p>\n<p><strong>3、@Transactional 注解属性 rollbackFor 设置错误</strong></p>\n<p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务，其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定rollbackFor属性。</p>\n<p><strong>4、同一个类中方法调用，导致@Transactional失效</strong></p>\n<p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。当外界调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。那为什么会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</p>\n</blockquote>\n<h3 id=\"10-spring运用了哪些设计模式\"><a href=\"#10-spring运用了哪些设计模式\" class=\"headerlink\" title=\"10.spring运用了哪些设计模式\"></a>10.spring运用了哪些设计模式</h3><blockquote>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。</p>\n<h3 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h3><p>Spring中jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是Spring并没有使用这种方式，而是使用Callback模式与模板方法配合，既达到了代码复用的效果，同时增加了灵活性。</p>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p>观察者设计模式是一种对象行为模式。它表示的是一种对象与对象之间具有<a href=\"https://so.csdn.net/so/search?q=%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB&spm=1001.2101.3001.7020\">依赖关系</a>，当一个对象发生改变时，这个对象锁依赖的对象也会做出反应。Spring事件驱动模型就是观察者模式很经典的应用。</p>\n<h3 id=\"适配器-模式\"><a href=\"#适配器-模式\" class=\"headerlink\" title=\"适配器 模式\"></a>适配器 模式</h3><p>适配器设计模式将一个接口转换成客户希望的另一个接口，适配器模式使得接口不兼容的那些类可以一起工作，其别名为包装器。在Spring MVC中，DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler，解析到对应的Handler（也就是我们常说的Controller控制器）后，开始由HandlerAdapter适配器处理。为什么要在Spring MVC中使用适配器模式？Spring MVC中的Controller种类众多不同类型的Controller通过不同的方法来对请求进行处理，有利于代码的维护拓展。</p>\n<h3 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h3><p>装饰者设计模式可以动态地给对象增加些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。Spring 中配置DataSource的时候，DataSource可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下切换不同的数据源？这个时候据需要用到装饰者模式。</p>\n<h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><p>Spring 框架的资源访问接口就是基于策略设计模式实现的。该接口提供了更强的资源访问能力，Spring框架本身大量使用了Resource接口来访问底层资源。Resource接口本身没有提供访问任何底层资源的实现逻辑，针对不同的额底层资源，Spring将会提供不同的Resource实现类，不同的实现类负责不同的资源访问类型。</p>\n</blockquote>\n<h3 id=\"11-Springboot中常用注解有哪些，简述一下注解的作用\"><a href=\"#11-Springboot中常用注解有哪些，简述一下注解的作用\" class=\"headerlink\" title=\"11.Springboot中常用注解有哪些，简述一下注解的作用\"></a>11.Springboot中常用注解有哪些，简述一下注解的作用</h3><blockquote>\n<h3 id=\"SpringBootApplication\"><a href=\"#SpringBootApplication\" class=\"headerlink\" title=\"@SpringBootApplication\"></a>@SpringBootApplication</h3><ul>\n<li>这个注解很常见了，每次在启动SpringBoot项目的时候，都会见到它，它作用在类上，标识该类为SpringBoot项目启动类。<br>并且让SpringBoot自动给程序进行必要的配置，等同于@Configuration、@EnableAutoConfiguration、@ComponentScan这三个注解。</li>\n</ul>\n<h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"@Configuration\"></a>@Configuration</h3><ul>\n<li>相当于传统Spring的xml配置文件。</li>\n<li>如果第三方库需要用到xml文件，建议通过@Configuration类作为项目的配置主类，可以使用@ImportResource注解加载xml配置文件。</li>\n</ul>\n<h3 id=\"EnableAutoConfiguration-自动配置。\"><a href=\"#EnableAutoConfiguration-自动配置。\" class=\"headerlink\" title=\"@EnableAutoConfiguration 自动配置。\"></a>@EnableAutoConfiguration 自动配置。</h3><ul>\n<li>SpringBoot自动配置(auto-configuration)，尝试根据你添加的启动器(starter)自动配置你的SpringBoot应用。</li>\n<li>你可以将@EnableAutoConfiguration注解或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。</li>\n<li>如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</li>\n</ul>\n<h3 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h3><ul>\n<li>如果某个类加上@ComponentScan注解，则该类会自动发现扫描组件。</li>\n<li>也就是说，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。</li>\n<li>我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，SpringBoot会扫描启动类所在包下以及子包下的使用了@Component、@Controller、@Service、@Repository等注解的类。</li>\n</ul>\n<h3 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"@Controller\"></a>@Controller</h3><ul>\n<li>@Controller注解用于定义控制器类，在SpringBoot中由控制器负责将用户发来的URL请求转发到对应的服务接口(Controller层)。</li>\n<li>一般这个注解用在类上，控制器方法需要加上@RequestMapping注解。</li>\n</ul>\n<h3 id=\"ResponseBody\"><a href=\"#ResponseBody\" class=\"headerlink\" title=\"@ResponseBody\"></a>@ResponseBody</h3><ul>\n<li>如果控制器方法加上@ResponseBody注解，该方法的返回结果将直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。</li>\n<li>在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。</li>\n<li>比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</li>\n</ul>\n<h3 id=\"RestController\"><a href=\"#RestController\" class=\"headerlink\" title=\"@RestController\"></a>@RestController</h3><ul>\n<li>@RestController注解是@Controller和@ResponseBody的合集。</li>\n<li>使用在类上，表示该类是控制器，并且类中所有控制器方法的返回值直接填入HTTP响应体中，是RESTful风格的控制器，控制器方法返回JSON数据。</li>\n</ul>\n<h3 id=\"RequestMapping\"><a href=\"#RequestMapping\" class=\"headerlink\" title=\"@RequestMapping\"></a>@RequestMapping</h3><ul>\n<li>提供路由信息，负责URL到Controller中的具体方法的映射。</li>\n</ul>\n<h3 id=\"Import\"><a href=\"#Import\" class=\"headerlink\" title=\"@Import\"></a>@Import</h3><ul>\n<li>用来导入其他配置类（加了@Configuration注解的类）。</li>\n</ul>\n<h3 id=\"ImportResource\"><a href=\"#ImportResource\" class=\"headerlink\" title=\"@ImportResource\"></a>@ImportResource</h3><ul>\n<li>用来加载xml配置文件。</li>\n</ul>\n<h3 id=\"PathVariable\"><a href=\"#PathVariable\" class=\"headerlink\" title=\"@PathVariable\"></a>@PathVariable</h3><ul>\n<li>获取URL上的参数（Restful风格接口）。</li>\n</ul>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"@Service\"></a>@Service</h3><ul>\n<li>一般用于修饰service层的组件</li>\n</ul>\n<h3 id=\"Repository\"><a href=\"#Repository\" class=\"headerlink\" title=\"@Repository\"></a>@Repository</h3><ul>\n<li>使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</li>\n</ul>\n<h3 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h3><ul>\n<li>用@Bean标注方法等价于XML中配置的bean，意思是产生一个bean，并交给SpringBoot管理。</li>\n</ul>\n<h3 id=\"Value\"><a href=\"#Value\" class=\"headerlink\" title=\"@Value\"></a>@Value</h3><ul>\n<li>注入SpringBoot中的配置文件——application.properties配置的属性的值。</li>\n</ul>\n<h3 id=\"Inject\"><a href=\"#Inject\" class=\"headerlink\" title=\"@Inject\"></a>@Inject</h3><ul>\n<li>等价于默认的@Autowired，只是没有required属性。</li>\n</ul>\n<h3 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"@Component\"></a>@Component</h3><ul>\n<li>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</li>\n</ul>\n<h3 id=\"AutoWired\"><a href=\"#AutoWired\" class=\"headerlink\" title=\"@AutoWired\"></a>@AutoWired</h3><ul>\n<li>自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。</li>\n</ul>\n<h3 id=\"Qualifier\"><a href=\"#Qualifier\" class=\"headerlink\" title=\"@Qualifier\"></a>@Qualifier</h3><ul>\n<li>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者。</li>\n</ul>\n<h3 id=\"Resource-name-”name”-type-”type”\"><a href=\"#Resource-name-”name”-type-”type”\" class=\"headerlink\" title=\"@Resource(name=”name”,type=”type”)\"></a>@Resource(name=”name”,type=”type”)</h3><ul>\n<li>没有括号内内容的话，默认byName。与@Autowired干类似的事。</li>\n</ul>\n<h2 id=\"附页\"><a href=\"#附页\" class=\"headerlink\" title=\"附页\"></a>附页</h2><table>\n<thead>\n<tr>\n<th>注解</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Component</td>\n<td>最普通的组件，可以被注入到spring容器进行管理</td>\n</tr>\n<tr>\n<td>@Repository</td>\n<td>作用于持久层</td>\n</tr>\n<tr>\n<td>@Service</td>\n<td>作用于业务逻辑层</td>\n</tr>\n<tr>\n<td>@Controller</td>\n<td>作用于表现层（spring-mvc的注解）</td>\n</tr>\n</tbody></table>\n<p>这几个注解几乎可以说是一样的：因为被这些注解修饰的类就会被Spring扫描到并注入到Spring的bean容器中。</p>\n<p>@Autowired是根据<strong>类型</strong>进行自动装配的，如果找到多个类型相同的，会按照名称进行匹配，如果名称相同，会报错，如果需要按指定名称进行装配，则需要配合@Qualifier；</p>\n<p>@Inject是根据<strong>类型</strong>进行自动装配的，如果需要按名称进行装配，则需要配合@Named；</p>\n<p>@Resource是根据<strong>名称</strong>进行自动装配的，一般会指定一个name属性</p>\n<p><strong>总结:</strong></p>\n<p>1、@Autowired是spring自带的，@Inject是JSR330规范实现的，@Resource是JSR250规范实现的，需要导入不同的包</p>\n<p>2、@Autowired、@Inject用法基本一样，不同的是@Autowired有一个request属性</p>\n<p>3、@Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的</p>\n<p>4、@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Name一起使用</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","Springboot"]},{"title":"Redis面试","url":"/2022/06/12/Redis%E9%9D%A2%E8%AF%95/","content":"<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h3 id=\"1-redis-的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？\"><a href=\"#1-redis-的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？\" class=\"headerlink\" title=\"1.redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？\"></a>1.redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？</h3><blockquote>\n<h3 id=\"redis-持久化的两种方式\"><a href=\"#redis-持久化的两种方式\" class=\"headerlink\" title=\"redis 持久化的两种方式\"></a>redis 持久化的两种方式</h3><ul>\n<li><p>RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。</p>\n</li>\n<li><p>AOF（append only file）：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。</p>\n<h4 id=\"RDB-优缺点\"><a href=\"#RDB-优缺点\" class=\"headerlink\" title=\"RDB 优缺点\"></a><strong>RDB 优缺点</strong></h4><ul>\n<li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</li>\n<li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li>\n<li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</li>\n<li>如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</li>\n<li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li>\n</ul>\n<h4 id=\"AOF-优缺点\"><a href=\"#AOF-优缺点\" class=\"headerlink\" title=\"AOF 优缺点\"></a>AOF 优缺点</h4><ul>\n<li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次<code>fsync</code>操作，最多丢失 1 秒钟的数据。</li>\n<li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li>\n<li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li>\n<li>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li>\n<li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li>\n<li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code>，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低）</li>\n<li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li>\n</ul>\n<h3 id=\"RDB-和-AOF-到底该如何选择\"><a href=\"#RDB-和-AOF-到底该如何选择\" class=\"headerlink\" title=\"RDB 和 AOF 到底该如何选择\"></a>RDB 和 AOF 到底该如何选择</h3><ul>\n<li>不要仅仅使用 RDB，因为那样会导致你丢失很多数据；</li>\n<li>也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；</li>\n<li>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"2-说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？\"><a href=\"#2-说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？\" class=\"headerlink\" title=\"2.说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？\"></a>2.<strong>说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？</strong></h3><blockquote>\n<h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a><strong>缓存雪崩</strong></h2><p><strong>出现过程</strong></p>\n<p>假设有如下一个系统，高峰期请求为5000次/秒，4000次走了缓存，只有1000次落到了数据库上，数据库每秒1000的并发是一个正常的指标，完全可以正常工作，<strong>但如果缓存宕机了，或者缓存设置了相同的过期时间，导致缓存在同一时刻同时失效</strong>，每秒5000次的请求会全部落到数据库上，数据库立马就死掉了，因为数据库一秒最多抗2000个请求，如果DBA重启数据库，立马又会被新的请求打死了，这就是缓存雪崩。</p>\n<p><strong>解决方法</strong></p>\n<ol>\n<li>事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃</li>\n<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL被打死</li>\n<li>事后：redis持久化RDB+AOF，快速恢复缓存数据</li>\n<li>缓存的失效时间设置为随机值，避免同时失效</li>\n</ol>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a><strong>缓存穿透</strong></h2><p><strong>出现过程</strong></p>\n<p>假如客户端每秒发送5000个请求，其中4000个为黑客的恶意攻击，即在数据库中也查不到。举个例子，用户id为正数，黑客构造的用户id为负数，如果黑客每秒一直发送这4000个请求，缓存就不起作用，数据库也很快被打死。</p>\n<p><strong>解决方法</strong></p>\n<ol>\n<li>对请求参数进行校验，不合理直接返回</li>\n<li>查询不到的数据也放到缓存，value为空，如 set -999 “”</li>\n<li>使用布隆过滤器，快速判断key是否在数据库中存在，不存在直接返回</li>\n</ol>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a><strong>缓存击穿</strong></h2><p><strong>出现过程</strong></p>\n<p>设置了过期时间的key，承载着高并发，是一种热点数据。从这个key过期到重新从MySQL加载数据放到缓存的一段时间，大量的请求有可能把数据库打死。缓存雪崩是指大量缓存失效，缓存击穿是指热点数据的缓存失效</p>\n<p><strong>解决方法</strong></p>\n<ol>\n<li><p>设置key永远不过期，或者快过期时，通过另一个异步线程重新设置key</p>\n</li>\n<li><p>当从缓存拿到的数据为null，重新从数据库加载数据的过程上锁，下面写个分布式锁实现的demo</p>\n</li>\n</ol>\n   <figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">1，缓存雪崩:如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期时间上增加一点随机值，另外如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段</span><br><span class=\"line\">2．缓存击穿:和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿，解决方案就是考虑这个热点key不设过期时间</span><br><span class=\"line\">3．缓存穿透:假如某一时刻访问redis的大量key都在redis中不存在(比如黑客故意伪造一些乱七八糟的key)，那么也会给数据造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n<h3 id=\"3-redis为什么快\"><a href=\"#3-redis为什么快\" class=\"headerlink\" title=\"3.redis为什么快\"></a>3.redis为什么快</h3><blockquote>\n<ul>\n<li>1、<code>Redis</code> 是一款纯内存结构，避免了磁盘 <code>I/O</code> 等耗时操作。</li>\n<li>2、<code>Redis</code> 命令处理的核心模块为单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。</li>\n<li>3、采用了 <code>I/O</code> 多路复用机制，大大提升了并发效率。</li>\n</ul>\n</blockquote>\n<h3 id=\"4-redis缓存淘汰策略\"><a href=\"#4-redis缓存淘汰策略\" class=\"headerlink\" title=\"4.redis缓存淘汰策略\"></a>4.redis缓存淘汰策略</h3><blockquote>\n<p>Redis内存不足的缓存淘汰策略提供了8种。<br>noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键<br>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键<br>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键<br>allkeys-random：加入键的时候如果过限，从所有key随机删除<br>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐<br>volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键<br>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键<br>allkeys-lfu：从所有键中驱逐使用频率最少的键</p>\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">这八种大体上可以分为4中，lru、lfu、random、ttl。</span><br><span class=\"line\">lru：Least Recently Used)，最近最少使用</span><br><span class=\"line\">lfu：Least Frequently Used，最不经常使用法</span><br><span class=\"line\">ttl：Time To Live，生存时间</span><br><span class=\"line\">random：随机</span><br><span class=\"line\">默认是noeviction。对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外</span><br><span class=\"line\">eviction：“逐出；赶出；收回”。</span><br><span class=\"line\">volatile：“不稳定的”。</span><br></pre></td></tr></table></figure>\n\n<p><strong>Redis默认的过期策略是noeviction, 最暴力那个, 如果内存满了那就是一场“华丽”的故事了。</strong></p>\n</blockquote>\n<h3 id=\"5-Redis有哪些数据结构？分别有哪些典型的应用场景\"><a href=\"#5-Redis有哪些数据结构？分别有哪些典型的应用场景\" class=\"headerlink\" title=\"5.Redis有哪些数据结构？分别有哪些典型的应用场景?\"></a>5.Redis有哪些数据结构？分别有哪些典型的应用场景?</h3><blockquote>\n<p>Redis的数据结构有:</p>\n<ul>\n<li>字符串:可以用来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</li>\n<li>哈希表:可以用来存储一些key-value对，更适合用来存储对象</li>\n<li>列表: Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据</li>\n<li>集合:和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似,<br>我和某人共同关注的人、朋友圈点赞等功能</li>\n<li>有序集合:集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</li>\n</ul>\n</blockquote>\n<h3 id=\"6-Redis分布式锁底层是如何实现的\"><a href=\"#6-Redis分布式锁底层是如何实现的\" class=\"headerlink\" title=\"6.Redis分布式锁底层是如何实现的\"></a>6.Redis分布式锁底层是如何实现的</h3><blockquote>\n<ul>\n<li>首先利用setnx来保证:如果key不存在才能获取到锁，如果key存在，则获取不到锁</li>\n<li>然后还要利用lua脚本来保证多个redis操作的原子性</li>\n<li>同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约</li>\n<li>同时还要考虑到redis书点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</li>\n</ul>\n</blockquote>\n<h3 id=\"7-Redis和Mysql如何保证数据一致\"><a href=\"#7-Redis和Mysql如何保证数据一致\" class=\"headerlink\" title=\"7.Redis和Mysql如何保证数据一致\"></a>7.Redis和Mysql如何保证数据一致</h3><blockquote>\n<p>1．先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致</p>\n<p>2．先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中</p>\n<p>3，延时双删，步骤是:先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","Redis"]},{"title":"Springboot面试(2)","url":"/2022/07/02/Springboot%E9%9D%A2%E8%AF%95(2)/","content":"<h2 id=\"springboot-2\"><a href=\"#springboot-2\" class=\"headerlink\" title=\"springboot(2)\"></a>springboot(2)</h2><h3 id=\"1-Spring-boot的核心配置文件是什么\"><a href=\"#1-Spring-boot的核心配置文件是什么\" class=\"headerlink\" title=\"1.Spring boot的核心配置文件是什么\"></a>1.Spring boot的核心配置文件是什么</h3><blockquote>\n<p>Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。</p>\n<p>bootstrap 配置文件是系统级别的，用来加载外部配置，如配置中心的配置信息，也可以用来定义系统不会变化的属性.bootstatp 文件的加载先于application文件<br>application 配置文件是应用级别的，是当前应用的配置文件</p>\n</blockquote>\n<h3 id=\"2-如何使用jwt进行登录校验\"><a href=\"#2-如何使用jwt进行登录校验\" class=\"headerlink\" title=\"2.如何使用jwt进行登录校验\"></a>2.如何使用jwt进行登录校验</h3><blockquote>\n<p>（1）<strong>客户端登录成功后（必须是在登陆成功才行，与session一样的前提条件）</strong>，服务器会根据用户名和签名以及其他信息加密生成唯一的token串，用来区分他们，不需要存入服务端的缓存中，但会把这个token返回给相应的主机，</p>\n<p>（2）主机收到token后会存入cookie或者localStorage中，以后主机的每一次发送其他类型的请求的操作都会携带这个token，</p>\n<p>（3）服务器会将客户端发来的这个token和服务端从数据库查询出来的并且重新计算得到的用户信息进行对比，如果匹配，则<strong>认证成功</strong>，如果用户请求的资源需要相应的权限，则校验token中的payload中存储的权限等相关信息，如果有权限则返回给对应主机所需要的资源（<strong>即做到了权限鉴权</strong>），否则拒绝</p>\n<p><code>用的依赖是java-jwt，用的包是auth0.jwt</code></p>\n</blockquote>\n<h3 id=\"3-生成的token在服务端有哪些存储方案\"><a href=\"#3-生成的token在服务端有哪些存储方案\" class=\"headerlink\" title=\"3.生成的token在服务端有哪些存储方案\"></a>3.生成的token在服务端有哪些存储方案</h3><blockquote>\n<p>（1）保存在redis，最常用，也是分布式下的验证token的解决方案，</p>\n<p>（2）数据库存储，性能比redis稍差，速度稍慢</p>\n<p>（3）不做保存，下次验证的时候直接用jwt.decode验证(服务端为express)，存储的压力给到了客户端，但是每次从客户端传到服务器端的数据量会稍微大一些</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","Springboot"]},{"title":"Jvm面试","url":"/2022/06/12/jvm%E9%9D%A2%E8%AF%95/","content":"<h2 id=\"jvm\"><a href=\"#jvm\" class=\"headerlink\" title=\"jvm\"></a>jvm</h2><h3 id=\"1-JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？\"><a href=\"#1-JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？\" class=\"headerlink\" title=\"1.JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？\"></a>1.<strong>JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？</strong></h3><blockquote>\n<p>JVM运行时一共划分：程序计数器、虚拟机栈、堆、本地方法栈、方法区。</p>\n<p>线程共享的数据区域：堆、方法区。</p>\n<p>线程独享的数据区域区域：程序计数器、虚拟机栈、本地方法栈。</p>\n<h3 id=\"连问（1）这几个内存区域分别存放什么数据？\"><a href=\"#连问（1）这几个内存区域分别存放什么数据？\" class=\"headerlink\" title=\"连问（1）这几个内存区域分别存放什么数据？\"></a>连问（1）<strong>这几个内存区域分别存放什么数据？</strong></h3><blockquote>\n<p><strong>程序计数器</strong>: 记录当前线程执行的位置</p>\n<p><strong>虚拟机栈</strong>: 存储基本数据类型以及对象的引用等</p>\n<p><strong>堆</strong>: 存储对象实例</p>\n<p><strong>本地方法栈</strong>: 与虚拟机栈类似，它为Native方法服务</p>\n<p><strong>方法区</strong>: 存储被JVM加载的类信息、常量、静态变量等。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"2-JVM内存怎么分配的\"><a href=\"#2-JVM内存怎么分配的\" class=\"headerlink\" title=\"2.JVM内存怎么分配的\"></a>2.JVM内存怎么分配的</h3><blockquote>\n<p>方法区:</p>\n<p>有时候也称为永久代（Permanent Generation）</p>\n<p><em><strong>注意: 在Java8中，永久代已经被移除，被一个称为“元数据区”(元空间)的区域所取代。</strong></em> </p>\n<p><em><strong>方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。</strong></em></p>\n<blockquote>\n<p>在方法区中，存储了每个类的信息（包括类的名称、修饰符、方法信息、字段信息）、类中静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息以及编译器编译后的代码等。当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，在这里进行的GC主要是方法区里的常量池和类型的卸载。当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。</p>\n<p>在方法区中有一个非常重要的部分就是运行时常量池，用于存放静态编译产生的字面量和符号引用。运行时生成的常量也会存在这个常量池中，比如String的intern方法。它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。</p>\n</blockquote>\n<p>JVM堆分代</p>\n<blockquote>\n<p>1、JVM堆被分为了年轻代和老年代。年轻代的GC过程称为Yong GC，速度快较频繁。老年代的GC过程称为Full GC，速度较慢应该尽量避免。</p>\n<p>2、对象被创建后，除了少部分大对象会在老年代分配内存外，大部分的对象首先都是在年轻代进行内存分配，而且大部分的对象都是“朝生夕死”，很快就会被年轻代的Yong GC回收掉。</p>\n<p>3、老年代的内存空间一般会比年轻代的内存空间大，能存放的对象多，老年代的空间不足后会进行Full GC操作，比Yong GC耗时，所以应尽量避免频繁的Full GC操作。</p>\n</blockquote>\n<p>年轻代的分区</p>\n<blockquote>\n<p>1、年轻代中分为一个Eden区和两个Surviver区，比例为8：1：1，两个Surviver区分别称为“From”区和“To”区。对象在Eden区创建，经过一次Yong GC后，还存活的对象将会被复制到Surviver区的“From”区，此时“To”区是空的。到了下一次GC的时候，Eden区还存活的对象会复制到Surviver区的“To”区，而“Form”区的对象有两个去处，“From”区的对象会根据经过的GC次数计算年龄，如果年龄到达了阈值（默认15），则会被移动到老年代中，否则就复制到“To”区，此时“From”区变成了空的，然后“From”区和“To”区进行角色互换，到下一次进行GC时，还是有一块空的“To”区，用来存放从eden区和“From”区移动过来的对象。</p>\n<p>2、那这种分区有什么好处呢？</p>\n<p>a、在年轻代新增Surviver区，有利于减轻老年代的负担，尽可能的让大部分对象在年轻代通过较高效的Yong GC回收掉，不至于老年代里存放的对象过多导致内存不足而进行频繁的Full GC操作。</p>\n<p>b、这种分区有利于减少内存碎片的产生。</p>\n<p>首先我们来看看，如果年轻代只分为Eden区和Surviver区两个区域并且比例是8:2的时候，内存的回收和分配情况会怎么样。第一次Yong GC后，Eden区还存活的对象移动到Surviver区，Surviver区还存活的对象保留在Surviver区，而这些对象的内存是不连续的，Surviver区里就会产生很多内存碎片，这就会导致有些大对象要移动到Surviver区的时候，没有足够的连续内存进行分配，而不得不移动到老年代中，增加老年代的负担，降低效率。</p>\n<p>然后我们看看Eden区和Surviver区的比例是8:1:1时会有什么样的效果。第一次Yong GC后，Eden区还存活的对象复制到Surviver区的“To”区，“From”区还存活的对象也复制到“To”区，再清空Eden区和From区，这样就等于“From”区完全是空的了，而“To”区也不会有内存碎片产生，等到第二次Yong GC时，“From”区和“To”区角色互换，很好的解决了内存碎片的问题。</p>\n<h4 id=\"详细的过程：\"><a href=\"#详细的过程：\" class=\"headerlink\" title=\"详细的过程：\"></a>详细的过程：</h4><p>1.当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次<em><strong>YoungGC</strong></em>，也就是<em><strong>年轻代的垃圾回收</strong></em>。</p>\n<p>一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。</p>\n<p>2.这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，<strong>会将Eden区与From区还在被使用的对象复制到To区</strong>，</p>\n<p>3.再下一次YoungGC的时候，<strong>则是将Eden区与To区中的还在被使用的对象复制到From区</strong>。</p>\n<p>4.经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。</p>\n<p><img src=\"/2022/06/12/jvm%E9%9D%A2%E8%AF%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlZXJsZXNzX2Z1,size_16,color_FFFFFF,t_70.png\" alt=\"img\"></p>\n</blockquote>\n</blockquote>\n<h3 id=\"3-JVM怎么回收内存，gc机制是什么\"><a href=\"#3-JVM怎么回收内存，gc机制是什么\" class=\"headerlink\" title=\"3.JVM怎么回收内存，gc机制是什么?\"></a>3.JVM怎么回收内存，gc机制是什么?</h3><blockquote>\n<p>垃圾收集需要完成的三件事情：</p>\n<ul>\n<li><p>哪些内存需要回收？</p>\n<blockquote>\n<p>程序计数器，虚拟机栈和本地方法栈都是随线程而生，随线程而灭。 栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的因此这几个区域的内存分配和回收都具备确定性，<strong>在这几个区域内就不需要过多考虑如何回收的问题</strong>， 当方法结束或者线程结束时， 内存自然就跟随着回收了。</p>\n<p>而Java堆和方法区这两个区域则有着很显著的不确定性： 一个接口的多个实现类需要的内存可能会不一样， 一个方法所执行的不同条件分支所需要的内存也可能不一样， 只有处于运行期间， 我们才能知道程序究竟会创建哪些对象， 创建多少个对象， 这部分内存的分配和回收是动态的。 因此，垃圾收集器所关注的正是这部分内存该如何管理。</p>\n</blockquote>\n</li>\n<li><p>什么时候回收？ 哪些还“存活”着， 哪些已经“死去”了。</p>\n<blockquote>\n<p>判断对象是否死去通常有两种方法：引用计数算法和可达性分析算法。</p>\n<h4 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h4><p>引用计数算法：在对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加一； 当引用失效时， 计数器值就减一； 任何时刻计数器为零的对象就是不可能再被使用的。</p>\n<p>优点:</p>\n<ul>\n<li>原理简单，<strong>判断</strong>效率高</li>\n<li>实时性，<strong>任何内存，一旦没有指向它的引用，就会立即被回收</strong>。</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>内存分配和释放次数变多，维护引用计数代价越高（执行效率低）</li>\n<li>循环引用不能去使用（关键缺点）</li>\n</ul>\n<p>在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是这个看似简单的算法<strong>有很多例外情况要考虑</strong>，必须要配合大量额外处理才能保证正确地工作。</p>\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集， 从这些节点开始， 根据引用关系向下搜索， 搜索过程所走过的路径称为“引用链”（Reference Chain） ，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。</p>\n<p>如下图所示， 对象object 5、 object 6、 object 7虽然互有关联， 但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p>\n<p><img src=\"/2022/06/12/jvm%E9%9D%A2%E8%AF%95/Users\\12136\\Desktop\\blog\\source_posts\\jvm面试.assets\\30fd6c9f4f6645d21928035233adbed9.png\" alt=\"image.png\"></p>\n<p>在Java技术体系里面， 固定可作为GC Roots的对象包括以下几种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">在虚拟机栈（栈帧中的本地变量表）中引用的对象， 譬如，各个线程被调用的方法堆栈中使用到的参数、 局部变量、 临时变量等。</span><br><span class=\"line\">在方法区中类静态属性引用的对象， 譬如，Java类的引用类型静态变量。</span><br><span class=\"line\">在方法区中常量引用的对象， 譬如，字符串常量池（String Table）里的引用。</span><br><span class=\"line\">在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</span><br><span class=\"line\">Java虚拟机内部的引用，如，基本数据类型对应的Class对象， 一些常驻的异常对象（比如NullPointExcepiton、 OutOfMemoryError）等， 还有系统类加载器。</span><br><span class=\"line\">所有被同步锁（<span class=\"keyword\">synchronized</span>关键字）持有的对象。</span><br><span class=\"line\">反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、本地代码缓存等。</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n</li>\n<li><p>如何回收？</p>\n<blockquote>\n<p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段。</p>\n<p>这边就要用到垃圾收集算法</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它是最基础的收集算法，因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p>\n<p>缺点:</p>\n<ul>\n<li>标记和清除过程的效率都不高</li>\n<li>标记清除之后会产生大量的不连续的内存碎片，分配较大对象无法找到连续内存不得不触发另一次垃圾回收</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20200520095343831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3NTU0Mg==,size_16,color_FFFFFF,t_70\" alt=\"标记-清除算法执行过程\"></p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>为了解决效率问题，一种称为“复制”的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用一块。当这块内存用完了。就将还活着的对象复制到另一块上面，然后再把已经用过的内存空间一次清理掉。这样使得每次都是对其中一块内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免也太高了一点。</p>\n<p>如图所示，“<strong>半区域复制</strong>”这样实现的垃圾回收算法缺点显而易见<br>（1）内存利用效率太低，只能利用一半的内存<br>（2）如果内存中出现对象大都是存活的情况，将会产生大量内存间复制的开销</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200520101309851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3NTU0Mg==,size_16,color_FFFFFF,t_70\" alt=\"复制算法执行过程\"></p>\n<p>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更为优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。<br>  具体做法就是，把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生内存收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已使用过的那一块Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小默认时8:1，也即每次新生代中可用内存空间为整个新生代容量的90%，只有另一个Survivor空间，即10%的新生代是“浪费”的。如图：<br><img src=\"https://img-blog.csdnimg.cn/01ad068083f7434490866dd0e8399fc3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbG9yZGt5,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h3><p>复制算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对内存中被使用的所有的对象都100%存活的极端情况，<strong>所以在老年代一般不能直接选用这种算法。</strong><br>根据老年代的特点，有人提出了一种“标记-整理“算法，标记过程仍然与”标记-清除“算法一样，但是后续步骤不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。<br><img src=\"https://img-blog.csdnimg.cn/20200520110040232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3NTU0Mg==,size_16,color_FFFFFF,t_70\" alt=\"标记-整理算法执行过程\"></p>\n<h3 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾回收都采用”分代收集“算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为老年代和新生代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批的对象死去，只有少量存活，那就选用复制算法，只需要付出少量的存活对象的复制成本就可以完成收集。而老年代中因为对象的存活率高、没有额外的空间对他进行分配担保，就必须使用”标记-整理“或者”标记-清理“算法来进行回收。</p>\n<p>（1） 年轻代(Young Gen)</p>\n<p>年轻代特点是区域相对老年代较小，对像存活率低。</p>\n<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>\n<p>（2） 老年代(Tenure Gen)</p>\n<p>老年代的特点是区域较大，对像存活率高。</p>\n<p>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</p>\n<p>Mark阶段的开销与存活对像的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</p>\n<p>Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</p>\n<p>Compact阶段的开销与存活对像的数据成开比，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</p>\n<p>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>\n<h4 id=\"总结：没有最好的算法，只有最合适的算法\"><a href=\"#总结：没有最好的算法，只有最合适的算法\" class=\"headerlink\" title=\"总结：没有最好的算法，只有最合适的算法\"></a>总结：没有最好的算法，只有最合适的算法</h4></blockquote>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"4-static变量的初始化前后在jvm内存中的位置？\"><a href=\"#4-static变量的初始化前后在jvm内存中的位置？\" class=\"headerlink\" title=\"4.static变量的初始化前后在jvm内存中的位置？\"></a>4.static变量的初始化前后在jvm内存中的位置？</h3><blockquote>\n<p>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。</p>\n<p>静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</p>\n</blockquote>\n<h3 id=\"5-Java方法调用在jvm中是怎样的过程-方法栈、入参、返回值\"><a href=\"#5-Java方法调用在jvm中是怎样的过程-方法栈、入参、返回值\" class=\"headerlink\" title=\"5.Java方法调用在jvm中是怎样的过程(方法栈、入参、返回值)\"></a>5.Java方法调用在jvm中是怎样的过程(方法栈、入参、返回值)</h3><blockquote>\n<p>方法（Java中称为方法，其他语言一般称为函数）调用主要是通过栈来存储相关的数据，系统就方法调用者和方法如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回值存储器来存储的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sum</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">sum</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> a * b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> Sum.sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        System.out.println(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当程序在 main 方法调用 Sum.sum 之前，栈的情况大概如图所示。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/16766bef159f43a7588afbfb06017327.png\" alt=\"调用Sum.sum之前的栈示意图\"></p>\n<p>在 main 方法调用 Sum.sum 时，首先将参数 1 和 2 入栈，然后将返回地址（也就是调用方法结束后要执行的指令地址）入栈，<br>接着跳转到 sum 函数，在 sum 函数内部，需要为局部变量 c 分配一个空间，而参数变量 a 和 b 则直接对应于入栈的数据 1 和 2，在返回之前，返回值保存到了专门的返回值存储器中。</p>\n<p>在调用 return 后，程序会跳转到栈中保存的返回地址，即 main 的一条指令地址，而 sum 函数相关的数据会出栈，从而又变回上图中的样子。</p>\n<p>main 的下一条指令是根据方法返回值给变量 d 赋值，返回值从专门的返回值存储器中获得。<br><img src=\"https://img-blog.csdnimg.cn/img_convert/1f0d23ad1a920bd0cf2889940087e568.png\" alt=\"在Sum.sum内部，准备返回之前的栈示意图\"></p>\n<h3 id=\"程序执行的基本原理\"><a href=\"#程序执行的基本原理\" class=\"headerlink\" title=\"程序执行的基本原理\"></a>程序执行的基本原理</h3><p>CPU有一个指令指示器，指向下一条要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。</p>\n<p>具体到Java程序来说就是，程序从 main 方法开始顺序执行，方法调用可以看作一个无条件跳转，跳转到对应方法的指令处开始执行，<br>碰到 return 语句或者方法结尾的时候，再执行一次无条件跳转， 跳转回调用方，执行调用方法后的下一条指令。</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","Jvm"]},{"title":"lock锁和Synchronized锁","url":"/2022/07/10/lock%E9%94%81%E5%92%8CSynchronized%E9%94%81/","content":"<h1 id=\"lock锁和Synchronized锁\"><a href=\"#lock锁和Synchronized锁\" class=\"headerlink\" title=\"lock锁和Synchronized锁\"></a>lock锁和Synchronized锁</h1><blockquote>\n<h3 id=\"synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种\"><a href=\"#synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种\" class=\"headerlink\" title=\"synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种\"></a>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种</h3><h3 id=\"一个线程访问一个对象中的synchronized-this-同步代码块时，其他试图访问该对象的线程将被阻塞-：\"><a href=\"#一个线程访问一个对象中的synchronized-this-同步代码块时，其他试图访问该对象的线程将被阻塞-：\" class=\"headerlink\" title=\"(一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞)：\"></a>(一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞)：</h3><ol>\n<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 　</li>\n<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>\n<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li>\n<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ticket</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">number</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sale</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;:&quot;</span>+(number++));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Ticket</span> <span class=\"variable\">ticket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Ticket</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                ticket.sale();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;aa&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                ticket.sale();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;bb&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                ticket.sale();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;cc&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">aa:<span class=\"number\">0</span></span><br><span class=\"line\">aa:<span class=\"number\">1</span></span><br><span class=\"line\">aa:<span class=\"number\">2</span></span><br><span class=\"line\">aa:<span class=\"number\">3</span></span><br><span class=\"line\">aa:<span class=\"number\">4</span></span><br><span class=\"line\">bb:<span class=\"number\">5</span></span><br><span class=\"line\">bb:<span class=\"number\">6</span></span><br><span class=\"line\">bb:<span class=\"number\">7</span></span><br><span class=\"line\">bb:<span class=\"number\">8</span></span><br><span class=\"line\">bb:<span class=\"number\">9</span></span><br><span class=\"line\">cc:<span class=\"number\">10</span></span><br><span class=\"line\">cc:<span class=\"number\">11</span></span><br><span class=\"line\">cc:<span class=\"number\">12</span></span><br><span class=\"line\">cc:<span class=\"number\">13</span></span><br><span class=\"line\">cc:<span class=\"number\">14</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><blockquote>\n<p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p>\n<p>　　1）Lock不是Java语言内置的，synchronized是Java语言的<strong>关键字</strong>，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p>\n<p>　　2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p>\n<p><strong>synchronized 的局限性 与 Lock 的优点</strong>　</p>\n<p>　　如果一个代码块被synchronized关键字修饰，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待直至占有锁的线程释放锁。事实上，占有锁的线程释放锁一般会是以下三种情况之一：</p>\n<p>　　1：占有锁的线程执行完了该代码块，然后释放对锁的占有；</p>\n<p>　　2：占有锁线程执行发生异常，此时JVM会让线程自动释放锁；</p>\n<p>　　3：占有锁线程进入 WAITING 状态从而释放锁，例如在该线程中调用wait()方法等。</p>\n<p>　　试考虑以下三种情况：　</p>\n<p>Case 1 ：</p>\n<p>　　<strong>在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间 (解决方案：tryLock(long time, TimeUnit unit)) 或者 能够响应中断 (解决方案：lockInterruptibly())），这种情况可以通过 Lock 解决。</strong></p>\n<p>Case 2 ：</p>\n<p>　　<strong>我们知道，当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程都只是进行读操作时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。同样地，Lock也可以解决这种情况 (解决方案：ReentrantReadWriteLock) 。</strong></p>\n<p>Case 3 ：</p>\n<p>　　<strong>我们可以通过Lock得知线程有没有成功获取到锁 (解决方案：ReentrantLock) ，但这个是synchronized无法办到的。</strong></p>\n<p><strong>上面提到的三种情形，我们都可以通过Lock来解决，但 synchronized 关键字却无能为力。事实上，Lock 是 java.util.concurrent.locks包 下的接口，Lock 实现提供了比 synchronized 关键字 更广泛的锁操作，它能以更优雅的方式处理线程同步问题。也就是说，Lock提供了比synchronized更多的功能。</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ticket</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">number</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">sale</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;:&quot;</span>+(number++));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Ticket</span> <span class=\"variable\">ticket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Ticket</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                ticket.sale();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;aa&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                ticket.sale();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;bb&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">                ticket.sale();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;cc&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">aa:<span class=\"number\">0</span></span><br><span class=\"line\">aa:<span class=\"number\">1</span></span><br><span class=\"line\">aa:<span class=\"number\">2</span></span><br><span class=\"line\">aa:<span class=\"number\">3</span></span><br><span class=\"line\">aa:<span class=\"number\">4</span></span><br><span class=\"line\">cc:<span class=\"number\">5</span></span><br><span class=\"line\">cc:<span class=\"number\">6</span></span><br><span class=\"line\">cc:<span class=\"number\">7</span></span><br><span class=\"line\">cc:<span class=\"number\">8</span></span><br><span class=\"line\">cc:<span class=\"number\">9</span></span><br><span class=\"line\">bb:<span class=\"number\">10</span></span><br><span class=\"line\">bb:<span class=\"number\">11</span></span><br><span class=\"line\">bb:<span class=\"number\">12</span></span><br><span class=\"line\">bb:<span class=\"number\">13</span></span><br><span class=\"line\">bb:<span class=\"number\">14</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>lock没有主动用unlock()去释放锁,会造成死锁现象,因此用lock需要在finally块中释放锁.</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取锁  </span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果当前线程未被中断，则获取锁，可以响应中断  </span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">lockInterruptibly</span><span class=\"params\">()</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回绑定到此 Lock 实例的新 Condition 实例  </span></span><br><span class=\"line\">Condition <span class=\"title function_\">newCondition</span><span class=\"params\">()</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仅在调用时锁为空闲状态才获取该锁，可以响应中断  </span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">()</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁  </span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放锁  </span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span>  </span><br></pre></td></tr></table></figure>\n","categories":["java知识"],"tags":["java基础","方法句柄， JVM"]},{"title":"八锁问题","url":"/2022/07/10/%E5%85%AB%E9%94%81%E9%97%AE%E9%A2%98/","content":"<h1 id=\"八锁问题\"><a href=\"#八锁问题\" class=\"headerlink\" title=\"八锁问题\"></a>八锁问题</h1><ol>\n<li>new发短信后 睡眠100毫秒，发短信、发邮件的打印顺序</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Test0101</span> <span class=\"variable\">test0101</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0101</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0101.sendMessage();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AAA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0101.sendEmail();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BBB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test0101</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendMessage&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendEmail</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendEmail&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">sendMessage</span><br><span class=\"line\">sendEmail</span><br><span class=\"line\">因为<span class=\"keyword\">synchronized</span>关键字 是对该资源类的对象上锁，因此哪个线程先拿到对象锁，就先执行</span><br></pre></td></tr></table></figure>\n\n<p> 2.发短信线程中执行时睡眠4秒，发短信、发邮件的打印顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Test0201</span> <span class=\"variable\">test0201</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0201</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0201.sendMessage();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AAA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0201.sendEmail();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BBB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test0201</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendMessage&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendEmail</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendEmail&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">sendMessage</span><br><span class=\"line\">sendEmail</span><br><span class=\"line\">原理同上。还是上面的线程先拿到 资源类 锁对象</span><br></pre></td></tr></table></figure>\n\n<p>3.打电话线程，发短信、打电话的打印顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test03</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Test0301</span> <span class=\"variable\">test0301</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0301</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0301.sendMessage();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AAA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0301.call();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BBB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test0301</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendMessage&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendEmail</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendEmail&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;call&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">call</span><br><span class=\"line\">sendMessage</span><br><span class=\"line\"><span class=\"title function_\">call</span><span class=\"params\">()</span>为普通方法,不受同步方法的影响,不受锁的影响</span><br></pre></td></tr></table></figure>\n\n<p>4.两个资源，发短信、发邮件的打印顺序(先邮件后短信)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test04</span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Test0401</span> <span class=\"variable\">test0401</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0401</span>();</span><br><span class=\"line\">        <span class=\"type\">Test0401</span> <span class=\"variable\">test0402</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0401</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0401.sendMessage();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AAA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0402.sendEmail();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BBB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test0401</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendMessage&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendEmail</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;call&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">sendEmail</span><br><span class=\"line\">sendMessage</span><br><span class=\"line\">区别于问题<span class=\"number\">1</span>，该情况是 两个资源类对象分别开启两个线程，因此锁对象 并无互相干扰，因为线程延时的原因，打电话 先输出</span><br></pre></td></tr></table></figure>\n\n<p>5.两个同步方法变静态、一个资源，发短信、发邮件的打印顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test05</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Test0501</span> <span class=\"variable\">test0401</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0501</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0401.sendMessage();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AAA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0401.sendEmail();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BBB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test0501</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendMessage&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendEmail</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendEmail&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;call&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">sendMessage</span><br><span class=\"line\">sendEmail</span><br><span class=\"line\">加上<span class=\"keyword\">static</span>关键字之后，两个方法都变为静态方法。</span><br></pre></td></tr></table></figure>\n\n<p>6.两个静态同步方法、两个资源，发短信、发邮件的打印顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test06</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Test0601</span> <span class=\"variable\">test0601</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0601</span>();</span><br><span class=\"line\">        <span class=\"type\">Test0601</span> <span class=\"variable\">test0602</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0601</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0601.sendMessage();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AAA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0602.sendEmail();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BBB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test0601</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendMessage&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendEmail</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendEmail&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;call&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">sendMessage</span><br><span class=\"line\">sendEmail</span><br><span class=\"line\">原理同<span class=\"number\">5</span>，<span class=\"keyword\">synchronized</span> 加 静态方法 锁的是 Class</span><br></pre></td></tr></table></figure>\n\n<p>7.一个静态同步方法、一个普通同步方法、一个资源，发短信、发邮件的打印顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test07</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Test0701</span> <span class=\"variable\">test0701</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0701</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0701.sendMessage();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AAA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0701.sendEmail();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BBB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test0701</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendMessage&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendEmail</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendEmail&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;call&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">sendEmail</span><br><span class=\"line\">sendMessage</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> 锁的是 类实例即对象 、<span class=\"keyword\">synchronized</span> 加 静态方法 锁的是 Class</span><br></pre></td></tr></table></figure>\n\n<p>8.一个静态同步方法、一个普通同步方法、两个资源，发短信、发邮件的打印顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test08</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Test0801</span> <span class=\"variable\">test0801</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0801</span>();</span><br><span class=\"line\">        <span class=\"type\">Test0801</span> <span class=\"variable\">test0802</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test0801</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0801.sendMessage();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AAA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            test0802.sendEmail();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BBB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test0801</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendMessage&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendEmail</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sendEmail&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">call</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;call&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果:</span><br><span class=\"line\">sendEmail</span><br><span class=\"line\">sendMessage</span><br><span class=\"line\">原理同<span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n","categories":["java知识"],"tags":["java基础","Juc"]},{"title":"分布式面试","url":"/2022/06/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95/","content":"<h2 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h2><h3 id=\"1-什么是CAP理论\"><a href=\"#1-什么是CAP理论\" class=\"headerlink\" title=\"1.什么是CAP理论\"></a>1.什么是CAP理论</h3><blockquote>\n<p>CAP理论是分布式领域中非常重要的一个指导理论，C(Consistency)表示强一致性，A(Availability)表示可用性，P(Partition Tolerance)表示<br>分区容错性，CAP理论指出在目前的硬件条件下，一个分布式系统是必须要保证分区容错性的，而在这个前提下，分布式系统要么保证C，要么保证AP，无法同时保证CAP。</p>\n<p><strong>分区容错性</strong>表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布式系统内部的某个结点挂点，或网络出现了故障，而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性的。</p>\n<p><strong>强一致性</strong>表示，一个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的，不然就会造成数据不一致，所以强一致性和可用性是不能同时满足的。</p>\n<p><strong>可用性</strong>表示，一个分布式系统对外要保证可用。</p>\n</blockquote>\n<h3 id=\"2-什么是BASE理论\"><a href=\"#2-什么是BASE理论\" class=\"headerlink\" title=\"2.什么是BASE理论\"></a>2.什么是BASE理论</h3><blockquote>\n<p>由于不能同时满足CAP，所以出现了BASE理论:<br>1.BA: Basically Available，表示基本可用，表示可以允许一定程度的不可用，比如由于系统故障，请求时间变长，或者由于系统故障导致部分<br>非核心功能不可用，都是允许的</p>\n<p>2.S: Soft state:表示分布式系统可以处于一种中间状态，比如数据正在同步</p>\n<p>3.E:Eventually consistent，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后再达到一致，在达到一致过程中<br>系统也是可用的</p>\n</blockquote>\n<h3 id=\"3-什么是RPC\"><a href=\"#3-什么是RPC\" class=\"headerlink\" title=\"3.什么是RPC\"></a>3.什么是RPC</h3><blockquote>\n<h2 id=\"什么是-RPC-？\"><a href=\"#什么是-RPC-？\" class=\"headerlink\" title=\"什么是 RPC ？\"></a>什么是 RPC ？</h2><ul>\n<li>RPC (Remote Procedure Call)即<strong>远程过程调用</strong>，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。</li>\n<li>除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</li>\n<li>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。</li>\n</ul>\n<p><strong>简单的说</strong></p>\n<ul>\n<li>RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</li>\n<li>RPC会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）。</li>\n<li>客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</li>\n</ul>\n</blockquote>\n<h3 id=\"4-什么是分布式ID\"><a href=\"#4-什么是分布式ID\" class=\"headerlink\" title=\"4.什么是分布式ID\"></a>4.什么是分布式ID</h3><blockquote>\n<p>在分布式系统中，经常需要一些全局唯一的ID对数据、消息、http请求等进行唯一标识。那么这个全局唯一ID就叫分布式ID</p>\n</blockquote>\n<h3 id=\"5-为什么需要分布式ID\"><a href=\"#5-为什么需要分布式ID\" class=\"headerlink\" title=\"5.为什么需要分布式ID\"></a>5.为什么需要分布式ID</h3><blockquote>\n<p>1.如果id我们使用的是数据库的自增长类型，在分布式系统中需要分库和分表时，会有两个相同的表，有可能产生主键冲突。</p>\n<p>2.电商订单号，采用自增方式，是最简单的生成规则。但是！这种与流水号相同的订单号很容易就被竞争对手看出你公司真实的运营信息。</p>\n</blockquote>\n<h3 id=\"6-分布式ID解决方案\"><a href=\"#6-分布式ID解决方案\" class=\"headerlink\" title=\"6.分布式ID解决方案\"></a>6.分布式ID解决方案</h3><blockquote>\n<p>1.uuid，这种方案复杂度最低，但是会影响存储空间和性能</p>\n<p>⒉利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候此方案也不是最优方案</p>\n<p>3.利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库(mysql)相比，性能有所提高,可以适当选用</p>\n<p>4.雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证趋势递增。业界存在tinyid、 leaf等开源中间件实现了雪花算法</p>\n</blockquote>\n<h3 id=\"7-分布式锁的使用场景和实现方案\"><a href=\"#7-分布式锁的使用场景和实现方案\" class=\"headerlink\" title=\"7.分布式锁的使用场景和实现方案\"></a>7.分布式锁的使用场景和实现方案</h3><blockquote>\n<p>在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时，遇到资源竞争时，可以利用ReentrantLock、synchronized等技术来作为锁，来控制共享资源的使用。</p>\n<p>而在分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用ReentrantLock、synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，需要一个分布式锁生成器，分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁。</p>\n<p>目前主流的分布式锁的实现方案有两种:</p>\n<p>1.zookeeper:利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱</p>\n<p>2.redis:利用redis的setnw、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式锁可能不可靠，不稳定(一旦redis中的数据出现了不一致)，可能会出现多个客户端同时加到锁的情况</p>\n</blockquote>\n<h3 id=\"8-分布式事务和实现实现方案\"><a href=\"#8-分布式事务和实现实现方案\" class=\"headerlink\" title=\"8.分布式事务和实现实现方案\"></a>8.分布式事务和实现实现方案</h3><blockquote>\n<p>在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于一次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。常用解决方案有:</p>\n<p>1.本地消息表:创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统</p>\n<p>2.消息队列:目前RocketMQ中支持事务消息，它的工作原理是:</p>\n<p>a.生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的</p>\n<p>b.再创建订单，根据创建订单成功与否，向Broker发送commit或rollback</p>\n<p>c.并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功</p>\n<p>d.一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束</p>\n<p>e.如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理</p>\n<p>3.Seata:阿里开源的分布式事务框架，支持AT、TCC等多种模式，底层都是基于两阶段提交理论来实现的</p>\n</blockquote>\n<h3 id=\"9-简述zab协议\"><a href=\"#9-简述zab协议\" class=\"headerlink\" title=\"9.简述zab协议\"></a>9.简述zab协议</h3><blockquote>\n<p>ZAB协议（Zookeeper Atomic Broadcast原子广播）是Zookeeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段:</p>\n<p>1.领导者选举阶段:从Zookeeper集群中选出一个节点作为Leader，所有的写请求都会由Leader节点来处理</p>\n<p>⒉数据同步阶段:集群中所有节点中的数据要和Leader节点保持一致，如果不一致则要进行同步</p>\n<p>3.请求广播阶段:当Leader节点接收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致</p>\n<p>但值得注意的是，Zookeeper只是尽量的在达到强一致性，实际上仍然只是最终一致性的。</p>\n</blockquote>\n<h3 id=\"10-Spring-Cloud和Dubbo有哪些区别\"><a href=\"#10-Spring-Cloud和Dubbo有哪些区别\" class=\"headerlink\" title=\"10.Spring Cloud和Dubbo有哪些区别?\"></a>10.Spring Cloud和Dubbo有哪些区别?</h3><blockquote>\n<p>Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用间的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有SpringCloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来一起使用的。</p>\n</blockquote>\n<h3 id=\"11-什么是服务雪崩-什么是服务限流\"><a href=\"#11-什么是服务雪崩-什么是服务限流\" class=\"headerlink\" title=\"11.什么是服务雪崩?什么是服务限流?\"></a>11.什么是服务雪崩?什么是服务限流?</h3><blockquote>\n<p>1.当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗<br>不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。<br>2．服务限流是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求<br>压垮，在秒杀中，限流是非常重要的。</p>\n</blockquote>\n<h3 id=\"12-什么是服务熔断-什么是服务降级-区别是什么\"><a href=\"#12-什么是服务熔断-什么是服务降级-区别是什么\" class=\"headerlink\" title=\"12.什么是服务熔断?什么是服务降级?区别是什么?\"></a>12.什么是服务熔断?什么是服务降级?区别是什么?</h3><blockquote>\n<p>1.服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。</p>\n<p>2.服务降级是指，当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力，这就是服务降级。</p>\n<p>相同点:</p>\n<p>1．都是为了防止系统崩溃</p>\n<p>2．都让用户体验到某些功能暂时不可用</p>\n<p>不同点:熔断是下游服务故障触发的，降级是为了降低系统负载</p>\n</blockquote>\n","categories":["面试"],"tags":["面试","分布式"]},{"title":"泰拉瑞亚服务器搭建","url":"/2022/08/10/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","content":"<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">一、设置swap，防止内存不足</span><br><span class=\"line\">首先查看</span><br><span class=\"line\">free –m</span><br><span class=\"line\">可以看到swap分区是0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">1、删除原有的分区</span><br><span class=\"line\">swapoff -a</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2、新建分区</span><br><span class=\"line\">dd if=/dev/zero of=/root/swapfile bs=1M count=2048</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">3、格式化交换分区</span><br><span class=\"line\">mkswap /root/swapfile</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4、启动新建的swap交换分区</span><br><span class=\"line\">swapon /root/swapfile</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">5、添加开机启动</span><br><span class=\"line\">进入目录</span><br><span class=\"line\">vi /etc/fstab</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">按（英文下状态小写的）i进入编辑模式，到达文件底部添加内容</span><br><span class=\"line\">/root/swapfile swap swap defaults 0 0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">完毕后依次按键盘 Esc-键盘shift+:+输入wq保存/退出编辑好的文件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">6、使用命令重启服务器</span><br><span class=\"line\">reboot</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">……等待重启</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">7、检查</span><br><span class=\"line\">输入命令free –m</span><br><span class=\"line\">看Swap有了数值，表示成功添加。</span><br><span class=\"line\"></span><br><span class=\"line\">8、进入管理员权限</span><br><span class=\"line\">sudo su root</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">二、安装工具</span><br><span class=\"line\">1、下载工具</span><br><span class=\"line\"></span><br><span class=\"line\">yum romove wget</span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y wget</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2、解压工具</span><br><span class=\"line\">yum install -y unzip</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">3、压缩工具</span><br><span class=\"line\">yum install –y zip</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4、远程管理工具</span><br><span class=\"line\">yum install -y screen</span><br><span class=\"line\">看到Complete!表示完成</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">三、创建目录</span><br><span class=\"line\">1、创建父目录</span><br><span class=\"line\">mkdir /opt/terraria</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2、创建2个子目录,和存档目录</span><br><span class=\"line\">mkdir /opt/terraria/bin keyword zip</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">3、查看目录是否创建成功</span><br><span class=\"line\">ls /opt/terraria/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4、进入zip文件夹</span><br><span class=\"line\">cd /opt/terraria/zip</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">5、下载泰拉瑞亚服务器包（最新版本去官网寻找）</span><br><span class=\"line\">wget https://terraria.org/api/download/pc-dedicated-server/terraria-server-1436.zip</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">6、查看是否下载好terraria-server-1436.zip</span><br><span class=\"line\">ls</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">7、解压服务器包到bin文件夹</span><br><span class=\"line\">unzip terraria-server-1436.zip -d ../bin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">8、新建服务器的配置文件</span><br><span class=\"line\">vim ../server-config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">按（英文状态小写的）i进入编辑模式</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">world=/opt/terraria/keyword/存档名.wld</span><br><span class=\"line\">worldname=世界的名字</span><br><span class=\"line\">difficulty=0</span><br><span class=\"line\">autocreate=2</span><br><span class=\"line\">maxplayers=4</span><br><span class=\"line\">password=设定一个密码</span><br><span class=\"line\">worldpath=/opt/terraria/keyword</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">参数解释：</span><br><span class=\"line\">autocreate是地图大小1&lt;2&lt;3</span><br><span class=\"line\">difficulty是难度0为普通,1为专家</span><br><span class=\"line\">maxplayers 最大人数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">按esc-shift+:- wq保存退出</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">四、启动准备</span><br><span class=\"line\">1、放行7777端口</span><br><span class=\"line\">启动防火墙：systemctl start firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">firewall-cmd --permanent --add-port=7777/tcp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">1、给文件添加最高权限</span><br><span class=\"line\">chmod 777 /opt/terraria/bin/1432/Linux/TerrariaServer.bin.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2、进入启动目录</span><br><span class=\"line\">cd /opt/terraria/bin/1432/Linux</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">3、启动服务器使用自定义的配置文件</span><br><span class=\"line\">./TerrariaServer.bin.x86_64 -config /opt/terraria/server-config</span><br><span class=\"line\">等待加载……</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4、已经创建成功此时还差一步</span><br><span class=\"line\">先退出</span><br><span class=\"line\">exit</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">编辑之前的配置文件</span><br><span class=\"line\">vim /opt/terraria/server-config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">按（英文状态小写的）i进入编辑模式</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">分别给worldname=xx 每段前加#号</span><br><span class=\"line\">difficulty=xx</span><br><span class=\"line\">autocreate=xx</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">按esc-shift+:- wq保存退出</span><br><span class=\"line\">目的是让注释代码让其失效，不然每次重开服务器都会生成新世界</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">五、创建新会话来运行服务器</span><br><span class=\"line\">1、移动到服务器目录</span><br><span class=\"line\">cd /opt/terraria/1432/Linux</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2、创建新的screen会话，用于运行服务器</span><br><span class=\"line\">screen -S terrariaServer</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">3、启动服务器使用自定义的配置文件</span><br><span class=\"line\">./TerrariaServer.bin.x86_64 -config /opt/terraria/server-config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">创建好后,使用Ctrl+A+D退出会话，不会被关闭</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">停止服务器输入</span><br><span class=\"line\">exit</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">重新连接screen会话</span><br><span class=\"line\">screen -R terrariaServer</span><br></pre></td></tr></table></figure>\n\n\n\n\n","categories":["兴趣"],"tags":["Linux","游戏"]},{"title":"java7新特性之方法句柄","url":"/2022/07/10/%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84/","content":"<h1 id=\"方法句柄\"><a href=\"#方法句柄\" class=\"headerlink\" title=\"方法句柄\"></a>方法句柄</h1><p>JDK6之前我们会使用java反射来实现动态方法调用，多数框架用反射的比较多，例如mybatis、spring等。在JDK7中，新增了java.lang.invoke.MethodHandle（方法句柄），称之为“现代化反射”。其实反射和java.lang.invoke.MethodHandle都是间接调用方法的途径，但java.lang.invoke.MethodHandle比反射更简洁，用反射功能会写一大堆冗余代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">race</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Horse</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">race</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Horse.race()&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"comment\">// 利用接口抽象方法</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Horse</span>();</span><br><span class=\"line\">    animal.race();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 反射调用</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">Horse</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Horse</span>();</span><br><span class=\"line\">    <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> object.getClass().getMethod(<span class=\"string\">&quot;race&quot;</span>);</span><br><span class=\"line\">    method.invoke(object);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>MethodType用来描述方法的返回值类型以及入参类型。<br>MehodHandle包含一个指向Method对象（方法在jvm内部的对等体）的指针。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello,&quot;</span> + s + <span class=\"string\">&quot;MethodHandle&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"type\">Main</span> <span class=\"variable\">main</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Main</span>();</span><br><span class=\"line\">        <span class=\"type\">MethodHandle</span> <span class=\"variable\">mh</span> <span class=\"operator\">=</span> getToStringMH();</span><br><span class=\"line\">        System.out.println((String) mh.invokeExact(main, <span class=\"string\">&quot;ss&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MethodHandle <span class=\"title function_\">getToStringMH</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodType</span> <span class=\"variable\">mt</span> <span class=\"operator\">=</span> MethodType.methodType(String.class, String.class);  <span class=\"comment\">//获取方法类型 参数为:1.返回值类型,2方法中参数类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodHandle</span> <span class=\"variable\">mh</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mh = MethodHandles.lookup().findVirtual(Main.class, <span class=\"string\">&quot;toString&quot;</span>, mt);  <span class=\"comment\">//查找方法句柄</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException | IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mh;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法句柄是一个强类型的，能够被直接执行的引用。该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上等价于目标字段的 getter 或者 setter 方法。</p>\n<p>方法句柄的类型（MethodType）是由所指向方法的参数类型以及返回类型组成的。它是用来确认方法句柄是否适配的唯一关键。当使用方法句柄时，我们其实并不关心方法句柄所指向方法的类名或者方法名。</p>\n<p><strong>MethodHandle 的创建方式：</strong></p>\n<p>方式一、通过反射创建 MethodHandle（不符合初衷）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">race</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MethodHandles.Lookup <span class=\"title function_\">lookup</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MethodHandles.lookup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> Main.class.getDeclaredMethod(<span class=\"string\">&quot;race&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">MethodHandle</span> <span class=\"variable\">methodHandle</span> <span class=\"operator\">=</span> Main.lookup().unreflect(method);</span><br><span class=\"line\">        methodHandle.invoke();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出: hello</span><br></pre></td></tr></table></figure>\n\n<p>方式二、根据 MethodType 创建 MethodHandle</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">race</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;race&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;say&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MethodHandles.Lookup <span class=\"title function_\">lookup</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MethodHandles.lookup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        MethodHandles.<span class=\"type\">Lookup</span> <span class=\"variable\">lookup</span> <span class=\"operator\">=</span> Main.lookup();</span><br><span class=\"line\">        <span class=\"type\">MethodType</span> <span class=\"variable\">methodType</span> <span class=\"operator\">=</span> MethodType.methodType(<span class=\"keyword\">void</span>.class);</span><br><span class=\"line\">        <span class=\"type\">MethodHandle</span> <span class=\"variable\">methodHandle</span> <span class=\"operator\">=</span> lookup.findStatic(Main.class, <span class=\"string\">&quot;race&quot;</span>, methodType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodHandle</span> <span class=\"variable\">methodHandle2</span> <span class=\"operator\">=</span> lookup.findVirtual(Main.class, <span class=\"string\">&quot;say&quot;</span>, methodType);</span><br><span class=\"line\">        methodHandle.invoke();</span><br><span class=\"line\">        methodHandle2.invoke(<span class=\"keyword\">new</span> <span class=\"title class_\">Main</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出:</span><br><span class=\"line\">race</span><br><span class=\"line\">say</span><br></pre></td></tr></table></figure>\n\n<p>小结一下：</p>\n<p>1、<strong>方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于 Lookup 对象的创建位置。</strong></p>\n<p>2、如果 JDK 版本大于8，那么可以在其他类中，也能够通过该 Lookup 对象对类私有属性进行赋值、取值操作。</p>\n<h4 id=\"外类中操控私有字段\"><a href=\"#外类中操控私有字段\" class=\"headerlink\" title=\"外类中操控私有字段\"></a>外类中操控私有字段</h4><p>因为权限问题，外类中创建的 Lookup 对象无法操控私有字段，那么有什么替代方案呢？</p>\n<ul>\n<li>通过操控get和set方法</li>\n<li>反射</li>\n</ul>\n<p>关于invoke和invokeExtract方法的区别：</p>\n<blockquote>\n<p>invokeExtract要求更加精确，<br>如下 methodHandle2.invokeExact(test1,5.1,new Integer(1));可以执行，<br>methodHandle2.invokeExact(test1,5.1,1);会报错，因为要将1转换为integer，所以不合要求。这个方法要求不能有任何类型转换，也就是参数严格一致。<br>invoke相对要轻松很多。</p>\n</blockquote>\n<p>关键概念</p>\n<blockquote>\n<p>Lookup<br>MethodHandle 的创建工厂，通过它可以创建MethodHandle，值得注意的是检查工作是在创建时处理的，而不是在调用时处理。</p>\n<p>MethodType<br>顾名思义，就是代表方法的签名。一个方法的返回值类型是什么，有几个参数，每个参数的类型什么？</p>\n<p>MethodHandle<br>方法句柄，通过它我们就可以动态访问类型信息了。</p>\n</blockquote>\n<p>如何使用</p>\n<blockquote>\n<p>当理解了上面几个关键概念后使用起来就比较简单了，总的来说只需要4步：</p>\n<p>创建Lookup<br>创建MethodType<br>基于Lookup与MethodType获得MethodHandle<br>调用MethodHandle</p>\n</blockquote>\n","categories":["java知识"],"tags":["java基础","方法句柄， JVM"]},{"title":"消息队列面试","url":"/2022/06/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95/","content":"<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><h3 id=\"1-消息队列有哪些作用\"><a href=\"#1-消息队列有哪些作用\" class=\"headerlink\" title=\"1.消息队列有哪些作用\"></a>1.消息队列有哪些作用</h3><blockquote>\n<p>1．解耦:使用消息队列来作为两个系统直接的通讯方式，两个系统不需要相互依赖了</p>\n<p>2．异步:系统A给消费队列发送完消息之后，就可以继续做其他事情了</p>\n<p>3．流量削峰:如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，有消费者自己控制消费速度</p>\n</blockquote>\n<h3 id=\"2-死信队列和延迟队列是什么\"><a href=\"#2-死信队列和延迟队列是什么\" class=\"headerlink\" title=\"2.死信队列和延迟队列是什么\"></a>2.死信队列和延迟队列是什么</h3><blockquote>\n<p>1．死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试<br>2．延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单</p>\n</blockquote>\n<h4 id=\"3-Kafka的Pull和Push分别有什么优缺点\"><a href=\"#3-Kafka的Pull和Push分别有什么优缺点\" class=\"headerlink\" title=\"3.Kafka的Pull和Push分别有什么优缺点\"></a>3.Kafka的Pull和Push分别有什么优缺点</h4><blockquote>\n<ol>\n<li>pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制，根据自己的消息处理能力来进行控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空</li>\n<li>push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就得消费多少消息，所以可能会造成网络堵塞，消费者压力大等问题</li>\n</ol>\n</blockquote>\n<h3 id=\"4-Kafka为什么比RocketMQ的吞吐量要高\"><a href=\"#4-Kafka为什么比RocketMQ的吞吐量要高\" class=\"headerlink\" title=\"4.Kafka为什么比RocketMQ的吞吐量要高\"></a>4.Kafka为什么比RocketMQ的吞吐量要高</h3><blockquote>\n<p>Kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息并没有发送到Broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送给Broker。这种做法减少了网络io，从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了性能却降低了可靠性。</p>\n</blockquote>\n<h3 id=\"5-RocketMQ的底层实现原理\"><a href=\"#5-RocketMQ的底层实现原理\" class=\"headerlink\" title=\"5.RocketMQ的底层实现原理\"></a>5.RocketMQ的底层实现原理</h3><blockquote>\n<p>RocketMQ由NameServer集群、Producer集群、Consumer集群、Broker集群组成，消息生产和消费的大致原理如下:</p>\n<ul>\n<li>Broker在启动的时候向所有的NameServer注册，并保持长连接，每30s发送一次心跳</li>\n<li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li>\n<li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li>\n</ul>\n</blockquote>\n<h3 id=\"6-消息队列如何保证消息可靠传输\"><a href=\"#6-消息队列如何保证消息可靠传输\" class=\"headerlink\" title=\"6.消息队列如何保证消息可靠传输\"></a>6.消息队列如何保证消息可靠传输</h3><blockquote>\n<ol>\n<li>为了保证消息不多，也就是消息不能重复，也就是生产者不能重复生产消息，或者消费者不能重复消费消息</li>\n<li>首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制</li>\n<li>要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题</li>\n<li>消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面</li>\n<li>生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker</li>\n<li>broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就 是消费端ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到ack后才会删除消息</li>\n</ol>\n</blockquote>\n<h3 id=\"7-消息丢失怎么办\"><a href=\"#7-消息丢失怎么办\" class=\"headerlink\" title=\"7.消息丢失怎么办\"></a>7.消息丢失怎么办</h3><blockquote>\n<p>丢失我们从三个角度出发(以下是RabbitMQ案例 )</p>\n<h4 id=\"消费者丢数据\"><a href=\"#消费者丢数据\" class=\"headerlink\" title=\"消费者丢数据\"></a>消费者丢数据</h4><blockquote>\n<p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ <strong>事务channel.txSelect</strong>，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。</p>\n<p><strong>缺点:吞吐量减少</strong></p>\n<p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <strong>confirm</strong> 模式，在生产者那里设置开启 confirm 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>\n<p>事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm 机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p>\n<p><strong>所以一般在生产者这块避免数据丢失，都是用 confirm 机制的。</strong></p>\n</blockquote>\n<h4 id=\"消息队列丢数据\"><a href=\"#消息队列丢数据\" class=\"headerlink\" title=\"消息队列丢数据\"></a>消息队列丢数据</h4><blockquote>\n<p>就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。</p>\n</blockquote>\n<h4 id=\"消费端丢数据\"><a href=\"#消费端丢数据\" class=\"headerlink\" title=\"消费端丢数据\"></a>消费端丢数据</h4><blockquote>\n<p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p>\n<p>这个时候得用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p>\n</blockquote>\n<p><img src=\"https://pics3.baidu.com/feed/e1fe9925bc315c60668cdd22d3e7a31b48547744.jpeg?token=9ca5384b80f2f3bc315a49b06168b6d9\" alt=\"img\"></p>\n</blockquote>\n<h3 id=\"8-消息重复消费怎么办\"><a href=\"#8-消息重复消费怎么办\" class=\"headerlink\" title=\"8.消息重复消费怎么办?\"></a>8.消息重复消费怎么办?</h3><blockquote>\n<h4 id=\"重复消费出现场景（消费完后没有返回状态然后重启重新消费）\"><a href=\"#重复消费出现场景（消费完后没有返回状态然后重启重新消费）\" class=\"headerlink\" title=\"重复消费出现场景（消费完后没有返回状态然后重启重新消费）:\"></a>重复消费出现场景（消费完后没有返回状态然后重启重新消费）:</h4><blockquote>\n<p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p>\n<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p>\n<p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p>\n<p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。</p>\n<p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p>\n<p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p>\n<p><strong>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</strong></p>\n</blockquote>\n<h4 id=\"如何保证幂等性\"><a href=\"#如何保证幂等性\" class=\"headerlink\" title=\"如何保证幂等性\"></a>如何保证幂等性</h4><blockquote>\n<ul>\n<li>数据库实现主键唯一</li>\n<li>redis天然幂等性</li>\n<li>唯一键和redis结合</li>\n</ul>\n</blockquote>\n</blockquote>\n","categories":["面试"],"tags":["面试","消息队列"]},{"title":"自动拆箱和装箱原理","url":"/2022/08/08/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1%E5%8E%9F%E7%90%86/","content":"<p>自动装箱和自动拆箱是两个相反的过程，自动装箱即将基本数据类型转换为对应的封装类，自动拆箱即将封装类转换为对应的基本数据类型。此外，<strong>装箱的过程会增加内存的消耗，影响性能，因为这个过程会创建对应的对象。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210112100512319.png?x-oss-process=image#pic_center/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTQyNzEyOQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">integerNum</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>; <span class=\"comment\">// 进行自动装箱，得到的是封装类</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">intNum</span> <span class=\"operator\">=</span> integerNum; <span class=\"comment\">// 进行自动拆箱，得到基本数据类型</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>javap -c Main.class</code> 查看生成的字节码文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">&quot;Main.java&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">club</span>.wadreamer.test.Main &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> club.wadreamer.test.Main();</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(java.lang.String[])</span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: bipush        <span class=\"number\">100</span></span><br><span class=\"line\">       <span class=\"number\">2</span>: invokestatic  #<span class=\"number\">2</span>                  <span class=\"comment\">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class=\"line\">       <span class=\"number\">5</span>: astore_1</span><br><span class=\"line\">       <span class=\"number\">6</span>: aload_1</span><br><span class=\"line\">       <span class=\"number\">7</span>: invokevirtual #<span class=\"number\">3</span>                  <span class=\"comment\">// Method java/lang/Integer.intValue:()I</span></span><br><span class=\"line\">      <span class=\"number\">10</span>: istore_2</span><br><span class=\"line\">      <span class=\"number\">11</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>Integer#valueOf()</code> 和 <code>Integer#intValue()</code> 的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动装箱</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自动拆箱</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">intValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>从上述字节码可以得出如下结论：</p>\n<ul>\n<li>在进行自动装箱时，Java 虚拟机会自动调用 Integer#valueOf()。</li>\n<li>在进行自动拆箱时，Java 虚拟机会自动调用 Integer#intValue()。</li>\n<li>其他数据类型的自动装箱和自动拆箱的过程和 Integer 类似，都是调用类似 xxxValue()、valueOf() 等方法。</li>\n</ul>\n<h4 id=\"其他案例分析\"><a href=\"#其他案例分析\" class=\"headerlink\" title=\"其他案例分析\"></a>其他案例分析</h4><h5 id=\"1-空指针异常\"><a href=\"#1-空指针异常\" class=\"headerlink\" title=\"1.空指针异常\"></a>1.空指针异常</h5><blockquote>\n<p>包装类为空，拆箱时异常</p>\n</blockquote>\n<h5 id=\"2-equals和-问题\"><a href=\"#2-equals和-问题\" class=\"headerlink\" title=\"2.equals和==问题\"></a>2.equals和==问题</h5><blockquote>\n<p>两个包装类用==，比较的是地址</p>\n<p>两个包装类用equals，比较的是值</p>\n<p>一个包装类和一个基本数据类型用equals，比较的是值</p>\n<p>一个包装类和一个基本数据类型用==，比较的是值（会自动拆包）</p>\n<p>两个基本数据类型用==比较的是值</p>\n</blockquote>\n<h5 id=\"3-拆箱的缓存机制\"><a href=\"#3-拆箱的缓存机制\" class=\"headerlink\" title=\"3.拆箱的缓存机制\"></a>3.拆箱的缓存机制</h5><blockquote>\n<p><strong>对于 Integer</strong>，在 [-128, 127] 之间只有固定的 256 个值，所以为了避免多次创建对象，事先创建好一个大小为 256 的 Integer 数组 cache，所以如果值在这个范围内，就可以直接返回我们事先创建好的对象即可。</p>\n<p><strong>对于 Double 类型来说</strong>，我们就不能这样做，因为它在这个范围内个数是无限的。 总结一句就是：在某个范围内的整型数值的个数是有限的，而浮点数却不是。所以在 Double 里面的做法很直接，就是直接创建一个对象，所以每次创建的对象都不一样。</p>\n<p>对于 Boolean 类型来说，在内部已经提前创建好两个对象，因为它只有两种情况，这样也是为了避免重复创建太多的对象。因此，每次执行 Boolean#valueOf() 返回的都是相同的对象。</p>\n</blockquote>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h4><ul>\n<li>存在拆箱操作时一定要特别注意封装类对象是否为 null。</li>\n<li>包装类和基本数据类型在进行== 运算和算数运算时，会进行自动拆箱。</li>\n<li>equals() 会进行<strong>自动装箱操作</strong>，且需要先判断封装类的类型是否相同，再进一步判断内容是否相同。（==是优先比较基本数据类型，是<strong>拆箱操作</strong>）</li>\n<li>Integer、Short、Byte、Character、Long 这几个类的 valueOf() 的实现是类似的，均在存在 [-128, 127] 的缓存。</li>\n<li>Double、Float 的 valueOf() 的实现是类似的，每次都返回不同的对象。</li>\n<li>Boolean 预先创建了两个对象，Boolean#valueOf() 每次返回的都是相同的对象。</li>\n</ul>\n","categories":["java知识"],"tags":["面试","Java"]},{"title":"计算机网络面试","url":"/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/","content":"<h2 id=\"计算机网络相关\"><a href=\"#计算机网络相关\" class=\"headerlink\" title=\"计算机网络相关\"></a>计算机网络相关</h2><h3 id=\"1-get和post的区别\"><a href=\"#1-get和post的区别\" class=\"headerlink\" title=\"1.get和post的区别\"></a>1.get和post的区别</h3><blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">GET</th>\n<th>POST</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">后退按钮/刷新</td>\n<td align=\"left\">无害</td>\n<td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>\n</tr>\n<tr>\n<td align=\"left\">书签</td>\n<td align=\"left\">可收藏为书签</td>\n<td>不可收藏为书签</td>\n</tr>\n<tr>\n<td align=\"left\">缓存</td>\n<td align=\"left\">能被缓存</td>\n<td>不能缓存</td>\n</tr>\n<tr>\n<td align=\"left\">编码类型</td>\n<td align=\"left\">application/x-www-form-urlencoded</td>\n<td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>\n</tr>\n<tr>\n<td align=\"left\">历史</td>\n<td align=\"left\">参数保留在浏览器历史中。</td>\n<td>参数不会保存在浏览器历史中。</td>\n</tr>\n<tr>\n<td align=\"left\">对数据长度的限制</td>\n<td align=\"left\">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>\n<td>无限制。</td>\n</tr>\n<tr>\n<td align=\"left\">对数据类型的限制</td>\n<td align=\"left\">只允许 ASCII 字符。</td>\n<td>没有限制。也允许二进制数据。</td>\n</tr>\n<tr>\n<td align=\"left\">安全性</td>\n<td align=\"left\">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td>\n<td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>\n</tr>\n<tr>\n<td align=\"left\">可见性</td>\n<td align=\"left\">数据在 URL 中对所有人都是可见的。</td>\n<td>数据不会显示在 URL 中。</td>\n</tr>\n</tbody></table>\n<p>从标准上来看，GET 和 POST 的区别如下：</p>\n<p>GET 用于获取信息，是无副作用的，是幂等的，且可缓存 POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存</p>\n</blockquote>\n<h3 id=\"2-http和https的区别\"><a href=\"#2-http和https的区别\" class=\"headerlink\" title=\"2.http和https的区别\"></a>2.http和https的区别</h3><blockquote>\n<p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p>\n<p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>\n<p>HTTPS和HTTP的区别主要如下：</p>\n<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>\n<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>\n<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>\n<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>\n</blockquote>\n<h3 id=\"3-TCP和udp的区别\"><a href=\"#3-TCP和udp的区别\" class=\"headerlink\" title=\"3.TCP和udp的区别\"></a>3.TCP和udp的区别</h3><blockquote>\n<ul>\n<li>TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接</li>\n<li>TCP要求的系统资源较多，UDP较少</li>\n<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付</li>\n<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的</li>\n<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>\n<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</li>\n<li>TCP首部开销20字节；UDP的首部开销小，只有8个字节</li>\n<li>TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道</li>\n</ul>\n</blockquote>\n<h3 id=\"4-说说浏览器输入网址到返回页面的过程？\"><a href=\"#4-说说浏览器输入网址到返回页面的过程？\" class=\"headerlink\" title=\"4.说说浏览器输入网址到返回页面的过程？\"></a>4.说说浏览器输入网址到返回页面的过程？</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">基础版本：</span><br><span class=\"line\">浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP ，向服务器发起请求；</span><br><span class=\"line\">服务器交给后台处理完成后返回数据，浏览器接收⽂件（ HTML、JS、CSS 、图象等）；</span><br><span class=\"line\">浏览器对加载到的资源（ HTML、JS、CSS 等）进⾏语法解析，建立相应的内部数据结构 （如 HTML 的 DOM）；</span><br><span class=\"line\">载⼊解析到的资源⽂件，渲染页面，完成。</span><br></pre></td></tr></table></figure>\n\n<p>1、用户在输入栏输入地址</p>\n<p>　　(1) 如果有 beforeunload 事件会先执行判断继续还是跳出操作</p>\n<p>　　(2) 浏览器进程识别是 地址还是关键字检索</p>\n<p>　　(3) 将正确的 url 地址发送给网络进程</p>\n<p>2、网络进程查看有没有缓存</p>\n<p>　　(1) 有缓存直接返回数据</p>\n<p>　　(2) 没有缓存直接进入网络进程请求流程</p>\n<p>3、浏览器进程查询 DNS 获取服务器 ip 地址</p>\n<p>　　(1) 如果请求协议是 https 那么还需要建立TLS连接</p>\n<p>　　(2) 利用ip地址和服务器建立 tcp 连接</p>\n<p>　　(3) 如果浏览器的 tcp 连接请求有超过浏览器设定限额，则需要排队等待</p>\n<p>4、tcp 连接协议通过与服务器进行3次握手确立连接</p>\n<p>　　(1) 浏览器即用户端发起第一次握手</p>\n<p>　　(2) 服务器接收到用户端的消息发起接收到信息</p>\n<p>　　(3) 用户端接收到信息后向服务器发起第三次握手表示已经接收到信息可以连接 </p>\n<p>　　(4) 如果第二次握手发送数据包丢失或者用户端发起第三次握手数据包丢失，服务器在长时间未接收到信息会再次发起，总共会尝试6次</p>\n<p>5、tcp 接受信息</p>\n<p>6、网络进程接收到数据后将返回头和返回体发送给浏览器</p>\n<p>7、浏览器进程读取返回头查看返回信息，是否重定向或者响应数据类型处理</p>\n<p>　　(1) 重定向即回到第3步</p>\n<p>　　(2) 会根据 Content-Type 的值来决定如何显示响应体的内容。</p>\n<p>　　(3) Content-Type 为下载类型就会把请求交给浏览器的下载管理器，导航结束</p>\n<p>　　(4) 如果是 HTML，那么浏览器则会继续进行导航流程</p>\n<p>8、准备渲染进程</p>\n<p>9、浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息</p>\n<p>10、渲染进程就和网络进程直接建立连接进行管道数据传输</p>\n<p>11、数据传输完成后tcp发起4次挥手断开连接并且渲染进程同时向浏览器进程发起确认提交</p>\n<p>12、浏览器进程收到确认提交后会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态。</p>\n<p>13、渲染进程开始页面解析和子资源加载</p>\n<h3 id=\"相关的题目\"><a href=\"#相关的题目\" class=\"headerlink\" title=\"相关的题目\"></a>相关的题目</h3><h3 id=\"浏览器发出一个请求到收到响应经历了哪些步骤\"><a href=\"#浏览器发出一个请求到收到响应经历了哪些步骤\" class=\"headerlink\" title=\"浏览器发出一个请求到收到响应经历了哪些步骤?\"></a>浏览器发出一个请求到收到响应经历了哪些步骤?</h3><figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.浏览器解析用户输入的URL，生成一个HTTP格式的请求</span><br><span class=\"line\">⒉先根据URL域名从本地hosts文件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址                               3.浏览器通过操作系统将请求通过四层网络协议发送出去</span><br><span class=\"line\">4.途中可能会经过各种路由器、交换机，最终到达服务器</span><br><span class=\"line\">5.服务器搜到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了                                         6.tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet</span><br><span class=\"line\">7.然后servlet来处理这个请求，如果是SpringMVC中的DispatcherSservlet，那么则会找到对应的Controller中的方法，并执行该方法得到结果             8.Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器</span><br><span class=\"line\">9.浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"5-cookie做什么的？session又是什么？它们直接的关系？\"><a href=\"#5-cookie做什么的？session又是什么？它们直接的关系？\" class=\"headerlink\" title=\"5.cookie做什么的？session又是什么？它们直接的关系？\"></a>5.cookie做什么的？session又是什么？它们直接的关系？</h3><blockquote>\n<p>什么是Cookie？<br>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。</p>\n<p>当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。<br>信息保存的时间可以根据需要设置.</p>\n<p><strong>如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止.<br>如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期.</strong></p>\n<p><strong>Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据.</strong></p>\n<p><strong>由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,</strong><br><strong>因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性</strong></p>\n<p>什么是Session？<br>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>\n<p>每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。</p>\n<p>Session和Cookie的区别？</p>\n<p>1、数据存储位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>\n<p>2、安全性：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p>\n<p>3、服务器性能：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</p>\n<p>4、数据大小：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>\n<p>5、信息重要程度：可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</p>\n</blockquote>\n<h3 id=\"6-跨域请求是什么-有什么问题-怎么解决\"><a href=\"#6-跨域请求是什么-有什么问题-怎么解决\" class=\"headerlink\" title=\"6.跨域请求是什么?有什么问题?怎么解决?\"></a>6.跨域请求是什么?有什么问题?怎么解决?</h3><blockquote>\n<p>跨域是指浏览器在发起网络请求时，会检查该请求所对应的协议、域名、端口和当前网页是否一致，如果不一致则浏览器会进行限制，比如在<br><a href=\"http://www.baidu.com的某个网页中,如果使用ajax去访问www.jd.com是不行的,但是如果是img、iframe、scipt等标签的sc属性去访问则是可以的,之所以浏览器要做这层限制,是为了用户信息安全.但是如果开发者想要绕过这层限制也是可以的/\">www.baidu.com的某个网页中，如果使用ajax去访问www.jd.com是不行的，但是如果是img、iframe、scipt等标签的sc属性去访问则是可以的，之所以浏览器要做这层限制，是为了用户信息安全。但是如果开发者想要绕过这层限制也是可以的</a>:</p>\n<p>1.response添加header，比如resp.setHeader(“Access-Control-Allow-Origin”*);表示可以访问所有网站，不受是否同源的限制                                            </p>\n<p>2.jsonp的方式，该技术底层就是基于script标签来实现的，因为script标签是可以跨域的</p>\n<p>3.后台自己控制，先访问同域名下的接口，然后在接口中再去使用HTTPClient等工具去调用目标接口                                                                                  </p>\n<p>4.网关，和第三种方式类似，都是交给后台服务来进行跨域访问</p>\n</blockquote>\n<h3 id=\"7-Netty是什么？和Tomcat有什么区别？特点是什么？\"><a href=\"#7-Netty是什么？和Tomcat有什么区别？特点是什么？\" class=\"headerlink\" title=\"7.Netty是什么？和Tomcat有什么区别？特点是什么？\"></a>7.Netty是什么？和Tomcat有什么区别？特点是什么？</h3><blockquote>\n<p>Netty是一个基于NIO的异步网络通信框架，性能高，封装了原生NIO编码的复杂度，开发者可以直接使用Netty来开发高效率的各种网络服务器，并且编码简单。<br>Tomcat是一个Web服务器，是一个Servlet容器，基本上Tomcat内部只会运行Servlet程序，并处理HTTP请求，而Netty封装的是底层IO模型，关注的是网络数据的传输，而不关心具体的协议，可定制性更高。</p>\n<p>Netty的特点:</p>\n<ul>\n<li>异步、NIO的网络通信框架</li>\n<li>高性能</li>\n<li>高扩展，高定制性</li>\n<li>易用性</li>\n</ul>\n</blockquote>\n<h3 id=\"8-TCP的三次握手和四次挥手过程\"><a href=\"#8-TCP的三次握手和四次挥手过程\" class=\"headerlink\" title=\"8.TCP的三次握手和四次挥手过程\"></a>8.TCP的三次握手和四次挥手过程</h3><blockquote>\n<p>TCP协议是7层网络协议中的传输层协议，负责数据的可靠传输。在建立TCP连接时，需要通过三次握手来建立，过程是:</p>\n<ol>\n<li>客户端向服务端发送一个SYN</li>\n<li>服务端接收到SYN后，给客户端发送一个SYN_ACK</li>\n<li>客户端接收到SYN_ACK后，再给服务端发送一个ACK</li>\n</ol>\n<p>在断开TCP连接时，需要通过四次挥手来断开，过程是:</p>\n<ol>\n<li>客户端向服务端发送FIN</li>\n<li>服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还<br>有数据正在处理</li>\n<li>服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接</li>\n<li>客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了</li>\n</ol>\n<p><code>SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。</code></p>\n</blockquote>\n<h3 id=\"9-大文件上传如何做断点续传？\"><a href=\"#9-大文件上传如何做断点续传？\" class=\"headerlink\" title=\"9.大文件上传如何做断点续传？\"></a>9.大文件上传如何做断点续传？</h3><blockquote>\n<p>不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂</p>\n<p>文件上传简单，文件变大就复杂</p>\n<p>上传大文件时，以下几个变量会影响我们的用户体验</p>\n<ul>\n<li><p>服务器处理数据的能力</p>\n</li>\n<li><p>请求超时</p>\n</li>\n<li><p>网络波动</p>\n</li>\n<li><p>上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等</p>\n</li>\n</ul>\n<p>为了解决上述问题，我们需要对大文件上传单独处理</p>\n<p>这里涉及到<strong>分片上传</strong>及<strong>断点续传</strong>两个概念分片上传</p>\n<h3 id=\"分片上传\"><a href=\"#分片上传\" class=\"headerlink\" title=\"分片上传\"></a>分片上传</h3><p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传</p>\n<p>如下图</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e3e06808eb489dd3e6fb737f968196ef.png\" alt=\"img\"></p>\n<p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p>\n<p>大致流程如下：</p>\n<p>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</p>\n<p>初始化一个分片上传任务，返回本次分片上传唯一标识；</p>\n<p>按照一定的策略（串行或并行）发送各个分片数据块；</p>\n<p>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</p>\n<h3 id=\"断点续传\"><a href=\"#断点续传\" class=\"headerlink\" title=\"断点续传\"></a>断点续传</h3><p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p>\n<p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传或下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p>\n<p><strong>一般实现方式有两种：</strong></p>\n<p><strong>服务器端返回，告知从哪开始</strong></p>\n<p><strong>浏览器端自行处理</strong></p>\n<p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p>\n<p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可<br><img src=\"https://img-blog.csdnimg.cn/img_convert/2fca1391b4a9ae80c164ab5d88492c86.png\" alt=\"img\"></p>\n</blockquote>\n","categories":["面试"],"tags":["面试","计算机网络"]}]