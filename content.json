{"meta":{"title":"滚~韬的博客","subtitle":"滚~","description":"一个普通大学生的博客","author":"滚~韬","url":"https://gwtt.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-06-11T02:24:29.000Z","updated":"2022-06-11T02:34:49.842Z","comments":true,"path":"category/index.html","permalink":"https://gwtt.github.io/category/index.html","excerpt":"","text":""},{"title":"关于这个博客","date":"2022-06-11T02:34:12.102Z","updated":"2022-06-11T02:34:12.102Z","comments":true,"path":"about/index.html","permalink":"https://gwtt.github.io/about/index.html","excerpt":"","text":"​ 自我高二学习C#以来，到了大二才开始创建自己的博客，也可能是分手的缘故，让我重新开始审视自己。我学习代码已有5年了，遗憾的是，已经不再是抱着做游戏心态去学习代码，而是为了现实学习后端。加油吧。"},{"title":"标签","date":"2022-06-11T02:24:27.000Z","updated":"2022-06-11T02:35:07.018Z","comments":true,"path":"tag/index.html","permalink":"https://gwtt.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Git面试","slug":"Git面试","date":"2022-07-02T09:55:45.230Z","updated":"2022-07-02T10:09:08.769Z","comments":true,"path":"2022/07/02/Git面试/","link":"","permalink":"https://gwtt.github.io/2022/07/02/Git%E9%9D%A2%E8%AF%95/","excerpt":"","text":"Git1.什么是git? git是一个常用的分布式版本管理工具。 2.git常用的命令 git add 添加文件到暂存区 git commit 提交文件到本地仓库 git pull 从远程仓库拉取项目到本地 git push 将本地仓库的新的改变推送到远程仓库 git clone 将远程仓库复制到本地 git fetch 抓取 git merge 合并 3.git pull、git merge、git fetch三个命令的区别？ git clone：是在本地没有版本库的情况下，从远程仓库克隆一份到本地，是一个本地版本库从无到有的过程 git pull：是在本地仓库已经存在的情况下，将远程最新的commits抓取并合并到本地版本库的过程 git fetch： 从远程版本库抓取最新的commits，不会进行合并 git merge：合并 所以git pull = git fetch + git merge 4.push之前一定要进行哪个操作？ push之前一定要进行本地更新操作。使用git pull命令或者使用git fetch和git merge的命令组合。这时候，可能会出现版本冲突，如果出现的话，需要解决完冲突再进行代码push。 5.如何解决版本冲突 版本冲突多出现在合并操作(合并远程仓库代码或者合并分支代码)中。如果出现版本冲突，需要具体分析出现冲突的代码区，手动进行代码合并，然后再进行提交。 6.别人在远程推送的新分支怎么合并在自己上面 假设别人分支是A，我是B git checkouu B;//到自己分区 git merge A;//合并分支 git push;//提交","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://gwtt.github.io/tags/Git/"},{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Springboot面试(2)","slug":"Springboot面试(2)","date":"2022-07-02T09:31:37.501Z","updated":"2022-07-02T10:22:35.985Z","comments":true,"path":"2022/07/02/Springboot面试(2)/","link":"","permalink":"https://gwtt.github.io/2022/07/02/Springboot%E9%9D%A2%E8%AF%95(2)/","excerpt":"","text":"springboot(2)1.Spring boot的核心配置文件是什么 Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。 bootstrap 配置文件是系统级别的，用来加载外部配置，如配置中心的配置信息，也可以用来定义系统不会变化的属性.bootstatp 文件的加载先于application文件application 配置文件是应用级别的，是当前应用的配置文件 2.如何使用jwt进行登录校验 （1）客户端登录成功后（必须是在登陆成功才行，与session一样的前提条件），服务器会根据用户名和签名以及其他信息加密生成唯一的token串，用来区分他们，不需要存入服务端的缓存中，但会把这个token返回给相应的主机， （2）主机收到token后会存入cookie或者localStorage中，以后主机的每一次发送其他类型的请求的操作都会携带这个token， （3）服务器会将客户端发来的这个token和服务端从数据库查询出来的并且重新计算得到的用户信息进行对比，如果匹配，则认证成功，如果用户请求的资源需要相应的权限，则校验token中的payload中存储的权限等相关信息，如果有权限则返回给对应主机所需要的资源（即做到了权限鉴权），否则拒绝 用的依赖是java-jwt，用的包是auth0.jwt 3.生成的token在服务端有哪些存储方案 （1）保存在redis，最常用，也是分布式下的验证token的解决方案， （2）数据库存储，性能比redis稍差，速度稍慢 （3）不做保存，下次验证的时候直接用jwt.decode验证(服务端为express)，存储的压力给到了客户端，但是每次从客户端传到服务器端的数据量会稍微大一些","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Springboot","slug":"Springboot","permalink":"https://gwtt.github.io/tags/Springboot/"}]},{"title":"Juc面试(2)","slug":"Juc面试(2)","date":"2022-07-02T07:35:00.409Z","updated":"2022-07-02T09:01:03.491Z","comments":true,"path":"2022/07/02/Juc面试(2)/","link":"","permalink":"https://gwtt.github.io/2022/07/02/Juc%E9%9D%A2%E8%AF%95(2)/","excerpt":"","text":"juc(2)1.线程的生命周期 线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 新建：就是刚使用new方法，new出来的线程； 就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行; 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能; 阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态; 销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源; 那么处于Running状态的线程能发生哪些状态转变？ 被转换成Terminated状态，比如调用 stop() 方法; 被转换成Blocked状态，比如调用了sleep, wait 方法被加入 waitSet 中； 被转换成Blocked状态，如进行 IO 阻塞操作，如查询数据库进入阻塞状态； 被转换成Blocked状态，比如获取某个锁的释放，而被加入该锁的阻塞队列中； 该线程的时间片用完，CPU 再次调度，进入Runnable状态； 线程主动调用 yield 方法，让出 CPU 资源，进入Runnable状态 Blocked状态的线程能够发生哪些状态改变？ 被转换成Terminated状态，比如调用 stop() 方法，或者是 JVM 意外 Crash; 被转换成Runnable状态，阻塞时间结束，比如读取到了数据库的数据后； 完成了指定时间的休眠，进入到Runnable状态； 正在wait中的线程，被其他线程调用notify/notifyAll方法唤醒，进入到Runnable状态； 线程获取到了想要的锁资源，进入Runnable状态； 线程在阻塞状态下被打断，如其他线程调用了interrupt方法，进入到Runnable状态； 哪些情况进入终止状态 线程正常运行结束，生命周期结束； 线程运行过程中出现意外错误； JVM 异常结束，所有的线程生命周期均被结束。 2.死锁问题 什么是死锁死锁就是有两个或者多个进程由于竞争资源而造成阻塞的现象，如果无外力作用，这种局面就会一直持续下去 死锁产生的条件死锁产生必须满足四个必要条件： 1、互斥条件：指在一段时间内某资源只能由一个进程占用。 1只有一副钥匙 2、请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，且对自己已获得的其它资源保持不放。 1拿着红钥匙的人在没有归还红钥匙的情况下，又索要蓝钥匙 3、不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 1只要人不主动归还钥匙，就可以一直占着钥匙 4、环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链。即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 1拿着红钥匙的人在等待蓝钥匙，而拿着蓝钥匙的人又在等待红钥匙 如何避免死锁 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件） 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件） 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件） 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件） 编程中的最佳实践： 使用 Lock 的 tryLock(long timeout, TimeUnit unit)的方法，设置超时时间，超时可以退出防止死锁 尽量使用并发工具类代替加锁 尽量降低锁的使用粒度 尽量减少同步的代码块 死锁检测工具（了解）1、Jstack命令 jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 2、JConsole工具 Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。 3.单例模式 单例模式含义单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。 单例模式主要解决的问题是一个全局使用的类，不会被频繁的创建和销毁，从而提升代码的整体性能。 如何创建单例模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354饿汉式优点：简单，线程安全缺点：不管有没有使用都会占据空间public class HungrySingleton &#123; private static final HungrySingleton SINGLETON = new HungrySingleton(); /** * 单例模式有一个特点，不允许外部直接创建对象，私有构造不让外部实例化 */ private HungrySingleton() &#123;&#125; public static HungrySingleton getInstance() &#123; return SINGLETON; &#125;&#125;懒汉式优点: 简单缺点: 线程不安全，要加锁才能解决public class LazySingleton &#123; private static LazySingleton singleton; private LazySingleton()&#123;&#125; public static LazySingleton getInstance()&#123; if(singleton == null)&#123; return new LazySingleton(); &#125; return singleton; &#125;&#125;加锁后的public static LazySingleton getInstance() &#123; if (singleton == null) &#123; synchronized (LazySingleton.class) &#123; if (singleton == null) &#123; return new LazySingleton(); &#125; &#125; &#125; return singleton;&#125;枚举（推荐）优点：线程安全，防止反射和反序列化public enum EnumSingleton &#123; INSTANCE; public EnumSingleton getInstance()&#123; return INSTANCE; &#125;&#125; 在单例里面定义一个全局变量或者类变量的，它线程安全的还是线程不安全的结论:有写操作的话都是线程不安全的 静态变量即类变量，只初始化一次，位于方法区，为所有对象共享，共享一份内存，一旦静态变量被修改，其他对象均对修改可见，故线程非安全。 全局变量即实例成员变量。如果线程只是读取变量的值，而不会改变变量的值，则无论是单例还是非单例都是线程安全的；如果有修改变量值的操作，则单例模式因为只有一个对象实例singleton存在，多线程同时操作时是不安全的，而非单例模式下多线程操作是安全的。","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"juc","slug":"juc","permalink":"https://gwtt.github.io/tags/juc/"}]},{"title":"Java面试基础（2）","slug":"Java面试基础(2)","date":"2022-07-02T06:37:00.000Z","updated":"2022-07-02T09:31:31.704Z","comments":true,"path":"2022/07/02/Java面试基础(2)/","link":"","permalink":"https://gwtt.github.io/2022/07/02/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(2)/","excerpt":"","text":"java基础(2)1..java你用过的jdk版本 jdk1.8或者jdk11 关键问: 你知道jdk1.8相较于1.7有什么新特性吗 新增Lambda表达式 ：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 新增Stream API:对容器功能加强，可以对容器进行高效操作 新增方法引用:通过方法的名字来指向一个方法，用:: 新增Optional类:解决空指针异常 新增default:接口可以有具体方法 新增日期API (接下来可能会问Lambda表达式和StreamAPI) 你知道jdk11有什么新特性吗 新增本地类型推断:用var直接定义变量，编译器能自动推断类型 Optianal类增强，可以转换成流使用 字符类增加一些功能API 2.用过final关键字吗？它有什么作用 final关键字表示不可变，它可以修饰在类、方法、成员变量中。 如果修饰在类上，则表示该类不允许被继承 修饰在方法上，表示该方法无法被重写 修饰在变量上，表示该变量无法被修改，而且JVM会隐性定义为一个常量。(但是可以通过反射去破坏，但是反射无法修改被final和static同时修饰的变量) 另外，final修饰的关键字，还可以避免因为指令重排序带来的可见性问题，原因是，final遵循两个重排序规则 构造函数内，对一个 final 变量的写入，与随后把这个被构造对象的引用赋值给一个变量，这两个操作之间不可重排序。 首次读一个包含 final 变量的对象，与随后首次读这个 final 变量，这两个操作之间不可以重排序。 3.反射知道吗 通过反射可以获取到一些什么东西 反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。 ① 通过反射获取类中的属性和属性值 ② 通过反射获取反射类中的构造方法 ③ 通过反射获取反射类的父类（超类）和接口 ④通过反射获取反射类的方法","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"java基础","slug":"java基础","permalink":"https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"消息队列面试","slug":"消息队列面试","date":"2022-06-12T15:15:44.249Z","updated":"2022-06-29T12:09:33.297Z","comments":true,"path":"2022/06/12/消息队列面试/","link":"","permalink":"https://gwtt.github.io/2022/06/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95/","excerpt":"","text":"消息队列1.消息队列有哪些作用 1．解耦:使用消息队列来作为两个系统直接的通讯方式，两个系统不需要相互依赖了 2．异步:系统A给消费队列发送完消息之后，就可以继续做其他事情了 3．流量削峰:如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，有消费者自己控制消费速度 2.死信队列和延迟队列是什么 1．死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试2．延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务，比如十分钟内未支付则取消订单 3.Kafka的Pull和Push分别有什么优缺点 pull表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制，根据自己的消息处理能力来进行控制，但是消费者不能及时知道是否有消息，可能会拉到的消息为空 push表示Broker主动给消费者推送消息，所以肯定是有消息时才会推送，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就得消费多少消息，所以可能会造成网络堵塞，消费者压力大等问题 4.Kafka为什么比RocketMQ的吞吐量要高 Kafka的生产者采用的是异步发送消息机制，当发送一条消息时，消息并没有发送到Broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到一定数量时再批量发送给Broker。这种做法减少了网络io，从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致消息丢失，业务出错，所以理论上kafka利用此机制提高了性能却降低了可靠性。 5.RocketMQ的底层实现原理 RocketMQ由NameServer集群、Producer集群、Consumer集群、Broker集群组成，消息生产和消费的大致原理如下: Broker在启动的时候向所有的NameServer注册，并保持长连接，每30s发送一次心跳 Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息 Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费 6.消息队列如何保证消息可靠传输 为了保证消息不多，也就是消息不能重复，也就是生产者不能重复生产消息，或者消费者不能重复消费消息 首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制 要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题 消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面 生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就 是消费端ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到ack后才会删除消息","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"消息队列","slug":"消息队列","permalink":"https://gwtt.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}]},{"title":"分布式面试","slug":"分布式面试","date":"2022-06-12T15:14:14.872Z","updated":"2022-06-29T12:06:56.184Z","comments":true,"path":"2022/06/12/分布式面试/","link":"","permalink":"https://gwtt.github.io/2022/06/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95/","excerpt":"","text":"分布式1.什么是CAP理论 CAP理论是分布式领域中非常重要的一个指导理论，C(Consistency)表示强一致性，A(Availability)表示可用性，P(Partition Tolerance)表示分区容错性，CAP理论指出在目前的硬件条件下，一个分布式系统是必须要保证分区容错性的，而在这个前提下，分布式系统要么保证C，要么保证AP，无法同时保证CAP。 分区容错性表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布式系统内部的某个结点挂点，或网络出现了故障，而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性的。 强一致性表示，一个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的，不然就会造成数据不一致，所以强一致性和可用性是不能同时满足的。 可用性表示，一个分布式系统对外要保证可用。 2.什么是BASE理论 由于不能同时满足CAP，所以出现了BASE理论:1.BA: Basically Available，表示基本可用，表示可以允许一定程度的不可用，比如由于系统故障，请求时间变长，或者由于系统故障导致部分非核心功能不可用，都是允许的 2.S: Soft state:表示分布式系统可以处于一种中间状态，比如数据正在同步 3.E:Eventually consistent，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后再达到一致，在达到一致过程中系统也是可用的 3.什么是RPC 什么是 RPC ？ RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。 除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。 其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。 简单的说 RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。 RPC会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）。 客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。 4.什么是分布式ID 在分布式系统中，经常需要一些全局唯一的ID对数据、消息、http请求等进行唯一标识。那么这个全局唯一ID就叫分布式ID 5.为什么需要分布式ID 1.如果id我们使用的是数据库的自增长类型，在分布式系统中需要分库和分表时，会有两个相同的表，有可能产生主键冲突。 2.电商订单号，采用自增方式，是最简单的生成规则。但是！这种与流水号相同的订单号很容易就被竞争对手看出你公司真实的运营信息。 6.分布式ID解决方案 1.uuid，这种方案复杂度最低，但是会影响存储空间和性能 ⒉利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候此方案也不是最优方案 3.利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库(mysql)相比，性能有所提高,可以适当选用 4.雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证趋势递增。业界存在tinyid、 leaf等开源中间件实现了雪花算法 7.分布式锁的使用场景和实现方案 在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时，遇到资源竞争时，可以利用ReentrantLock、synchronized等技术来作为锁，来控制共享资源的使用。 而在分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用ReentrantLock、synchronized等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，需要一个分布式锁生成器，分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁。 目前主流的分布式锁的实现方案有两种: 1.zookeeper:利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱 2.redis:利用redis的setnw、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式锁可能不可靠，不稳定(一旦redis中的数据出现了不一致)，可能会出现多个客户端同时加到锁的情况 8.分布式事务和实现实现方案 在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于一次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。常用解决方案有: 1.本地消息表:创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统 2.消息队列:目前RocketMQ中支持事务消息，它的工作原理是: a.生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的 b.再创建订单，根据创建订单成功与否，向Broker发送commit或rollback c.并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功 d.一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束 e.如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理 3.Seata:阿里开源的分布式事务框架，支持AT、TCC等多种模式，底层都是基于两阶段提交理论来实现的 9.简述zab协议 ZAB协议（Zookeeper Atomic Broadcast原子广播）是Zookeeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段: 1.领导者选举阶段:从Zookeeper集群中选出一个节点作为Leader，所有的写请求都会由Leader节点来处理 ⒉数据同步阶段:集群中所有节点中的数据要和Leader节点保持一致，如果不一致则要进行同步 3.请求广播阶段:当Leader节点接收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致 但值得注意的是，Zookeeper只是尽量的在达到强一致性，实际上仍然只是最终一致性的。 10.Spring Cloud和Dubbo有哪些区别? Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用间的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有SpringCloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来一起使用的。 11.什么是服务雪崩?什么是服务限流? 1.当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。2．服务限流是指在高并发请求下，为了保护系统，可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。 12.什么是服务熔断?什么是服务降级?区别是什么? 1.服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。 2服务降级是指，当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力，这就是服务降级。 相同点: 1．都是为了防止系统崩溃 2．都让用户体验到某些功能暂时不可用 不同点:熔断是下游服务故障触发的，降级是为了降低系统负载","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"分布式","slug":"分布式","permalink":"https://gwtt.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Mybatis面试(1)","slug":"Mybatis面试(1)","date":"2022-06-12T15:12:55.815Z","updated":"2022-07-02T09:39:28.585Z","comments":true,"path":"2022/06/12/Mybatis面试(1)/","link":"","permalink":"https://gwtt.github.io/2022/06/12/Mybatis%E9%9D%A2%E8%AF%95(1)/","excerpt":"","text":"Mybatis(1)1.Mybatis的优缺点 Mybaits 的优点： 1234567891.基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。2.与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；3.很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。4.能够与 Spring 很好的集成；5.提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。 MyBatis 框架的缺点： 1231.SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。2.SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。 2.Mybatis中的#{}和${}区别是什么 1.#{}是预编译处理、是占位符，${}是字符串替换、是拼接符 2.Mybatis在处理#{}时，会将sql中的#替换为?号，调用PreparedStatement来赋值 3.Mybatis在处理${}时，就是把$替换成变量的值，调用Statement来赋值 4.使用#{}可以很大程度上防止SQL注入，提高系统安全性 5.#号防止sql注入的原理就是对参数及参数中的特殊字符进行了转义，从而达到防止sql注入的效果。 3.ORM框架是什么 对象关系映射（Object—Relational Mapping，简称ORM） 是一种为了解决面向对象与面向关系数据库存在的互不匹配的现象的技术；简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将java 程序中的对象自动持久化到关系数据库中；本质上就是将数据从一种形式转换到另外一种形式。 常见的比如Hibernate, Mybatis,TopLink等框架","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://gwtt.github.io/tags/Mybatis/"}]},{"title":"Redis面试","slug":"Redis面试","date":"2022-06-12T15:11:30.900Z","updated":"2022-06-29T12:06:28.149Z","comments":true,"path":"2022/06/12/Redis面试/","link":"","permalink":"https://gwtt.github.io/2022/06/12/Redis%E9%9D%A2%E8%AF%95/","excerpt":"","text":"Redis1.redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？ redis 持久化的两种方式 RDB：RDB 持久化机制，是对 redis 中的数据执行周期性的持久化。 AOF（append only file）：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，在 redis 重启的时候，可以通过回放 AOF 日志中的写入指令来重新构建整个数据集。 RDB 优缺点 RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。 RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。 如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。 RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。 AOF 优缺点 AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次fsync操作，最多丢失 1 秒钟的数据。 AOF 日志文件以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。 AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。 AOF 日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。 对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。 AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 fsync 一次日志文件，当然，每秒一次 fsync，性能也还是很高的。（如果实时写入，那么 QPS 会大降，redis 性能会大大降低） 以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 / merge / 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。 RDB 和 AOF 到底该如何选择 不要仅仅使用 RDB，因为那样会导致你丢失很多数据； 也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug； redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。 2.说说缓存雪崩、缓存击穿、缓存穿透吧，解决办法？ 缓存雪崩出现过程 假设有如下一个系统，高峰期请求为5000次/秒，4000次走了缓存，只有1000次落到了数据库上，数据库每秒1000的并发是一个正常的指标，完全可以正常工作，但如果缓存宕机了，或者缓存设置了相同的过期时间，导致缓存在同一时刻同时失效，每秒5000次的请求会全部落到数据库上，数据库立马就死掉了，因为数据库一秒最多抗2000个请求，如果DBA重启数据库，立马又会被新的请求打死了，这就是缓存雪崩。 解决方法 事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃 事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL被打死 事后：redis持久化RDB+AOF，快速恢复缓存数据 缓存的失效时间设置为随机值，避免同时失效 缓存穿透出现过程 假如客户端每秒发送5000个请求，其中4000个为黑客的恶意攻击，即在数据库中也查不到。举个例子，用户id为正数，黑客构造的用户id为负数，如果黑客每秒一直发送这4000个请求，缓存就不起作用，数据库也很快被打死。 解决方法 对请求参数进行校验，不合理直接返回 查询不到的数据也放到缓存，value为空，如 set -999 “” 使用布隆过滤器，快速判断key是否在数据库中存在，不存在直接返回 缓存击穿出现过程 设置了过期时间的key，承载着高并发，是一种热点数据。从这个key过期到重新从MySQL加载数据放到缓存的一段时间，大量的请求有可能把数据库打死。缓存雪崩是指大量缓存失效，缓存击穿是指热点数据的缓存失效 解决方法 设置key永远不过期，或者快过期时，通过另一个异步线程重新设置key 当从缓存拿到的数据为null，重新从数据库加载数据的过程上锁，下面写个分布式锁实现的demo 1231，缓存雪崩:如果缓存中某一时刻大批热点数据同时过期，那么就可能导致大量请求直接访问Mysql了，解决办法就是在过期时间上增加一点随机值，另外如果搭建一个高可用的Redis集群也是防止缓存雪崩的有效手段2．缓存击穿:和缓存雪崩类似，缓存雪崩是大批热点数据失效，而缓存击穿是指某一个热点key突然失效，也导致了大量请求直接访问Mysql数据库，这就是缓存击穿，解决方案就是考虑这个热点key不设过期时间3．缓存穿透:假如某一时刻访问redis的大量key都在redis中不存在(比如黑客故意伪造一些乱七八糟的key)，那么也会给数据造成压力，这就是缓存穿透，解决方案是使用布隆过滤器，它的作用就是如果它认为一个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加一层布隆过滤器来拦截不存在的key 3.redis为什么快 1、Redis 是一款纯内存结构，避免了磁盘 I/O 等耗时操作。 2、Redis 命令处理的核心模块为单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。 3、采用了 I/O 多路复用机制，大大提升了并发效率。 4.redis缓存淘汰策略 Redis内存不足的缓存淘汰策略提供了8种。noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键allkeys-random：加入键的时候如果过限，从所有key随机删除volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键allkeys-lfu：从所有键中驱逐使用频率最少的键 12345678这八种大体上可以分为4中，lru、lfu、random、ttl。lru：Least Recently Used)，最近最少使用lfu：Least Frequently Used，最不经常使用法ttl：Time To Live，生存时间random：随机默认是noeviction。对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外eviction：“逐出；赶出；收回”。volatile：“不稳定的”。 Redis默认的过期策略是noeviction, 最暴力那个, 如果内存满了那就是一场“华丽”的故事了。 5.Redis有哪些数据结构？分别有哪些典型的应用场景? Redis的数据结构有: 字符串:可以用来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID 哈希表:可以用来存储一些key-value对，更适合用来存储对象 列表: Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据 集合:和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似,我和某人共同关注的人、朋友圈点赞等功能 有序集合:集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能 6.Redis分布式锁底层是如何实现的 首先利用setnx来保证:如果key不存在才能获取到锁，如果key存在，则获取不到锁 然后还要利用lua脚本来保证多个redis操作的原子性 同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约 同时还要考虑到redis书点挂掉后的情况，所以需要采用红锁的方式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到 7.Redis和Mysql如何保证数据一致 1．先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不一致 2．先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种方案能解决1方案的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了Redis缓存数据，正在更新Mysql，此时另外一个查询再查询，那么就会把Mysql中老数据又查到Redis中 3，延时双删，步骤是:先删除Redis缓存数据，再更新Mysql，延迟几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把老数据读到了Redis中，那么也会被删除掉，从而把数据保持一致","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Redis","slug":"Redis","permalink":"https://gwtt.github.io/tags/Redis/"}]},{"title":"MySQL面试(1)","slug":"Mysql面试(1)","date":"2022-06-12T15:09:55.412Z","updated":"2022-07-02T09:55:37.945Z","comments":true,"path":"2022/06/12/Mysql面试(1)/","link":"","permalink":"https://gwtt.github.io/2022/06/12/Mysql%E9%9D%A2%E8%AF%95(1)/","excerpt":"","text":"MySQL(1) 1.$跟#的区别 #相当于对数据 加上 双引号，$相当于直接显示数据。 2.MySQL的事务隔离级别有哪些？默认隔离级别是？ READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。(默认) SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 12345脏读：一个事务读取另外一个事务还没有提交的数据。不可重复读：事务 T1 读到某行；事务 T2 修改或删除这行，提交事务；T1 重新读取发现这行数据已经被修改或删除。幻读：事务 T1 读取了 N 行；事务 T2 在事务 T1 读取的条件范围内生成了一行或多行数据；T1 重新读取获得与之前不同集合的行数据。 3.explain语句结果各个字段分别表示什么 Column 含义 id 查询序号 select_type 查询类型 table 表名 partitions 匹配的分区 type join类型 prossible_keys 可能会选择的索引 key 实际选择的索引 key_len 索引的长度 ref 与索引作比较的列 rows 要检索的行数(估算值) filtered 查询条件过滤的行数的百分比 Extra 额外信息 id: SQL查询中的序列号。 select_type: 查询的类型，可以是下表的任何一种类型： select_type 类型说明 SIMPLE 简单SELECT(不使用UNION或子查询) PRIMARY 最外层的SELECT UNION UNION中第二个或之后的SELECT语句 DEPENDENT UNION UNION中第二个或之后的SELECT语句取决于外面的查询 UNION RESULT UNION的结果 SUBQUERY 子查询中的第一个SELECT DEPENDENT SUBQUERY 子查询中的第一个SELECT, 取决于外面的查询 DERIVED 衍生表(FROM子句中的子查询) MATERIALIZED 物化子查询 UNCACHEABLE SUBQUERY 结果集无法缓存的子查询，必须重新评估外部查询的每一行 UNCACHEABLE UNION UNION中第二个或之后的SELECT，属于无法缓存的子查询 table 表名或者表的别名。 partitions 分区信息，非分区表为null。 type 访问类型，表示找到所查询数据的方法，也是本文重点介绍的属性。该属性的常见值如下，性能从好到差： NULL：无需访问表或者索引，比如获取一个索引列的最大值或最小值。 system/const：当查询最多匹配一行时，常出现于where条件是＝的情况。system是const的一种特殊情况，既表本身只有一行数据的情况。 eq_ref：多表关联查询时，根据唯一非空索引进行查询的情况。 ref：多表查询时，根据非唯一非空索引进行查询的情况。 range：在一个索引上进行范围查找。 index：遍历索引树查询，通常发生在查询结果只包含索引字段时。 ALL：全表扫描，没有任何索引可以使用时。这是最差的情况，应该避免。 possible_keys 表示mysql此次查询中可能使用的索引。 key 表示mysql实际在此次查询中使用的索引。 key_len 表示mysql使用的索引的长度。该值越小越好。 ref如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func rows 也是一个重要的字段。 这是mysql估算的需要扫描的行数（不是精确值）。这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好. extra（重要） explain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容: distinct：在select部分使用了distinc关键字 Using filesort：当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大. Using index“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错 Using temporary查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化. 4.什么是覆盖索引？ 覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。 5.最左前缀原则是什么 当一个SQL想要利用索引是，就一定要提供该索引所对应的字段中最左边的字段，也就是排在最前面的字段，比如针对a,b,c三个字段建立了一个联合索引，那么在写一个sql时就一定要提供a字段的条件，这样才能用到联合索引，这是由于在建立a,b,c三个字段的联合索引时，底层的B+树是按照a,b.c三个字段从左往右去比较大小进行排序的，所以如果想要利用B+树进行快速查找也得符合这个规则 6.lnnodb是如何实现事务的 Innodb通过Buffer Pool，LogBuffer，Redo Log, Undo Log来实现事务，以一个update语句为例: Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中 执行update语句，修改Buffer Pool中的数据，也就是内存中的数据 针对update语句生成一个RedoLog对象，并存入LogBuffer中 针对update语句生成undolog日志，用于事务回滚 如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中6．如果事务回滚，则利用undolog日志进行回滚 7.B树和B+树的区别，为什么Mysql使用B+树 B树的特点: 1．节点排序2.一个节点了可以存多个元素，多个元素也排序了 B+树的特点: 1．拥有B树的特点2．叶子节点之间有指针3．非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序 Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。 为什么索引采用B+树 1.索引用来加快查询速度，B+树对数据排序可以加快查询速度 2.一个节点存储多个元素，B+树不会很高，一个innodb页是一个节点，两层B+树可以存储200万条数据 3.B+树叶子节点有指针，可以支持全表扫描，范围查找等SQL语句 8.Mysql锁有哪些，如何理解 按锁粒度分类: 行锁:锁某行数据，锁粒度最小，并发度高 表锁:锁整张表，锁粒度最大，并发度低 间隙锁:锁的是一个区间 还可以分为: 共享锁:也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写- 排它锁:也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写 还可以分为: 乐观锁:并不会真正的去锁某行记录，而是通过一个版本号来实现的 悲观锁:上面所的行锁、表锁等都是悲观锁 在事务的隔离级别实现中，就需要利用锁来解决幻读 9.Mysql慢查询该如何优化? 检查是否走了索引，如果没有则优化SQL利用索引 检查所利用的索引，是否是最优索引 检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据 检查表中数据是否过多，是否应该进行分库分表了 检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源 10.mysql有哪些引擎 所谓的存储引擎是指用于存储、处理和保护数据的核心服务。也就是存储引擎是数据库的底层软件组织。在 MySQL 中可以使用“show engines”来查询数据库的所有存储引擎 nnoDB 存储引擎InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。 特点(1) 支持自动增长列AUTO_INCREMENT。自动增长列的值不能为空，且值必须唯一。MySQL中规定自增列必须为主键。(2) 支持外键，保证数据的完整性和正确性。外键所在表为子表，外键所依赖的表为父表。父表中被子表外键关联的字段必须为主键。(3) DML(数据库操作)操作遵循ACID模型，支持事务。(4) 行级锁 ，提高并发访问性能。 MyISAM 存储引擎MyISAM是MySQL早期的默认存储引擎。 特点(1) 不支持事务，不支持外键(2) 支持表锁，不支持行锁(3) 占用空间小，访问速度快 Memory 存储引擎Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。 特点(1) 内存存放(2) hash索引（默认） 11.索引的作用 创建索引可以大大提高系统的性能。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 12.索引的类型 存储方式区分1. B-树索引目前大多数索引都是采用B-树来存储，其包含组件有： 叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。 分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。 根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。 2. 哈希索引哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B-树索引和 HASH 索引，且将 HASH 当成默认索引。 哈希索引的最大特点是访问速度快，但也存在下面的一些缺点： MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B-树索引来说，建立哈希索引会耗费更多的时间。 不能使用 HASH 索引排序。 HASH 索引只支持等值比较，如”=” “IN()”或”&lt;=&gt;”。 HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。 逻辑区分1. 普通索引普通索引是 MySQL 中最基本的索引类型，它没有任何限制，唯一任务就是加快系统对数据的访问速度。允许重复值和空值。 关键字是 INDEX 或 KEY。 2. 唯一索引唯一索引列的值必须唯一，允许有空值。如果是组合索引，则列值的组合必须唯一。 关键字是 UNIQUE。 3. 主键索引主键索引是一种特殊的唯一索引，不允许值重复或者值为空。 关键字是 PRIMARY KEY。 4. 空间索引空间索引是对空间数据类型的字段建立的索引，不允许空值，只能在存储引擎为 MyISAM 的表中创建。 关键字是 SPATIAL。 5. 全文索引全文索引主要用来查找文本中的关键字，只能在 CHAR、VARCHAR 或 TEXT 类型的列上创建。只有 MyISAM 存储引擎支持，允许重复值和空值。 关键字是 FULLTEXT。 实际使用区分1. 单列索引单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。 2. 组合索引组合索引也称为复合索引或多列索引。相对于单列索引来说，组合索引是将原表的多个列共同组成一个索引。 查询时，字段顺序需与索引顺序一致；LIKE时，首字符不能是 ‘%’，否则会影响索引使用。","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","permalink":"https://gwtt.github.io/tags/MySQL/"}]},{"title":"Jvm面试","slug":"jvm面试","date":"2022-06-12T15:08:16.733Z","updated":"2022-06-12T15:09:39.003Z","comments":true,"path":"2022/06/12/jvm面试/","link":"","permalink":"https://gwtt.github.io/2022/06/12/jvm%E9%9D%A2%E8%AF%95/","excerpt":"","text":"jvm1.垃圾回收机制了解吗 1.垃圾回收算法 标记清除算法 复制算法 标记整理算法。 分代收集算法。 什么是标记清除算法？ 标记： 从根集合进行扫描，对存活的对象进行标记。 清除： 对堆内存从头到尾进行线性遍历，回收不可达对象内存。 标记-清除算法的缺点是什么？ 会造成很多内存碎片。补充： 为什么会造成很多内存碎片？ 因为标记清除算法。不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除以后，会造成大量的不连续的内存碎片，空间碎片太多，可能会导致，在以后需要创建较大对象时候，无法找到足够的连续内存，而不得不提前触发另一次垃圾回收， 什么是复制算法？（复制算法： 适合对象存活率低的场景） 复制算法将内存按容量按一定的比例分为对象面和空闲面。 对象在对象面上创建。 存活的对象被从对象面复制到空闲面。(这个时候空闲面变为对象面) 将对象面中所有的对象全部清空。 (这个时候，对象面变为空闲面)。 年轻代很多垃圾收集器，都用这个算法回收。 复制算法的优点，缺点各是什么？ 优点： 解决了内存碎片化的问题。 顺序分配内存，简单高效。 适用于对象存活率低的场景。 缺点： 对于对象存活率高的场景不适合。 什么是标记-整理算法？ 标记： 从根集合进行扫描，对存活的对象进行标记。 清除： 移动所有存活的对象， 且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。 标记-整理算法有什么优点？ 避免了内存的不连续性。 不用设置两块内存互换。 适用于存活率高的场景。 什么是分代收集算法？ 垃圾回收算法的组合拳。 按照对象生命周期的不同划分区域以 采用不同的垃圾回收算法。 目的： 提高JVM的 回收效率。 补充： JDK7 ，及以前：垃圾回收区分为三部分： Eden Space（年轻代）， Tenured Space（老年代） , Permanent Space（永久代）. 年轻代： 年轻代又被 划分为 Eden Space，(Eden 区 ) ， From Space, To Space.（也就是 两个Survivor 区） Eden区： 伊甸园。 如果Eden区放不下，会直接放在 Survivor 区，或者老年区。 Survivor 区分为：from 区， to 区， 划分不一定。 JDK8 : 垃圾回收区分为两部分： Eden Space， Tenured Space , 没有 Permanent Space。 2.JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？ JVM运行时一共划分：程序计数器、虚拟机栈、堆、本地方法栈、方法区。 线程共享的数据区域：堆、方法区。 线程独享的数据区域区域：程序计数器、虚拟机栈、本地方法栈。 连问（1）这几个内存区域分别存放什么数据？ 程序计数器: 记录当前线程执行的位置 虚拟机栈: 存储基本数据类型以及对象的引用等 堆: 存储对象实例 本地方法栈: 与虚拟机栈类似，它为Native方法服务 方法区: 存储被JVM加载的类信息、常量、静态变量等。","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Jvm","slug":"Jvm","permalink":"https://gwtt.github.io/tags/Jvm/"}]},{"title":"计算机网络面试","slug":"计算机网络面试","date":"2022-06-12T15:00:11.369Z","updated":"2022-07-01T05:15:36.235Z","comments":true,"path":"2022/06/12/计算机网络面试/","link":"","permalink":"https://gwtt.github.io/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/","excerpt":"","text":"计算机网络相关1.get和post的区别 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 从标准上来看，GET 和 POST 的区别如下： GET 用于获取信息，是无副作用的，是幂等的，且可缓存 POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存 2.http和https的区别 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。 简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别主要如下： 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 3.TCP和udp的区别 TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接 TCP要求的系统资源较多，UDP较少 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信 TCP首部开销20字节；UDP的首部开销小，只有8个字节 TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道 4.说说浏览器输入网址到返回页面的过程？ 12345基础版本：浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP ，向服务器发起请求；服务器交给后台处理完成后返回数据，浏览器接收⽂件（ HTML、JS、CSS 、图象等）；浏览器对加载到的资源（ HTML、JS、CSS 等）进⾏语法解析，建立相应的内部数据结构 （如 HTML 的 DOM）；载⼊解析到的资源⽂件，渲染页面，完成。 1、用户在输入栏输入地址 (1) 如果有 beforeunload 事件会先执行判断继续还是跳出操作 (2) 浏览器进程识别是 地址还是关键字检索 (3) 将正确的 url 地址发送给网络进程 2、网络进程查看有没有缓存 (1) 有缓存直接返回数据 (2) 没有缓存直接进入网络进程请求流程 3、浏览器进程查询 DNS 获取服务器 ip 地址 (1) 如果请求协议是 https 那么还需要建立TLS连接 (2) 利用ip地址和服务器建立 tcp 连接 (3) 如果浏览器的 tcp 连接请求有超过浏览器设定限额，则需要排队等待 4、tcp 连接协议通过与服务器进行3次握手确立连接 (1) 浏览器即用户端发起第一次握手 (2) 服务器接收到用户端的消息发起接收到信息 (3) 用户端接收到信息后向服务器发起第三次握手表示已经接收到信息可以连接 (4) 如果第二次握手发送数据包丢失或者用户端发起第三次握手数据包丢失，服务器在长时间未接收到信息会再次发起，总共会尝试6次 5、tcp 接受信息 6、网络进程接收到数据后将返回头和返回体发送给浏览器 7、浏览器进程读取返回头查看返回信息，是否重定向或者响应数据类型处理 (1) 重定向即回到第3步 (2) 会根据 Content-Type 的值来决定如何显示响应体的内容。 (3) Content-Type 为下载类型就会把请求交给浏览器的下载管理器，导航结束 (4) 如果是 HTML，那么浏览器则会继续进行导航流程 8、准备渲染进程 9、浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息 10、渲染进程就和网络进程直接建立连接进行管道数据传输 11、数据传输完成后tcp发起4次挥手断开连接并且渲染进程同时向浏览器进程发起确认提交 12、浏览器进程收到确认提交后会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态。 13、渲染进程开始页面解析和子资源加载 相关的题目浏览器发出一个请求到收到响应经历了哪些步骤?1234561.浏览器解析用户输入的URL，生成一个HTTP格式的请求⒉先根据URL域名从本地hosts文件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址 3.浏览器通过操作系统将请求通过四层网络协议发送出去4.途中可能会经过各种路由器、交换机，最终到达服务器5.服务器搜到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了 6.tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet7.然后servlet来处理这个请求，如果是SpringMVC中的DispatcherSservlet，那么则会找到对应的Controller中的方法，并执行该方法得到结果 8.Tomcat得到响应结果后封装成HTTP响应的格式，并再次通过网络发送给浏览器所在的服务器9.浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染 5.cookie做什么的？session又是什么？它们直接的关系？ 什么是Cookie？Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。 当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。信息保存的时间可以根据需要设置. 如果没有设置Cookie失效日期,它们仅保存到关闭浏览器程序为止.如果将Cookie对象的Expires属性设置为Minvalue,则表示Cookie永远不会过期. Cookie存储的数据量很受限制,大多数浏览器支持最大容量为4K,因此不要用来保存数据集及其他大量数据. 由于并非所有的浏览器都支持Cookie,并且数据信息是以明文文本的形式保存在客户端的计算机中,因此最好不要保存敏感的,未加密的数据,否则会影响网站的安全性 什么是Session？Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。 每个用户访问服务器都会建立一个session，那服务器是怎么标识用户的唯一身份呢？事实上，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。 Session和Cookie的区别？ 1、数据存储位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、安全性：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。 3、服务器性能：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。 4、数据大小：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、信息重要程度：可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。 6.跨域请求是什么?有什么问题?怎么解决? 跨域是指浏览器在发起网络请求时，会检查该请求所对应的协议、域名、端口和当前网页是否一致，如果不一致则浏览器会进行限制，比如在www.baidu.com的某个网页中，如果使用ajax去访问www.jd.com是不行的，但是如果是img、iframe、scipt等标签的sc属性去访问则是可以的，之所以浏览器要做这层限制，是为了用户信息安全。但是如果开发者想要绕过这层限制也是可以的: 1.response添加header，比如resp.setHeader(“Access-Control-Allow-Origin”*);表示可以访问所有网站，不受是否同源的限制 2.jsonp的方式，该技术底层就是基于script标签来实现的，因为script标签是可以跨域的 3.后台自己控制，先访问同域名下的接口，然后在接口中再去使用HTTPClient等工具去调用目标接口 4.网关，和第三种方式类似，都是交给后台服务来进行跨域访问 7.Netty是什么？和Tomcat有什么区别？特点是什么？ Netty是一个基于NIO的异步网络通信框架，性能高，封装了原生NIO编码的复杂度，开发者可以直接使用Netty来开发高效率的各种网络服务器，并且编码简单。Tomcat是一个Web服务器，是一个Servlet容器，基本上Tomcat内部只会运行Servlet程序，并处理HTTP请求，而Netty封装的是底层IO模型，关注的是网络数据的传输，而不关心具体的协议，可定制性更高。 Netty的特点: 异步、NIO的网络通信框架 高性能 高扩展，高定制性 易用性 8.TCP的三次握手和四次挥手过程 TCP协议是7层网络协议中的传输层协议，负责数据的可靠传输。在建立TCP连接时，需要通过三次握手来建立，过程是: 客户端向服务端发送一个SYN 服务端接收到SYN后，给客户端发送一个SYN_ACK 客户端接收到SYN_ACK后，再给服务端发送一个ACK 在断开TCP连接时，需要通过四次挥手来断开，过程是: 客户端向服务端发送FIN 服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理 服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接 客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了 SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gwtt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Springboot面试(1)","slug":"Springboot面试(1)","date":"2022-06-12T14:52:33.501Z","updated":"2022-07-02T09:32:11.209Z","comments":true,"path":"2022/06/12/Springboot面试(1)/","link":"","permalink":"https://gwtt.github.io/2022/06/12/Springboot%E9%9D%A2%E8%AF%95(1)/","excerpt":"","text":"springboot(1)1.说说对springmvc的理解 什么是MVCmvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。 mvc设计模式的好处 1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。 2.有利于系统的并行开发，提升开发效率。 SpringMVC流程 1、 用户发送请求至前端控制器DispatcherServlet。 2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、 DispatcherServlet调用HandlerAdapter处理器适配器。 5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 6、 Controller执行完成返回ModelAndView。 7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 9、 ViewReslover解析后返回具体View。 10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 11、 DispatcherServlet响应用户。 核心组件DispatcherServlet（前端控制器）说明：Spring MVC 的入口函数，接收请求，响应结果，相当于转发器，中央处理器，它就相当于mvc模式中DispatcherServlet的存在降低了组件之间的耦合性。HandlerMapping(处理器映射器）说明：根据请求的url查找Handler（即处理器Controller），映射方式有配置文件方式，实现接口方式，注解方式等。HandlerAdapter(处理器适配器)说明：HandlerAdapter是适配器模式的应用，按照HandlerAdapter要求的规则去执行Handler。Handler（处理器）说明：Handler需要开发工程师按照HandlerAdapter的要求去做，是后端控制器，处理具体的业务逻辑。View resolver（视图解析器）说明：进行视图解析，首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。视图View说明：View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf等） springMVC是一个MVC的开源框架，springMVC=struts2+spring，springMVC就相当于是Struts2加上sring的整合，但是这里有一个疑惑就是，springMVC和spring是什么样的关系呢？这个在百度百科上有一个很好的解释：意思是说，springMVC是spring的一个后续产品，其实就是spring在原有基础上，又提供了web应用的MVC模块，可以简单的把springMVC理解为是spring的一个模块（类似AOP，IOC这样的模块），网络上经常会说springMVC和spring无缝集成，其实springMVC就是spring的一个子模块，所以根本不需要同spring进行整合。 2.说说ioc和aop理解和原理 IOCIOC叫做控制反转，指的是通过Spring来管理对象创建、配置和生命周期，这样相当于把控制权交给了Spring，不需要人工来管理对象之间的复杂的依赖关系，这样做的好处就是解耦！ 在Spring里面，主要提供BeanFactory和ApplicationContext两种IOC容器，通过它们来实现对Bean的管理！ AOP叫做面向切面编程，他是一个编程范式，目的就是提高代码的模块性。Spring AOP基于动态代理的方式实现，如果是实现了接口的话就会使用JDK动态代理，反之则使用CGLIB代理。Spring中AOP的应用主要体现在事务、日志、异常处理等方面，通过在代码的前后做一些增强处理，可以实现对业务的逻辑隔离，提高代码的模块化能力，同时也是解耦。Spring主要提供了Aspect切面，JoinPoint连接点、PointCut切入点、Advice增强等实现方式。 3.说说springboot的理解 在使用spring框架的时候,我们需要配置applicationContext.xml的配置文件,并且在pom文件中,我们需要导入相关的依赖jar包以及版本,这样在使用的过程中,就显得有些复杂. 而springboot利用起步依赖和自动装配就很好的解决了一个问题,首先,我们来说说起步依赖,在springboot的pom文件中,我们依赖父工程 ,在父工程中,定义了相关的坐标以及版本信息,这样我们继承了这个父工程的时候,就不需要指定版本信息,在我们的项目中.依赖了start-web这个坐标,而这个坐标依赖了spring以及springmvc的坐标,这样,根据依赖传递我们的项目就间接依赖了spring和mvc坐标,所有我们只需要导入start-web这一个坐标就可以了 接下来我们说说自动装配,在springboot的启动类上有一个@SpringBootApplication注解,这个注解也是springboot项目的核心注解,在@SpringBootApplication注解中,有一个@EnableAutoConfiguration注解,也就是开启自动配置的意思,这个注解的关键功能由@Import提供,其导入的AutoConfigurationImportSelector中的selectImports()方法能够找到META-INF/spring.factories配置文件中的所有启动配置类,并对其进行加载,而这些自动配置类都是以AtuoConfiguration结尾来命名的,它实际上就是一个JavaConfig形式的Spring容器配置类,通过@ConfigurationProperties注解,绑定到对应的以properties结尾的配置实体类上封装为一个bean,然后在通过@EnableAutoConfiguration注解导入到Spring容器中,这样自动装配就完成了. 4.使用过过滤器或者拦截器吗，说说拦截器的方法和实现的接口 使用过 用过滤器主要做过全局网关配置请求token和跨域问题，实现Filter接口 用拦截器主要做日志输出，实现HandlerInterceptor 接口，有三个方法，preHandle，postHandle，afterCompletion，分别是请求之前调用，之后调用，结束后调用，然后相比过滤器，它需要在springmvc注入，在启动类添加配置代码。实现WebMvcConfigurer接口添加拦截器。 5.aop在什么情况下会使用到 AOP的应用场景：1.日志处理2.用户登录3.权限（Authentication ）4.性能优化（Performance optimization）5.事务（Transactions ）6.记录跟踪 优化 校准（logging, tracing, profiling and monitoring）7.调试（Debugging）8.懒加载（Lazy loading）9.错误处理（Error handling）10.资源池（Resource pooling）11.同步（Synchronization） 6.如果有过滤器和拦截器和aop，他们的执行顺序是什么 执行顺序依次是过滤器、拦截器、切面 7.Spring 中的bean 是线程安全的吗 Spring本身并没有针对Bean做线程安全的处理，所以: 1.如果Bean是无状态的，那么Bean则是线程安全的 2.如果Bean是有状态的，那么Bean则不是线程安全的 另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。 (有状态会话bean ：每个用户有自己特有的一个实例，在用户的生存期内，bean保持了用户的信息，即“有状态”；一旦用户灭亡（调用结束或实例结束），bean的生命期也告结束。即每个用户最初都会得到一个初始的bean。简单来说，有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。无状态会话bean ：bean一旦实例化就被加进会话池中，各个用户都可以共用。即使用户已经消亡，bean 的生命期也不一定结束，它可能依然存在于会话池中，供其他用户调用。由于没有特定的用户，那么也就不能保持某一用户的状态，所以叫无状态bean。但无状态会话bean 并非没有状态，如果它有自己的属性（变量），那么这些变量就会受到所有调用它的用户的影响，这是在实际应用中必须注意的。简单来说，无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。) 8.BeanFactory和ApplicationContext的区别 BeanFactory： 是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能； ApplicationContext： 应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能； 国际化（MessageSource） 访问资源，如URL和文件（ResourceLoader） 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 消息发送、响应机制（ApplicationEventPublisher） AOP（拦截器） 9.@Transactional 注解的失效场景 1、@Transactional 应用在非 public 修饰的方法上 如果Transactional注解应用在非public 修饰的方法上，Transactional将会失效。 注意：protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。 2、@Transactional 注解属性 propagation 设置错误 这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 3、@Transactional 注解属性 rollbackFor 设置错误 rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务，其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定rollbackFor属性。 4、同一个类中方法调用，导致@Transactional失效 开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。当外界调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。那为什么会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。 10.spring运用了哪些设计模式 工厂模式Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。 代理模式Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。 模板方法模式Spring中jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是Spring并没有使用这种方式，而是使用Callback模式与模板方法配合，既达到了代码复用的效果，同时增加了灵活性。 观察者模式观察者设计模式是一种对象行为模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变时，这个对象锁依赖的对象也会做出反应。Spring事件驱动模型就是观察者模式很经典的应用。 适配器 模式适配器设计模式将一个接口转换成客户希望的另一个接口，适配器模式使得接口不兼容的那些类可以一起工作，其别名为包装器。在Spring MVC中，DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler，解析到对应的Handler（也就是我们常说的Controller控制器）后，开始由HandlerAdapter适配器处理。为什么要在Spring MVC中使用适配器模式？Spring MVC中的Controller种类众多不同类型的Controller通过不同的方法来对请求进行处理，有利于代码的维护拓展。 装饰者模式装饰者设计模式可以动态地给对象增加些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。Spring 中配置DataSource的时候，DataSource可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下切换不同的数据源？这个时候据需要用到装饰者模式。 策略模式Spring 框架的资源访问接口就是基于策略设计模式实现的。该接口提供了更强的资源访问能力，Spring框架本身大量使用了Resource接口来访问底层资源。Resource接口本身没有提供访问任何底层资源的实现逻辑，针对不同的额底层资源，Spring将会提供不同的Resource实现类，不同的实现类负责不同的资源访问类型。 11.springmvc的工作流程 1、 用户发送http请求至前端控制器DispatcherServlet，中途会有过滤器Filter进行数据过滤。DispatcherServlet执行doService方法经过数据灌入后调用doDispatch方法，得到请求资源标识符（URI） 2、 DispatcherServlet收到请求后调用HandlerMapping处理器映射器。HandlerMapping找到具体的Handler处理器(可以根据xml配置、注解进行查找)。将生成的Handler（处理器对象）及HandlerInterceptor（处理器拦截器）一并返回给DispatcherServlet。 3，将封装好的HandlerExecutionChain类型的Handler处理器执行链和适合这个Handler的HandlerAdapter（里面定义了执行Handler的特定规则）返回给DispatcherServlet。 4，通过获取到适合的HandlerAdapter执行HandlerAdapter中的 handle方法（这个handle只是处理器适配器中的一个方法而已），方法调用Handler里对应的bean，执行该bean对应的Controller类。 5， 最终将执行结果封装成ModelAndView对象返回给DispatcherServlet。 6， DispatcherServlet将ModelAndView传给ViewReslover视图解析器，并根据View进行渲染视图（即将模型数据填充至视图中） 7，将处理过后的ModelAndView视图交给DispatcherServlet，并由DispatcherServlet响应给客户端（展示画面）。 12.Springboot中常用注解有哪些，简述一下注解的作用 @SpringBootApplication 这个注解很常见了，每次在启动SpringBoot项目的时候，都会见到它，它作用在类上，标识该类为SpringBoot项目启动类。并且让SpringBoot自动给程序进行必要的配置，等同于@Configuration、@EnableAutoConfiguration、@ComponentScan这三个注解。 @Configuration 相当于传统Spring的xml配置文件。 如果第三方库需要用到xml文件，建议通过@Configuration类作为项目的配置主类，可以使用@ImportResource注解加载xml配置文件。 @EnableAutoConfiguration 自动配置。 SpringBoot自动配置(auto-configuration)，尝试根据你添加的启动器(starter)自动配置你的SpringBoot应用。 你可以将@EnableAutoConfiguration注解或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。 如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。 @ComponentScan 如果某个类加上@ComponentScan注解，则该类会自动发现扫描组件。 也就是说，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。 我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，SpringBoot会扫描启动类所在包下以及子包下的使用了@Component、@Controller、@Service、@Repository等注解的类。 @Controller @Controller注解用于定义控制器类，在SpringBoot中由控制器负责将用户发来的URL请求转发到对应的服务接口(Controller层)。 一般这个注解用在类上，控制器方法需要加上@RequestMapping注解。 @ResponseBody 如果控制器方法加上@ResponseBody注解，该方法的返回结果将直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。 在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。 比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。 @RestController @RestController注解是@Controller和@ResponseBody的合集。 使用在类上，表示该类是控制器，并且类中所有控制器方法的返回值直接填入HTTP响应体中，是RESTful风格的控制器，控制器方法返回JSON数据。 @RequestMapping 提供路由信息，负责URL到Controller中的具体方法的映射。 @Import 用来导入其他配置类（加了@Configuration注解的类）。 @ImportResource 用来加载xml配置文件。 @PathVariable 获取URL上的参数（Restful风格接口）。 @Service 一般用于修饰service层的组件 @Repository 使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。 @Bean 用@Bean标注方法等价于XML中配置的bean，意思是产生一个bean，并交给SpringBoot管理。 @Value 注入SpringBoot中的配置文件——application.properties配置的属性的值。 @Inject 等价于默认的@Autowired，只是没有required属性。 @Component 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @AutoWired 自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。 @Qualifier 当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者。 @Resource(name=”name”,type=”type”) 没有括号内内容的话，默认byName。与@Autowired干类似的事。 附页 注解 含义 @Component 最普通的组件，可以被注入到spring容器进行管理 @Repository 作用于持久层 @Service 作用于业务逻辑层 @Controller 作用于表现层（spring-mvc的注解） 这几个注解几乎可以说是一样的：因为被这些注解修饰的类就会被Spring扫描到并注入到Spring的bean容器中。 @Autowired是根据类型进行自动装配的，如果找到多个类型相同的，会按照名称进行匹配，如果名称相同，会报错，如果需要按指定名称进行装配，则需要配合@Qualifier； @Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named； @Resource是根据名称进行自动装配的，一般会指定一个name属性 总结: 1、@Autowired是spring自带的，@Inject是JSR330规范实现的，@Resource是JSR250规范实现的，需要导入不同的包 2、@Autowired、@Inject用法基本一样，不同的是@Autowired有一个request属性 3、@Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的 4、@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Name一起使用","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Springboot","slug":"Springboot","permalink":"https://gwtt.github.io/tags/Springboot/"}]},{"title":"Juc面试(1)","slug":"Juc面试(1)","date":"2022-06-11T03:22:48.894Z","updated":"2022-07-02T07:34:55.934Z","comments":true,"path":"2022/06/11/Juc面试(1)/","link":"","permalink":"https://gwtt.github.io/2022/06/11/Juc%E9%9D%A2%E8%AF%95(1)/","excerpt":"","text":"juc(1)1.了解线程吗，他和进程有什么区别 线程的基本概念 线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程基本上自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。 好处 ： ​ （1）易于调度。 ​ （2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。 ​ （3）开销少。创建线程比创建进程要快，所需开销很少。 ​ （4）利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行 线程和进程的区别一 简单地讲,任何的一个程序都必须有且有一个以上的进程,而相对于一个进程而言也必须要有且有一个以上的线程。相对于进程而言，对线程进行划分的尺度一般要小很多，这就导致了多线程的一些程序能够出现更高的并发性。 （线程相比进程划分尺度小，迸发性更高） 线程和进程的区别二 在执行进程的时候，一般会具有相互独立的多个内存单元。但是多个线程是可以共享内存的，这样运行效率就很大的程度上被提高了。相对于单个的独立进程而言都会有相应程序的运行入口以及一些程序等出口。线程就不一样了，它不能独立的去执行而必须要依附在相应的应用程序里面。这样的话应用程序就可以执行多个线程并进行相应的控制。 （同一进程的线程共享内存，运行效率高） 线程和进程的区别三 通过了解逻辑角度我们可以得知，多线程这样的意义是相对于在一个应用程序里面的，能够同时的执行。而操作系统不会认为多个线程就是多个独立应用，因此也就不会使其调度以及管理实现资源的分配。 (线程没有资源分配) 123456789了解的，线程时进程中执行运算的最小单位，是被系统独立调度和分派的基本单位。可以创建线程或者撤销另一个线程，可以迸发执行。区别： （1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.（4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。 2.线程和进程的通信方式了解吗 进程间通信方式进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。 （1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。 （2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。 （3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身。 （4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。 （5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。 （6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。 （7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。 （8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。 线程间通信的方式 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；互斥量: Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问信号量: Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较 3.线程的创建方式 四种方式 （1）通过继承Thread类来创建新的线程。 （2）通过实现Runnable接口来创建线程。 Thread和Runnable区别： Thread 是类，需要继承，但是一个类只能继承一个类，一旦继承 Thread 之后，无法在继承其他的类。 Runnable 是接口，一个类可以实现多个接口，所以实现Runnable接口可拓展性更好 Thread是Runnable接口的实现类 （3）通过实现Callable接口来创建线程。 Runnable和Callable的区别 Runnable没有返回值。 Callable可以返回值。 （4）自定义线程池（推荐）,从中获取线程。 4.sleep和wait的区别 (1)限制 使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。 而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。 (2)使用场景 sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。 (3)类不同 sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。 (4)释放锁 wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。 (5)线程切换 sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。 5.run和start的区别 1.线程中的start()方法和run()方法的主要区别在于，当程序调用start()方法，将会创建一个新线程去执行run()方法中的代码。但是如果直接调用run()方法的话，会直接在当前线程中执行run()中的代码，注意，这里不会创建新线程。这样run()就像一个普通方法一样。 2.另外当一个线程启动之后，不能重复调用start()，否则会报IllegalStateException异常。但是可以重复调用run()方法。 总结起来就是run()就是一个普通的方法，而start()会创建一个新线程去执行run()的代码。 6.了解synchronize吗 修饰实例方法，对于普通同步方法，锁是当前的实例对象 修饰静态方法，对于静态同步方法，锁是当前的Class对象 修饰方法代码块，对于同步方法块，锁是synchronized括号里面配置的对象！ 7.创建线程池的核心参数有哪些？多讲几个? 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; corePoolSize：线程池的核心线程数。核心线程会一直存活，即便没有任务需要执行，当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理。设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。 maximumPoolSize：线程池允许的最大线程数。当线程数&gt;=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务。当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常。 keepAliveTime：线程空闲时间。当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize。如果allowCoreThreadTimeout=true，则会直到线程数量=0。 unit：keepAliveTime的时间单位。 workQueue：当核心线程数达到最大时，新任务会放在队列中排队等待执行。 threadFactory：线程工厂，ThreadFactory是一个接口，只有一个方法，即newThread(Runnable r)。从这个方法名字就可以知道，这接口是用来创建新的线程的。其使用也很简单，仅仅只需要实现newThread方法，根据自己的需要进行线程的创建即可。 handler：任务拒绝处理器。两种情况会拒绝处理任务： 1）、当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务； 2）、当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常。拒绝策略有如下几种： AbortPolicy 丢弃任务，抛运行时异常。 CallerRunsPolicy 如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务 DiscardPolicy 丢弃任务，不抛出异常 DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务，重新提交被拒绝的任务。 8.线程同步 线程同步主要包括四种方式： 互斥量pthread_mutex_ 读写锁pthread_rwlock_ 条件变量pthread_cond_ 信号量sem_ 9.说说你对volatile关键字的理解 被volatile修饰的共享变量，就具有了以下两点特性： 1 . 保证了不同线程对该变量操作的内存可见性; 2 . 禁止指令重排序 连环问(1)能不能详细说下什么是内存可见性，什么又是重排序呢？ 内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。 也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。 重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。 10.说一下公平锁和非公平锁区别 1234公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。优点：所有的线程都能得到资源，不会饿死在队列中。缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。 1234非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。 11.ReentrantLock的trylock和lock区别 1: lock拿不到锁会一直等待，并且没有返回值。tryLock是去尝试，拿不到就返回false，拿到返回true。 2: tryLock是可以被打断的，被中断的，lock是不可以。 12.CountDownLatch和Semaphore的区别和底层原理 CountDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用CountDownLatch的await()将会阻塞，其他线程可以调用CountDownLatch的countDown()方法来对CountDownLatch中的数字减一，当数字被减成o后，所有await的线程都将被唤醒. 对应的底层原理就是，调用await()方法的线程会利用AQS排队，一旦数字被减为O，则会将AQS中排队的线程依次唤醒。 Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用该信号量，通过acquire()来获取许可，如果没有许可可用则线程阻塞，并通过AQS来排队，可以通过release()方法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第一个线程开始依次唤醒，直到没有空闲许可。 13.Sychronized的偏向锁、轻量级锁、重量级锁 1.偏向锁:在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了 ⒉轻量级锁:由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁,之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程 3.如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞 4.自旋锁:自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程。阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。 14.Sychronized和ReentrantLock的区别 sychronized是一个关键字，ReentrantLock是一个类 sychronized会自动的加锁与释放锁,ReentrantLock需要程序员手动加锁与释放锁 sychronized的底层是JVM层面的锁，ReentrantLock是APl层面的锁 sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁 sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock通过代码中int类型的state标识来标识锁的状态 sychronized底层有一个锁升级的过程 15.线程池的底层工作原理 线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时: 1.如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 ⒉.如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。 3.如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。 4.如果此时线程池中的线程数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 5.当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数 16.BIO,NIO,AIO分别是什么 1.BIO:同步阻塞lO，使用BIO读取数据时，线程会阻塞住，并且需要线程主动去查询是否有数据可读，并且需要处理完一个Socket之后才能处理下一个Socket 2.NIO:同步非阻塞lO，使用NIO读取数据时，线程不会阻塞，但需要线程主动的去查询是否有IO事件 3.AlO:也叫做NIO 2.0，异步非阻塞lO，使用AIO读取数据时，线程不会阻塞，并且当有数据可读时会通知给线程，不需要线程主动去查询","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"juc","slug":"juc","permalink":"https://gwtt.github.io/tags/juc/"}]},{"title":"Java面试基础（1）","slug":"Java面试基础(1)","date":"2022-06-11T03:07:00.000Z","updated":"2022-07-02T06:37:19.100Z","comments":true,"path":"2022/06/11/Java面试基础(1)/","link":"","permalink":"https://gwtt.github.io/2022/06/11/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80(1)/","excerpt":"","text":"java基础(1)1.int和interger的区别 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。 延伸：关于Integer和int的比较1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false 2、Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为 ①当变量值在-128到127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②当变量值不在-128到127之间时，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的） 123Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 123456Integer i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因：java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下： 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了 2.什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array 当数据量固定时或者多维度时，我们可以使用数组，而当我们可以根据需要自动扩充，修改数据时，应该使用list linklist和arraylist的区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 3.集合有哪些接口，他们有什么区别 Collection接口：单列集合，两个子接口 ①List接口：有序可重复 LinkedList：基于链表实现，每个元素储存本身内存地址还储存下一个元素的地址。（增删快，查找慢） ArrayList：基于数组实现，每次增删都要重新创建新的数组，但数组有索引。（增删慢，查找快） Vector：基于数组，线程安全相关，效率低。 ②Set接口：不可重复 HashSet: 储存的元素无序，不可重复，底层是哈希表 LinkedHashSet：储存元素有序，不可重复，底层是哈希表和链表的结合 TreeSet：可以指定一个顺序，对象存入之后会按照指定的顺序排序。 2 . Map接口：双列集合 HashMap：非线程安全，高效，支持null LinkedHashMap：是HashMap的一个子类，保存了记录的插入顺序 HashTable：线程安全，低效，不支持null TreeMap：能够把他保存的记录根据键排序，默认是键值的升序排序 4.重载和重写的区别 方法重载Overload： 1、同一个类中 2、方法名相同，参数列表不同（参数顺序、个数、类型） 3、方法返回值、访问修饰符任意 4、与方法的参数名无关 1234567891011121314151617181920//重载public void eat()&#123; System.out.println(&quot;我是干饭人&quot; ); &#125;// public int eat()&#123; 会报错// return 4;// &#125; //报错原因：参数类型和个数一样,返回值类型不同是不算重载的 //因为在调用方法的时候,我们还不知道方法的返回值类型,所以编译器无法区分你调用的是哪个方法。 public void eat(String name)&#123; System.out.println(&quot;我是干饭人:&quot;+name ); &#125; public void eat(String name,int age)&#123; System.out.println(&quot;我是干饭人:&quot;+name+&quot;我今年&quot;+age ); &#125; 方法重写Override： 1、有继承关系的子类中 2、方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值相同 3、访问修饰符，访问范围需要大于等于父类的访问范围 4、与方法的参数名无关 1234567891011121314//重载public class Father &#123; public void walk()&#123; System.out.println(&quot;我是父亲&quot;); &#125;&#125;public class Son extends Father &#123; @Override//方法重写 public void walk() &#123; System.out.println(&quot;我是儿子&quot;); &#125;&#125; 5.接口和抽象类的区别 A:成员的区别抽象类：构造方法：有构造方法，用于子类实例化使用。成员变量：可以是变量，也可以是常量。成员方法：可以是抽象的，也可以是非抽象的。 接口：构造方法：没有构造方法成员变量：只能是常量。默认修饰符：public static final成员方法：jdk1.7只能是抽象的。默认修饰符：public abstract (推荐：默认修饰符请自己永远手动给出)jdk1.8可以写以default和static开头的具体方法 B:类和接口的关系区别类与类：继承关系,只能单继承。可以多层继承。 类与接口：实现关系,可以单实现,也可以多实现。类还可以在继承一个类的同时实现多个接口。 接口与接口：继承关系,可以单继承,也可以多继承。 C:体现的理念不同抽象类里面定义的都是一个继承体系中的共性内容。接口是功能的集合,是一个体系额外的功能，是暴露出来的规则。 6.字符串转为json用什么接口 JSONObject jsonObject = JSON.parseObject(tt); fastjson 7.hashmap和hashset的区别及原理 HashSet是通过HasMap来实现的，HashMap的输入参数有Key、Value两个组成，在实现HashSet的时候，保持HashMap的Value为常量，相当于在HashMap中只对Key对象进行处理。HashMap的底层是一个数组结构，数组中的每一项对应了一个链表，这种结构称“链表散列”的数据结构，即数组和链表的结合体；也叫散列表、哈希表。 HahMap存储对象的过程如下①、对HahMap的Key调用hashCode()方法，返回int值，即对应的hashCode； ②、把此hashCode作为哈希表的索引，查找哈希表的相应位置，若当前位置内容为NULL，则把hashMap的Key、Value包装成Entry数组，放入当前位置； ③、若当前位置内容不为空，则继续查找当前索引处存放的链表，利用equals方法，找到Key相同的Entry数组，则用当前Value去替换旧的Value； ④、若未找到与当前Key值相同的对象，则把当前位置的链表后移（Entry数组持有一个指向下一个元素的引用），把新的Entry数组放到链表表头； HashSet存储对象的过程往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ， 然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。 情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。 情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次 ，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。 注意:现在Hashmap不是数组加链表实现，而是数组，链表，红黑树，链表节点数大于8时会从链表结构变成树结构。 123&gt;ConcurrentHashMap线程安全，锁部分Hashtable线程安全，锁全部上者效率更高 8.io有哪些类型 Java IO方式大体上可以分为三类，基于不同的io模型可以简单分为同步阻塞的BIO,同步非阻塞的NIO和异步非阻塞的AIO. BIO：Block IO 同步阻塞式 IO，就是咱们日常使用的传统 IO，它的特色是模式简单使用方便，并发处理能力低。 NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端经过 Channel(通道)通信，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操做基于事件和回调机制。 9.说说对耦合的理解 耦合就是模块与模块之间的联系程度 123高内聚，低耦合有什么好处呢？事实上，你会发现，短期来看，并没有很明显的好处，甚至会有一些人抱怨，“我这样写不行吗？有舍么问题？” “我写了十几年代码都是这样写的也没见有什么问题。”等等；还有个最重要的，这样甚至在短期内会影响系统的开发进度，因为高内聚，低耦合的系统对开发设计人员提出了更高的要求。高内聚，低耦合的好处体现在系统持续发展的过程中，高内聚，低耦合的系统具有更好的重用性，维护性，扩展性，可以更高效的完成系统的维护开发，持续的支持业务的发展，而不会成为业务发展的障碍。 123456789高内聚，低耦合是否意味着内聚越高越好，耦合越低越好？(内聚性，又称块内联系，指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。)（1）并不是内聚越高越好，耦合越低越好，真正好的设计是在高内聚和低耦合间进行平衡，也就是说高内聚和低耦合是冲突的。（2）最强的内聚莫过于一个类只写一个函数，这样内聚性绝对是最高的。但这会带来一个明显的问题：类的数量急剧增多，这样就导致了其它类的耦合特别多，于是整个设计就变成了“高内聚高耦合”了。由于高耦合，整个系统变动同样非常频繁。（3）对于耦合来说，最弱的耦合是一个类将所有的函数都包含了，这样类完全不依赖其它类，耦合性是最低的。但这样会带来一个明显的问题：内聚性很低，于是整个设计就变成了“低耦合低内聚”了。由于低内聚，整个类的变动同样非常频繁。（4）真正做到高内聚、低耦合是很难的，很多时候未必一定要这样，更多的时候“最适合”的才是最好的，不过、审时度势、融会贯通、人尽其才、物尽其用，才是设计的王道。 10.8大基本数据类型 1234567891011121314151617181920212223242526272829303132333435bytebyte属于Java中的整型，长度为1字节8bit，取值10000000（-128）到 01111111（127），变量初始化默认值为0，包装类Byteshortshort属于Java中的整型，长度为2字节16bit，取值10000000 00000000（-32768）到 01111111 11111111（32767），变量初始化默认值为0，包装类Shortintint属于Java中的整型，长度为4字节32bit，取值-2^31 （-2,147,483,648）到 2^31-1（2,147,483,647），变量初始化默认值为0，包装类Integerlonglong属于Java中的整型，长度为8字节64bit，取值-2^63 （-9,223,372,036,854,775,808‬）到 2^63-1（9,223,372,036,854,775,8087），变量初始化默认值为0或0L，包装类Longfloatfloat属于Java中的浮点型，也叫单精度浮点型，长度为4字节32bit，变量初始化默认值0.0f，包装类Floatdoubledouble属于Java中的浮点型，也叫双精度浮点型，长度为8字节64bit，变量初始化默认值0.0d，包装类Doublecharchar属于java中的字符型，占2字节16bit，可以赋值单字符以及整型数值, 变量初始化无默认值，包装类Character。boolean在JVM中并没有提供boolean专用的字节码指令，而boolean类型数据在经过编译后在JVM中会通过int类型来表示，此时boolean数据4字节32位，而boolean数组将会被编码成Java虚拟机的byte数组，此时每个boolean数据1字节占8bit.--Java虚拟机规范仅有两个值true, false，变量初始化默认值false 11.==和equal的区别 equal与== 1.最大的区别是，==是运算符，equal是方法 简述几种情况下的equal与== java基本类型比较包装类型比较String类型比较对象1.java基本类型（short，int，long，byte，char，float，double，boolean） 比较基本类型，只能用==，不能用equal，这里的==比较的是两个变量的值 2.比较包装类型 ==比较的是内存地址，因为a和b是new出来的，是两个不同的对象，所以地址肯定是不同的，而equal比较的是值. 123456public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; 3.比较String类型 ==比较的是内存地址，equal比较的是值 4.比较对象 ==和equal比较的都是内存地址，因为equal没有被重写，没有被重写的equal都是object的equal方法 12.String 与 StringBuffer 和 StringBuilder 的区别 String 是不可变的，而 StringBuffer 和 StringBuilder 是可变类。 StringBuffer 是线程安全和同步的，而 StringBuilder 不是。这就是 StringBuilder 比 StringBuffer 快的原因。 字符串连接运算符 (+) 在内部使用 StringBuilder 类。 对于非多线程环境中的字符串操作，我们应该使用 StringBuilder 否则使用 StringBuffer 类。 13.CopyOnWriteArrayList的底层原理 CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。 优点： 读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。Java的list在遍历时，若中途有别的线程对list容器进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的list容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了 缺点： 缺点也很明显，一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。 12345678910111213141516171819public boolean add(E e) &#123; //ReentrantLock加锁，保证线程安全 final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; //拷贝原容器，长度为原容器长度加一 Object[] newElements = Arrays.copyOf(elements, len + 1); //在新副本上执行添加操作 newElements[len] = e; //将原容器引用指向新副本 setArray(newElements); return true; &#125; finally &#123; //解锁 lock.unlock(); &#125; &#125; 14.深拷贝和浅拷贝的区别对于基本数据类型，两者都是值传递 对于引用数据类型，浅拷贝是地址拷贝，而深拷贝是创建一个新的对象，将值复制进去","categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"java基础","slug":"java基础","permalink":"https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://gwtt.github.io/tags/Git/"},{"name":"面试","slug":"面试","permalink":"https://gwtt.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Springboot","slug":"Springboot","permalink":"https://gwtt.github.io/tags/Springboot/"},{"name":"juc","slug":"juc","permalink":"https://gwtt.github.io/tags/juc/"},{"name":"java基础","slug":"java基础","permalink":"https://gwtt.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"消息队列","slug":"消息队列","permalink":"https://gwtt.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"分布式","slug":"分布式","permalink":"https://gwtt.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://gwtt.github.io/tags/Mybatis/"},{"name":"Redis","slug":"Redis","permalink":"https://gwtt.github.io/tags/Redis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://gwtt.github.io/tags/MySQL/"},{"name":"Jvm","slug":"Jvm","permalink":"https://gwtt.github.io/tags/Jvm/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gwtt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}