<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="滚~韬">


    <meta name="subtitle" content="滚~">


    <meta name="description" content="一个普通大学生的博客">



<title>Java面试基础（1） | 滚~韬的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/jquery-3.6.0.min.js"></script>
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- 搜索的部分 -->



    <script>
    // function searchToggle() {
    //     const width = $(document.body).width()
    //     if(width > 479) {
    //         return;
    //     }
    //     const search = $('.search');
    //     const searchForm = $('.form-search')

    //     if(!search.hasClass("mobile-search")) {
    //         search.addClass("mobile-search");
    //     } else {
    //         search.removeClass("mobile-search");
    //     } 
    // }

    function searchToggle() {
        const width = $(document.body).width()
        if(width > 479) {
            return;
        }
        const search = $('.search');
        const searchForm = $('.form-search');
        const menuToggle = $('.menu-toggle');
        const title = $('.navbar-header-title ');

        if(!search.hasClass("mobile-search")) {
            search.addClass("mobile-search");
            menuToggle.addClass("open-search")
            title.addClass("mobile-title-hidden")
        } else {
            search.removeClass("mobile-search");
            menuToggle.removeClass("open-search")
            // title.css({visibility: 'visible'})
            title.removeClass("mobile-title-hidden")
        } 
    }



    function search(searchInputEl, formEl, flag) {
        const path = "/" + "search.json"; // 可以在public 下查看这个search.json
        $(formEl).submit(function(e){
            e.preventDefault();
            let target = null
            if(searchInputEl == null) {
                const screenWidth = $(document.body).width();
                target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input');
                console.log(target);
            } else {
                target = $(searchInputEl)
            }

            if(!flag && target.val() === '') {
                return ;
            }

            $("#u-search").fadeIn(500, function() {
                $("body > .wrapper").addClass("modal-active");

                $.ajax({
                    url: path,
                    dataType: "json",
                    beforeSend: function (xhr) {
                        $input = target.val();
                        $(".form-input").val($input);
                        const loadingBar = $('.search-loading-bar') 
                        loadingBar.css({
                            width:'100%',
                            display: 'block'
                        });
                    },
                    success: function( datas ) {
                        console.log(datas);
                        const $resultPanel = $(".modal-body")[0];
                        let str = `<ul class="modal-results">`;
                        var keywords = $(".form-input").val().trim().toLowerCase().split(/[\s\-]+/);
                        $resultPanel.innerHTML = "";
                        let hasResult = false
                        let text = `<div class="no-result">找不到与关键词相关的内容....</div>`;

                        if ($(".form-input").val().trim().length <= 0) {
                            // 没有结果
                            $resultPanel.innerHTML = text;
                            return;
                        }
                        datas.forEach(function (data, index) {
                            var isMatch = true;
                            if (!data.title || data.title.trim() === '') {
                                data.title = "Untitled";
                            }
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content && data.content.trim().replace(/<[^>]+>/g, "").toLowerCase() || '';
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty contents
                            if (data_content !== '') {
                                keywords.forEach(function (keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);

                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        hasResult = true
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            } else {
                                isMatch = false;
                            }
                            // show search results
                            if (isMatch) {
                                str += `<li class='result-item'><a href='${data_url}' class='result-item-detail'> <span class="title">${data_title}</span>`;
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 200 characters
                                    var start = first_occur - 40;
                                    var end = first_occur + 160;

                                    if (start < 0) {
                                        start = 0;
                                    }

                                    if (start == 0) {
                                        end = 200;
                                    }

                                    if (end > content.length) {
                                        end = content.length;
                                    }

                                    var match_content = content.substring(start, end);

                                    // highlight all keywords
                                    keywords.forEach(function (keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, `<em class="search-keyword">${keyword}</em>`);
                                    });

                                    str += `<span class="content"> ${match_content} ...</span></a>`;
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        if(hasResult) {
                            $resultPanel.innerHTML = str;
                        } else {
                            $resultPanel.innerHTML = text;
                        }

                    },
                    complete: function() {
                        setTimeout(() => {
                                const loadingBar = $('.search-loading-bar') 
                                loadingBar.css({
                                    width:'0%',
                                    display: 'none'
                                });
                        }, 300)
                    }
                });
            })

        });
    }

    $(document).ready(function() {
        $('.modal-close').click(function () { 
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })

        $('.modal-overlay').click(function() {
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })
        search(null, ".form-search", false)
        search("#u-search-modal-form .form-input", ".u-search-modal-form", true)
    })
</script>



<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="滚~韬的博客" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();

    </script>
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
    <div class="container">
        <!-- <div class="navbar-header header-logo"><a href="/">滚~韬</a></div> -->
        <div class="navbar-header header-logo"><a href="/"><i class="iconfont icon-zhuye" style="font-size: 1em;"></i>滚~韬</a></div>
        <div class="menu navbar-right">
            <!-- 这里表示的是pc端搜索框 -->
            
            
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/2.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="点此搜索" autocomplete="off" id="pc-search-input"/>
        </form>
    </div>


            
            <a class="menu-item" href="/archives">文章</a>
            
            <a class="menu-item" href="/category">分类</a>
            
            <a class="menu-item" href="/tag">标签</a>
            
            <a class="menu-item" href="/about">关于</a>
            
            <input id="switch_default" type="checkbox" class="switch_default">
            <label for="switch_default" class="toggleBtn"></label>
        </div>
    </div>
</nav>


<nav class="navbar-mobile" id="nav-mobile">
    <div class="container">
        <div class="navbar-header">
            <div>
                <a href="/">滚~韬</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
            </div>
            <div class="navbar-mobile-right">
                
                
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/2.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="点此搜索" autocomplete="off" id="mobile-search-input"/>
        </form>
    </div>


                <div class="menu-toggle" onclick="mobileBtn()">&#9776; 目录</div>
            </div>

        </div>
        <div class="menu" id="mobile-menu">
            
            <a class="menu-item" href="/archives">文章</a>
            
            <a class="menu-item" href="/category">分类</a>
            
            <a class="menu-item" href="/tag">标签</a>
            
            <a class="menu-item" href="/about">关于</a>
            
        </div>
    </div>
</nav>


</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开所有</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前去底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java面试基础（1）</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">滚~韬</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">六月 11&nbsp;&nbsp;11:07</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类:
                            
                                <a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
                            
                        </span>
                    
			 

<span class="post-count">

字数:

<a href="">4.2k</a> 

</span>



 



<span class="post-count">

时间:

<a href="">15min</a> 

</span>


                </div>
            
        </header>

        <div class="post-content">
            <h2 id="java基础-1"><a href="#java基础-1" class="headerlink" title="java基础(1)"></a>java基础(1)</h2><h3 id="1-int和interger的区别"><a href="#1-int和interger的区别" class="headerlink" title="1.int和interger的区别"></a>1.int和interger的区别</h3><blockquote>
<ul>
<li><p>Integer是int的包装类；int是基本数据类型；</p>
</li>
<li><p>Integer变量必须实例化后才能使用；int变量不需要；</p>
</li>
<li><p>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</p>
</li>
<li><p>Integer的默认值是null；int的默认值是0。</p>
<p>延伸：<br>关于Integer和int的比较<br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>2、Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> i <span class="operator">=</span> <span class="keyword">new</span> <span class="type">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> j <span class="operator">=</span> <span class="number">100</span>；</span><br><span class="line">System.out.print(i <span class="operator">=</span><span class="operator">=</span> j); <span class="operator">/</span><span class="operator">/</span><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为 ①当变量值在-128到127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②当变量值不在-128到127之间时，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>对于第4条的原因：<br>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p>
</li>
</ul>
</blockquote>
<h3 id="2-什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array"><a href="#2-什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array" class="headerlink" title="2.什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array"></a>2.什么时候用list什么时候用数组，linklist和arraylist的区别以及什么时候用link什么时候用array</h3><blockquote>
<ul>
<li><p>当数据量固定时或者多维度时，我们可以使用数组，而当我们可以根据需要自动扩充，修改数据时，应该使用list</p>
<p>linklist和arraylist的区别</p>
</li>
<li><p>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 </p>
</li>
<li><p>对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。</p>
<p>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>
</li>
</ul>
</blockquote>
<h3 id="3-集合有哪些接口，他们有什么区别"><a href="#3-集合有哪些接口，他们有什么区别" class="headerlink" title="3.集合有哪些接口，他们有什么区别"></a>3.集合有哪些接口，他们有什么区别</h3><blockquote>
<p> Collection接口：单列集合，两个子接口<br> ①List接口：有序可重复<br> LinkedList：基于链表实现，每个元素储存本身内存地址还储存下一个元素的地址。（增删快，查找慢）</p>
<p> ArrayList：基于数组实现，每次增删都要重新创建新的数组，但数组有索引。（增删慢，查找快）</p>
<p> Vector：基于数组，线程安全相关，效率低。</p>
<p> ②Set接口：不可重复<br> HashSet: 储存的元素无序，不可重复，底层是哈希表</p>
<p> LinkedHashSet：储存元素有序，不可重复，底层是哈希表和链表的结合</p>
<p> TreeSet：可以指定一个顺序，对象存入之后会按照指定的顺序排序。</p>
<p> 2 . Map接口：双列集合<br> HashMap：非线程安全，高效，支持null</p>
<p> LinkedHashMap：是HashMap的一个子类，保存了记录的插入顺序</p>
<p> HashTable：线程安全，低效，不支持null</p>
<p> TreeMap：能够把他保存的记录根据键排序，默认是键值的升序排序</p>
</blockquote>
<h3 id="4-重载和重写的区别"><a href="#4-重载和重写的区别" class="headerlink" title="4.重载和重写的区别"></a>4.重载和重写的区别</h3><blockquote>
<p>方法重载Overload：</p>
<p>1、同一个类中</p>
<p>2、方法名相同，参数列表不同（参数顺序、个数、类型）</p>
<p>3、方法返回值、访问修饰符任意</p>
<p>4、与方法的参数名无关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;我是干饭人&quot;</span> );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public int eat()&#123;  会报错</span></span><br><span class="line"><span class="comment">//        return 4;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"> <span class="comment">//报错原因：参数类型和个数一样,返回值类型不同是不算重载的</span></span><br><span class="line"> <span class="comment">//因为在调用方法的时候,我们还不知道方法的返回值类型,所以编译器无法区分你调用的是哪个方法。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;我是干饭人:&quot;</span>+name );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;我是干饭人:&quot;</span>+name+<span class="string">&quot;我今年&quot;</span>+age );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法重写Override：</p>
<p>1、有继承关系的子类中</p>
<p>2、方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值相同</p>
<p>3、访问修饰符，访问范围需要大于等于父类的访问范围</p>
<p>4、与方法的参数名无关</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我是父亲&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span><span class="comment">//方法重写</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;我是儿子&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-接口和抽象类的区别"><a href="#5-接口和抽象类的区别" class="headerlink" title="5.接口和抽象类的区别"></a>5.接口和抽象类的区别</h3><blockquote>
<p>A:成员的区别<br>抽象类：<br>构造方法：有构造方法，用于子类实例化使用。<br>成员变量：可以是变量，也可以是常量。<br>成员方法：可以是抽象的，也可以是非抽象的。</p>
<p>接口：<br>构造方法：没有构造方法<br>成员变量：只能是常量。默认修饰符：public static final<br>成员方法：jdk1.7只能是抽象的。默认修饰符：public abstract (推荐：默认修饰符请自己永远手动给出)<br>jdk1.8可以写以default和static开头的具体方法</p>
<p>B:类和接口的关系区别<br>类与类：<br>继承关系,只能单继承。可以多层继承。</p>
<p>类与接口：<br>实现关系,可以单实现,也可以多实现。<br>类还可以在继承一个类的同时实现多个接口。</p>
<p>接口与接口：<br>继承关系,可以单继承,也可以多继承。</p>
<p>C:体现的理念不同<br>抽象类里面定义的都是一个继承体系中的共性内容。<br>接口是功能的集合,是一个体系额外的功能，是暴露出来的规则。</p>
</blockquote>
<h3 id="6-字符串转为json用什么接口"><a href="#6-字符串转为json用什么接口" class="headerlink" title="6.字符串转为json用什么接口"></a>6.字符串转为json用什么接口</h3><blockquote>
<p>JSONObject jsonObject = JSON.parseObject(tt);</p>
<p>fastjson</p>
</blockquote>
<h3 id="7-hashmap和hashset的区别及原理"><a href="#7-hashmap和hashset的区别及原理" class="headerlink" title="7.hashmap和hashset的区别及原理"></a>7.hashmap和hashset的区别及原理</h3><blockquote>
<p>HashSet是通过HasMap来实现的，HashMap的输入参数有Key、Value两个组成，在实现HashSet的时候，保持HashMap的Value为常量，相当于在HashMap中只对Key对象进行处理。<br>HashMap的底层是一个数组结构，数组中的每一项对应了一个链表，这种结构称“链表散列”的数据结构，即数组和链表的结合体；也叫散列表、哈希表。</p>
<p>HahMap存储对象的过程如下<br>①、对HahMap的Key调用hashCode()方法，返回int值，即对应的hashCode；</p>
<p>②、把此hashCode作为哈希表的索引，查找哈希表的相应位置，若当前位置内容为NULL，则把hashMap的Key、Value包装成Entry数组，放入当前位置；</p>
<p>③、若当前位置内容不为空，则继续查找当前索引处存放的链表，利用equals方法，找到Key相同的Entry数组，则用当前Value去替换旧的Value；</p>
<p>④、若未找到与当前Key值相同的对象，则把当前位置的链表后移（Entry数组持有一个指向下一个元素的引用），把新的Entry数组放到链表表头；</p>
<p>HashSet存储对象的过程<br>往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，</p>
<p>然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中 的存储位置。</p>
<p>情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。</p>
<p>情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次</p>
<p>，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加。</p>
<p>注意:现在Hashmap不是数组加链表实现，而是数组，链表，红黑树，链表节点数大于8时会从链表结构变成树结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;ConcurrentHashMap线程安全，锁部分</span><br><span class="line">Hashtable线程安全，锁全部</span><br><span class="line">上者效率更高</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="8-io有哪些类型"><a href="#8-io有哪些类型" class="headerlink" title="8.io有哪些类型"></a>8.io有哪些类型</h3><blockquote>
<p>Java IO方式大体上可以分为三类，基于不同的io模型可以简单分为同步阻塞的BIO,同步非阻塞的NIO和异步非阻塞的AIO.</p>
<p>BIO：Block IO 同步阻塞式 IO，就是咱们日常使用的传统 IO，它的特色是模式简单使用方便，并发处理能力低。</p>
<p>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端经过 Channel(通道)通信，实现了多路复用。</p>
<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操做基于事件和回调机制。</p>
</blockquote>
<h3 id="9-说说对耦合的理解"><a href="#9-说说对耦合的理解" class="headerlink" title="9.说说对耦合的理解"></a>9.说说对耦合的理解</h3><blockquote>
<p>耦合就是模块与模块之间的联系程度</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高内聚，低耦合有什么好处呢？</span><br><span class="line"></span><br><span class="line">事实上，你会发现，短期来看，并没有很明显的好处，甚至会有一些人抱怨，“我这样写不行吗？有舍么问题？” “我写了十几年代码都是这样写的也没见有什么问题。”等等；还有个最重要的，这样甚至在短期内会影响系统的开发进度，因为高内聚，低耦合的系统对开发设计人员提出了更高的要求。高内聚，低耦合的好处体现在系统持续发展的过程中，高内聚，低耦合的系统具有更好的重用性，维护性，扩展性，可以更高效的完成系统的维护开发，持续的支持业务的发展，而不会成为业务发展的障碍。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">高内聚，低耦合是否意味着内聚越高越好，耦合越低越好？</span><br><span class="line">(内聚性，又称块内联系，指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。)</span><br><span class="line">（1）并不是内聚越高越好，耦合越低越好，真正好的设计是在高内聚和低耦合间进行平衡，也就是说高内聚和低耦合是冲突的。</span><br><span class="line"></span><br><span class="line">（2）最强的内聚莫过于一个类只写一个函数，这样内聚性绝对是最高的。但这会带来一个明显的问题：类的数量急剧增多，这样就导致了其它类的耦合特别多，于是整个设计就变成了“高内聚高耦合”了。由于高耦合，整个系统变动同样非常频繁。</span><br><span class="line"></span><br><span class="line">（3）对于耦合来说，最弱的耦合是一个类将所有的函数都包含了，这样类完全不依赖其它类，耦合性是最低的。但这样会带来一个明显的问题：内聚性很低，于是整个设计就变成了“低耦合低内聚”了。由于低内聚，整个类的变动同样非常频繁。</span><br><span class="line"></span><br><span class="line">（4）真正做到高内聚、低耦合是很难的，很多时候未必一定要这样，更多的时候“最适合”的才是最好的，不过、审时度势、融会贯通、人尽其才、物尽其用，才是设计的王道。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="10-8大基本数据类型"><a href="#10-8大基本数据类型" class="headerlink" title="10.8大基本数据类型"></a>10.8大基本数据类型</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">byte</span><br><span class="line"></span><br><span class="line">byte属于Java中的整型，长度为1字节8bit，取值10000000（-128）到 01111111（127），变量初始化默认值为0，包装类Byte</span><br><span class="line"></span><br><span class="line">short</span><br><span class="line"></span><br><span class="line">short属于Java中的整型，长度为2字节16bit，取值10000000 00000000（-32768）到 01111111 11111111（32767），变量初始化默认值为0，包装类Short</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line"></span><br><span class="line">int属于Java中的整型，长度为4字节32bit，取值-2^31 （-2,147,483,648）到 2^31-1（2,147,483,647），变量初始化默认值为0，包装类Integer</span><br><span class="line"></span><br><span class="line">long</span><br><span class="line"></span><br><span class="line">long属于Java中的整型，长度为8字节64bit，取值-2^63 （-9,223,372,036,854,775,808‬）到 2^63-1（9,223,372,036,854,775,8087），变量初始化默认值为0或0L，包装类Long</span><br><span class="line"></span><br><span class="line">float</span><br><span class="line"></span><br><span class="line">float属于Java中的浮点型，也叫单精度浮点型，长度为4字节32bit，变量初始化默认值0.0f，包装类Float</span><br><span class="line"></span><br><span class="line">double</span><br><span class="line"></span><br><span class="line">double属于Java中的浮点型，也叫双精度浮点型，长度为8字节64bit，变量初始化默认值0.0d，包装类Double</span><br><span class="line"></span><br><span class="line">char</span><br><span class="line"></span><br><span class="line">char属于java中的字符型，占2字节16bit，可以赋值单字符以及整型数值, 变量初始化无默认值，包装类Character。</span><br><span class="line"></span><br><span class="line">boolean</span><br><span class="line"></span><br><span class="line">在JVM中并没有提供boolean专用的字节码指令，而boolean类型数据在经过编译后在JVM中会通过int类型来表示，此时boolean数据4字节32位，而boolean数组将会被编码成Java虚拟机的byte数组，此时每个boolean数据1字节占8bit.</span><br><span class="line"></span><br><span class="line">--Java虚拟机规范</span><br><span class="line"></span><br><span class="line">仅有两个值true, false，变量初始化默认值false</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="11-和equal的区别"><a href="#11-和equal的区别" class="headerlink" title="11.==和equal的区别"></a>11.==和equal的区别</h3><blockquote>
<p>equal与==</p>
<p>1.最大的区别是，==是运算符，equal是方法</p>
<p>简述几种情况下的equal与==</p>
<p>java基本类型<br>比较包装类型<br>比较String类型<br>比较对象<br>1.java基本类型（short，int，long，byte，char，float，double，boolean）</p>
<p>比较基本类型，只能用==，不能用equal，这里的==比较的是两个变量的值</p>
<p>2.比较包装类型</p>
<p>==比较的是内存地址，因为a和b是new出来的，是两个不同的对象，所以地址肯定是不同的，而equal比较的是值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">      <span class="type">return</span> <span class="variable">value</span> <span class="operator">=</span>= ((Integer)obj).intValue();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.比较String类型</p>
<p>==比较的是内存地址，equal比较的是值</p>
<p>4.比较对象</p>
<p>==和equal比较的都是内存地址，因为equal没有被重写，没有被重写的equal都是object的equal方法</p>
</blockquote>
<h3 id="12-String-与-StringBuffer-和-StringBuilder-的区别"><a href="#12-String-与-StringBuffer-和-StringBuilder-的区别" class="headerlink" title="12.String 与 StringBuffer 和 StringBuilder 的区别"></a>12.String 与 StringBuffer 和 StringBuilder 的区别</h3><blockquote>
<ul>
<li>String 是不可变的，而 StringBuffer 和 StringBuilder 是可变类。</li>
<li>StringBuffer 是线程安全和同步的，而 StringBuilder 不是。这就是 StringBuilder 比 StringBuffer 快的原因。</li>
<li>字符串连接运算符 (+) 在内部使用 StringBuilder 类。</li>
<li>对于非多线程环境中的字符串操作，我们应该使用 StringBuilder 否则使用 StringBuffer 类。</li>
</ul>
</blockquote>
<h3 id="13-CopyOnWriteArrayList的底层原理"><a href="#13-CopyOnWriteArrayList的底层原理" class="headerlink" title="13.CopyOnWriteArrayList的底层原理"></a>13.CopyOnWriteArrayList的底层原理</h3><blockquote>
<p><strong>CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</strong></p>
<p><strong>优点：</strong></p>
<p>　　读操作性能很高，因为无需任何同步措施，比较适用于<strong>读多写少</strong>的并发场景。Java的list在遍历时，若中途有别的线程对list容器进行修改，则会抛出<strong>ConcurrentModificationException</strong>异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的list容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了</p>
<p><strong>缺点：</strong></p>
<p>　　缺点也很明显，<strong>一是内存占用问题</strong>，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；<strong>二是无法保证实时性</strong>，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">     <span class="comment">//ReentrantLock加锁，保证线程安全</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Object[] elements = getArray();</span><br><span class="line">         <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">         <span class="comment">//拷贝原容器，长度为原容器长度加一</span></span><br><span class="line">         Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">         <span class="comment">//在新副本上执行添加操作</span></span><br><span class="line">         newElements[len] = e;</span><br><span class="line">         <span class="comment">//将原容器引用指向新副本</span></span><br><span class="line">         setArray(newElements);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//解锁</span></span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="14-深拷贝和浅拷贝的区别"><a href="#14-深拷贝和浅拷贝的区别" class="headerlink" title="14.深拷贝和浅拷贝的区别"></a>14.深拷贝和浅拷贝的区别</h3><p>对于基本数据类型，两者都是值传递</p>
<p>对于引用数据类型，浅拷贝是地址拷贝，而深拷贝是创建一个新的对象，将值复制进去</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%9D%A2%E8%AF%95/"># 面试</a>
                    
                        <a href="/tags/java%E5%9F%BA%E7%A1%80/"># java基础</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">后退</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/06/11/Juc%E9%9D%A2%E8%AF%95(1)/">Juc面试(1)</a>
            
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 滚~韬 | Powered by <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
<!-- 搜索功能 -->
<!-- Chic/layout.ejs -->
<div id="u-search">
    <div class="modal">
        <div class="modal-header">
            <div class="container">
                <form id="u-search-modal-form" class="u-search-modal-form">
                    <button type="submit" class="form-submit-btn">
                        <img src="/image/2.png" class="search-btn-img" />
                    </button>
                    <input placeholder="搜索内容..." class="form-input" id="modal-form-input">
                </form>
                <a class="modal-close">x</a>
            </div>
            <div class="search-loading">
                <div class="search-loading-bar"></div>
            </div>
        </div>
        <div class="modal-body">
        </div>
    </div>
    <div class="modal-overlay"></div>
</div>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>


</html>