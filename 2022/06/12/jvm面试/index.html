<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="滚~韬">


    <meta name="subtitle" content="滚~">


    <meta name="description" content="一个普通大学生的博客">



<title>Jvm面试 | 滚~韬的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/jquery-3.6.0.min.js"></script>
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- 搜索的部分 -->



    <script>
    // function searchToggle() {
    //     const width = $(document.body).width()
    //     if(width > 479) {
    //         return;
    //     }
    //     const search = $('.search');
    //     const searchForm = $('.form-search')

    //     if(!search.hasClass("mobile-search")) {
    //         search.addClass("mobile-search");
    //     } else {
    //         search.removeClass("mobile-search");
    //     } 
    // }

    function searchToggle() {
        const width = $(document.body).width()
        if(width > 479) {
            return;
        }
        const search = $('.search');
        const searchForm = $('.form-search');
        const menuToggle = $('.menu-toggle');
        const title = $('.navbar-header-title ');

        if(!search.hasClass("mobile-search")) {
            search.addClass("mobile-search");
            menuToggle.addClass("open-search")
            title.addClass("mobile-title-hidden")
        } else {
            search.removeClass("mobile-search");
            menuToggle.removeClass("open-search")
            // title.css({visibility: 'visible'})
            title.removeClass("mobile-title-hidden")
        } 
    }



    function search(searchInputEl, formEl, flag) {
        const path = "/" + "search.json"; // 可以在public 下查看这个search.json
        $(formEl).submit(function(e){
            e.preventDefault();
            let target = null
            if(searchInputEl == null) {
                const screenWidth = $(document.body).width();
                target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input');
                console.log(target);
            } else {
                target = $(searchInputEl)
            }

            if(!flag && target.val() === '') {
                return ;
            }

            $("#u-search").fadeIn(500, function() {
                $("body > .wrapper").addClass("modal-active");

                $.ajax({
                    url: path,
                    dataType: "json",
                    beforeSend: function (xhr) {
                        $input = target.val();
                        $(".form-input").val($input);
                        const loadingBar = $('.search-loading-bar') 
                        loadingBar.css({
                            width:'100%',
                            display: 'block'
                        });
                    },
                    success: function( datas ) {
                        console.log(datas);
                        const $resultPanel = $(".modal-body")[0];
                        let str = `<ul class="modal-results">`;
                        var keywords = $(".form-input").val().trim().toLowerCase().split(/[\s\-]+/);
                        $resultPanel.innerHTML = "";
                        let hasResult = false
                        let text = `<div class="no-result">找不到与关键词相关的内容....</div>`;

                        if ($(".form-input").val().trim().length <= 0) {
                            // 没有结果
                            $resultPanel.innerHTML = text;
                            return;
                        }
                        datas.forEach(function (data, index) {
                            var isMatch = true;
                            if (!data.title || data.title.trim() === '') {
                                data.title = "Untitled";
                            }
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content && data.content.trim().replace(/<[^>]+>/g, "").toLowerCase() || '';
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty contents
                            if (data_content !== '') {
                                keywords.forEach(function (keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);

                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        hasResult = true
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            } else {
                                isMatch = false;
                            }
                            // show search results
                            if (isMatch) {
                                str += `<li class='result-item'><a href='${data_url}' class='result-item-detail'> <span class="title">${data_title}</span>`;
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 200 characters
                                    var start = first_occur - 40;
                                    var end = first_occur + 160;

                                    if (start < 0) {
                                        start = 0;
                                    }

                                    if (start == 0) {
                                        end = 200;
                                    }

                                    if (end > content.length) {
                                        end = content.length;
                                    }

                                    var match_content = content.substring(start, end);

                                    // highlight all keywords
                                    keywords.forEach(function (keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, `<em class="search-keyword">${keyword}</em>`);
                                    });

                                    str += `<span class="content"> ${match_content} ...</span></a>`;
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        if(hasResult) {
                            $resultPanel.innerHTML = str;
                        } else {
                            $resultPanel.innerHTML = text;
                        }

                    },
                    complete: function() {
                        setTimeout(() => {
                                const loadingBar = $('.search-loading-bar') 
                                loadingBar.css({
                                    width:'0%',
                                    display: 'none'
                                });
                        }, 300)
                    }
                });
            })

        });
    }

    $(document).ready(function() {
        $('.modal-close').click(function () { 
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })

        $('.modal-overlay').click(function() {
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })
        search(null, ".form-search", false)
        search("#u-search-modal-form .form-input", ".u-search-modal-form", true)
    })
</script>



<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="滚~韬的博客" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();

    </script>
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
    <div class="container">
        <!-- <div class="navbar-header header-logo"><a href="/">滚~韬</a></div> -->
        <div class="navbar-header header-logo"><a href="/"><i class="iconfont icon-zhuye" style="font-size: 1em;"></i>滚~韬</a></div>
        <div class="menu navbar-right">
            <!-- 这里表示的是pc端搜索框 -->
            
            
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/2.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="点此搜索" autocomplete="off" id="pc-search-input"/>
        </form>
    </div>


            
            <a class="menu-item" href="/archives">文章</a>
            
            <a class="menu-item" href="/category">分类</a>
            
            <a class="menu-item" href="/tag">标签</a>
            
            <a class="menu-item" href="/about">关于</a>
            
            <input id="switch_default" type="checkbox" class="switch_default">
            <label for="switch_default" class="toggleBtn"></label>
        </div>
    </div>
</nav>


<nav class="navbar-mobile" id="nav-mobile">
    <div class="container">
        <div class="navbar-header">
            <div>
                <a href="/">滚~韬</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
            </div>
            <div class="navbar-mobile-right">
                
                
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/2.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="点此搜索" autocomplete="off" id="mobile-search-input"/>
        </form>
    </div>


                <div class="menu-toggle" onclick="mobileBtn()">&#9776; 目录</div>
            </div>

        </div>
        <div class="menu" id="mobile-menu">
            
            <a class="menu-item" href="/archives">文章</a>
            
            <a class="menu-item" href="/category">分类</a>
            
            <a class="menu-item" href="/tag">标签</a>
            
            <a class="menu-item" href="/about">关于</a>
            
        </div>
    </div>
</nav>


</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开所有</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前去底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6;    // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function () {
            tocbot.refresh(obj_merge(tocbot_default_config, { hasInnerContainers: true }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function () {
        tocbot.init(obj_merge(tocbot_default_config, { collapseDepth: 1 }));
    });

    function expandToc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, { collapseDepth: expanded ? 1 : DEPTH_MAX }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Jvm面试</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">滚~韬</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">六月 12&nbsp;&nbsp;23:08</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类:
                            
                                <a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
                            
                        </span>
                    

			 

<span class="post-count">

字数:

<a href="">5.5k</a> 

</span>



 



<span class="post-count">

时间:

<a href="">19min</a> 

</span>


                </div>
            
        </header>

        <div class="post-content">
            <h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="1-JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？"><a href="#1-JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？" class="headerlink" title="1.JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？"></a>1.<strong>JVM运行时划分哪几个区域？哪些区域是线程共享的？哪些区域是线程独占的？</strong></h3><blockquote>
<p>JVM运行时一共划分：程序计数器、虚拟机栈、堆、本地方法栈、方法区。</p>
<p>线程共享的数据区域：堆、方法区。</p>
<p>线程独享的数据区域区域：程序计数器、虚拟机栈、本地方法栈。</p>
<h3 id="连问（1）这几个内存区域分别存放什么数据？"><a href="#连问（1）这几个内存区域分别存放什么数据？" class="headerlink" title="连问（1）这几个内存区域分别存放什么数据？"></a>连问（1）<strong>这几个内存区域分别存放什么数据？</strong></h3><blockquote>
<p><strong>程序计数器</strong>: 记录当前线程执行的位置</p>
<p><strong>虚拟机栈</strong>: 存储基本数据类型以及对象的引用等</p>
<p><strong>堆</strong>: 存储对象实例</p>
<p><strong>本地方法栈</strong>: 与虚拟机栈类似，它为Native方法服务</p>
<p><strong>方法区</strong>: 存储被JVM加载的类信息、常量、静态变量等。</p>
</blockquote>
</blockquote>
<h3 id="2-JVM内存怎么分配的"><a href="#2-JVM内存怎么分配的" class="headerlink" title="2.JVM内存怎么分配的"></a>2.JVM内存怎么分配的</h3><blockquote>
<p>方法区:</p>
<p>有时候也称为永久代（Permanent Generation）</p>
<p><em><strong>注意: 在Java8中，永久代已经被移除，被一个称为“元数据区”(元空间)的区域所取代。</strong></em> </p>
<p><em><strong>方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。</strong></em></p>
<blockquote>
<p>在方法区中，存储了每个类的信息（包括类的名称、修饰符、方法信息、字段信息）、类中静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息以及编译器编译后的代码等。当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，在这里进行的GC主要是方法区里的常量池和类型的卸载。当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。</p>
<p>在方法区中有一个非常重要的部分就是运行时常量池，用于存放静态编译产生的字面量和符号引用。运行时生成的常量也会存在这个常量池中，比如String的intern方法。它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。</p>
</blockquote>
<p>JVM堆分代</p>
<blockquote>
<p>1、JVM堆被分为了年轻代和老年代。年轻代的GC过程称为Yong GC，速度快较频繁。老年代的GC过程称为Full GC，速度较慢应该尽量避免。</p>
<p>2、对象被创建后，除了少部分大对象会在老年代分配内存外，大部分的对象首先都是在年轻代进行内存分配，而且大部分的对象都是“朝生夕死”，很快就会被年轻代的Yong GC回收掉。</p>
<p>3、老年代的内存空间一般会比年轻代的内存空间大，能存放的对象多，老年代的空间不足后会进行Full GC操作，比Yong GC耗时，所以应尽量避免频繁的Full GC操作。</p>
</blockquote>
<p>年轻代的分区</p>
<blockquote>
<p>1、年轻代中分为一个Eden区和两个Surviver区，比例为8：1：1，两个Surviver区分别称为“From”区和“To”区。对象在Eden区创建，经过一次Yong GC后，还存活的对象将会被复制到Surviver区的“From”区，此时“To”区是空的。到了下一次GC的时候，Eden区还存活的对象会复制到Surviver区的“To”区，而“Form”区的对象有两个去处，“From”区的对象会根据经过的GC次数计算年龄，如果年龄到达了阈值（默认15），则会被移动到老年代中，否则就复制到“To”区，此时“From”区变成了空的，然后“From”区和“To”区进行角色互换，到下一次进行GC时，还是有一块空的“To”区，用来存放从eden区和“From”区移动过来的对象。</p>
<p>2、那这种分区有什么好处呢？</p>
<p>a、在年轻代新增Surviver区，有利于减轻老年代的负担，尽可能的让大部分对象在年轻代通过较高效的Yong GC回收掉，不至于老年代里存放的对象过多导致内存不足而进行频繁的Full GC操作。</p>
<p>b、这种分区有利于减少内存碎片的产生。</p>
<p>首先我们来看看，如果年轻代只分为Eden区和Surviver区两个区域并且比例是8:2的时候，内存的回收和分配情况会怎么样。第一次Yong GC后，Eden区还存活的对象移动到Surviver区，Surviver区还存活的对象保留在Surviver区，而这些对象的内存是不连续的，Surviver区里就会产生很多内存碎片，这就会导致有些大对象要移动到Surviver区的时候，没有足够的连续内存进行分配，而不得不移动到老年代中，增加老年代的负担，降低效率。</p>
<p>然后我们看看Eden区和Surviver区的比例是8:1:1时会有什么样的效果。第一次Yong GC后，Eden区还存活的对象复制到Surviver区的“To”区，“From”区还存活的对象也复制到“To”区，再清空Eden区和From区，这样就等于“From”区完全是空的了，而“To”区也不会有内存碎片产生，等到第二次Yong GC时，“From”区和“To”区角色互换，很好的解决了内存碎片的问题。</p>
<h4 id="详细的过程："><a href="#详细的过程：" class="headerlink" title="详细的过程："></a>详细的过程：</h4><p>1.当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次<em><strong>YoungGC</strong></em>，也就是<em><strong>年轻代的垃圾回收</strong></em>。</p>
<p>一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。</p>
<p>2.这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，<strong>会将Eden区与From区还在被使用的对象复制到To区</strong>，</p>
<p>3.再下一次YoungGC的时候，<strong>则是将Eden区与To区中的还在被使用的对象复制到From区</strong>。</p>
<p>4.经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。</p>
<p><img src="/2022/06/12/jvm%E9%9D%A2%E8%AF%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlZXJsZXNzX2Z1,size_16,color_FFFFFF,t_70.png" alt="img"></p>
</blockquote>
</blockquote>
<h3 id="3-JVM怎么回收内存，gc机制是什么"><a href="#3-JVM怎么回收内存，gc机制是什么" class="headerlink" title="3.JVM怎么回收内存，gc机制是什么?"></a>3.JVM怎么回收内存，gc机制是什么?</h3><blockquote>
<p>垃圾收集需要完成的三件事情：</p>
<ul>
<li><p>哪些内存需要回收？</p>
<blockquote>
<p>程序计数器，虚拟机栈和本地方法栈都是随线程而生，随线程而灭。 栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的因此这几个区域的内存分配和回收都具备确定性，<strong>在这几个区域内就不需要过多考虑如何回收的问题</strong>， 当方法结束或者线程结束时， 内存自然就跟随着回收了。</p>
<p>而Java堆和方法区这两个区域则有着很显著的不确定性： 一个接口的多个实现类需要的内存可能会不一样， 一个方法所执行的不同条件分支所需要的内存也可能不一样， 只有处于运行期间， 我们才能知道程序究竟会创建哪些对象， 创建多少个对象， 这部分内存的分配和回收是动态的。 因此，垃圾收集器所关注的正是这部分内存该如何管理。</p>
</blockquote>
</li>
<li><p>什么时候回收？ 哪些还“存活”着， 哪些已经“死去”了。</p>
<blockquote>
<p>判断对象是否死去通常有两种方法：引用计数算法和可达性分析算法。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法：在对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加一； 当引用失效时， 计数器值就减一； 任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>优点:</p>
<ul>
<li>原理简单，<strong>判断</strong>效率高</li>
<li>实时性，<strong>任何内存，一旦没有指向它的引用，就会立即被回收</strong>。</li>
</ul>
<p>缺点:</p>
<ul>
<li>内存分配和释放次数变多，维护引用计数代价越高（执行效率低）</li>
<li>循环引用不能去使用（关键缺点）</li>
</ul>
<p>在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是这个看似简单的算法<strong>有很多例外情况要考虑</strong>，必须要配合大量额外处理才能保证正确地工作。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法：通过一系列称为“GC Roots”的根对象作为起始节点集， 从这些节点开始， 根据引用关系向下搜索， 搜索过程所走过的路径称为“引用链”（Reference Chain） ，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。</p>
<p>如下图所示， 对象object 5、 object 6、 object 7虽然互有关联， 但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p>
<p><img src="/2022/06/12/jvm%E9%9D%A2%E8%AF%95/Users\12136\Desktop\blog\source_posts\jvm面试.assets\30fd6c9f4f6645d21928035233adbed9.png" alt="image.png"></p>
<p>在Java技术体系里面， 固定可作为GC Roots的对象包括以下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在虚拟机栈（栈帧中的本地变量表）中引用的对象， 譬如，各个线程被调用的方法堆栈中使用到的参数、 局部变量、 临时变量等。</span><br><span class="line">在方法区中类静态属性引用的对象， 譬如，Java类的引用类型静态变量。</span><br><span class="line">在方法区中常量引用的对象， 譬如，字符串常量池（String Table）里的引用。</span><br><span class="line">在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</span><br><span class="line">Java虚拟机内部的引用，如，基本数据类型对应的Class对象， 一些常驻的异常对象（比如NullPointExcepiton、 OutOfMemoryError）等， 还有系统类加载器。</span><br><span class="line">所有被同步锁（<span class="keyword">synchronized</span>关键字）持有的对象。</span><br><span class="line">反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、本地代码缓存等。</span><br></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p>如何回收？</p>
<blockquote>
<p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段。</p>
<p>这边就要用到垃圾收集算法</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它是最基础的收集算法，因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p>
<p>缺点:</p>
<ul>
<li>标记和清除过程的效率都不高</li>
<li>标记清除之后会产生大量的不连续的内存碎片，分配较大对象无法找到连续内存不得不触发另一次垃圾回收</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200520095343831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3NTU0Mg==,size_16,color_FFFFFF,t_70" alt="标记-清除算法执行过程"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，一种称为“复制”的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用一块。当这块内存用完了。就将还活着的对象复制到另一块上面，然后再把已经用过的内存空间一次清理掉。这样使得每次都是对其中一块内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免也太高了一点。</p>
<p>如图所示，“<strong>半区域复制</strong>”这样实现的垃圾回收算法缺点显而易见<br>（1）内存利用效率太低，只能利用一半的内存<br>（2）如果内存中出现对象大都是存活的情况，将会产生大量内存间复制的开销</p>
<p><img src="https://img-blog.csdnimg.cn/20200520101309851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3NTU0Mg==,size_16,color_FFFFFF,t_70" alt="复制算法执行过程"></p>
<p>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更为优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。<br>  具体做法就是，把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生内存收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已使用过的那一块Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小默认时8:1，也即每次新生代中可用内存空间为整个新生代容量的90%，只有另一个Survivor空间，即10%的新生代是“浪费”的。如图：<br><img src="https://img-blog.csdnimg.cn/01ad068083f7434490866dd0e8399fc3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbG9yZGt5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对内存中被使用的所有的对象都100%存活的极端情况，<strong>所以在老年代一般不能直接选用这种算法。</strong><br>根据老年代的特点，有人提出了一种“标记-整理“算法，标记过程仍然与”标记-清除“算法一样，但是后续步骤不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。<br><img src="https://img-blog.csdnimg.cn/20200520110040232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3NTU0Mg==,size_16,color_FFFFFF,t_70" alt="标记-整理算法执行过程"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾回收都采用”分代收集“算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为老年代和新生代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批的对象死去，只有少量存活，那就选用复制算法，只需要付出少量的存活对象的复制成本就可以完成收集。而老年代中因为对象的存活率高、没有额外的空间对他进行分配担保，就必须使用”标记-整理“或者”标记-清理“算法来进行回收。</p>
<p>（1） 年轻代(Young Gen)</p>
<p>年轻代特点是区域相对老年代较小，对像存活率低。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<p>（2） 老年代(Tenure Gen)</p>
<p>老年代的特点是区域较大，对像存活率高。</p>
<p>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</p>
<p>Mark阶段的开销与存活对像的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。</p>
<p>Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</p>
<p>Compact阶段的开销与存活对像的数据成开比，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。</p>
<p>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<h4 id="总结：没有最好的算法，只有最合适的算法"><a href="#总结：没有最好的算法，只有最合适的算法" class="headerlink" title="总结：没有最好的算法，只有最合适的算法"></a>总结：没有最好的算法，只有最合适的算法</h4></blockquote>
</li>
</ul>
</blockquote>
<h3 id="4-static变量的初始化前后在jvm内存中的位置？"><a href="#4-static变量的初始化前后在jvm内存中的位置？" class="headerlink" title="4.static变量的初始化前后在jvm内存中的位置？"></a>4.static变量的初始化前后在jvm内存中的位置？</h3><blockquote>
<p>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。</p>
<p>静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</p>
</blockquote>
<h3 id="5-Java方法调用在jvm中是怎样的过程-方法栈、入参、返回值"><a href="#5-Java方法调用在jvm中是怎样的过程-方法栈、入参、返回值" class="headerlink" title="5.Java方法调用在jvm中是怎样的过程(方法栈、入参、返回值)"></a>5.Java方法调用在jvm中是怎样的过程(方法栈、入参、返回值)</h3><blockquote>
<p>方法（Java中称为方法，其他语言一般称为函数）调用主要是通过栈来存储相关的数据，系统就方法调用者和方法如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回值存储器来存储的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sum</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a * b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> Sum.sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当程序在 main 方法调用 Sum.sum 之前，栈的情况大概如图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/16766bef159f43a7588afbfb06017327.png" alt="调用Sum.sum之前的栈示意图"></p>
<p>在 main 方法调用 Sum.sum 时，首先将参数 1 和 2 入栈，然后将返回地址（也就是调用方法结束后要执行的指令地址）入栈，<br>接着跳转到 sum 函数，在 sum 函数内部，需要为局部变量 c 分配一个空间，而参数变量 a 和 b 则直接对应于入栈的数据 1 和 2，在返回之前，返回值保存到了专门的返回值存储器中。</p>
<p>在调用 return 后，程序会跳转到栈中保存的返回地址，即 main 的一条指令地址，而 sum 函数相关的数据会出栈，从而又变回上图中的样子。</p>
<p>main 的下一条指令是根据方法返回值给变量 d 赋值，返回值从专门的返回值存储器中获得。<br><img src="https://img-blog.csdnimg.cn/img_convert/1f0d23ad1a920bd0cf2889940087e568.png" alt="在Sum.sum内部，准备返回之前的栈示意图"></p>
<h3 id="程序执行的基本原理"><a href="#程序执行的基本原理" class="headerlink" title="程序执行的基本原理"></a>程序执行的基本原理</h3><p>CPU有一个指令指示器，指向下一条要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。</p>
<p>具体到Java程序来说就是，程序从 main 方法开始顺序执行，方法调用可以看作一个无条件跳转，跳转到对应方法的指令处开始执行，<br>碰到 return 语句或者方法结尾的时候，再执行一次无条件跳转， 跳转回调用方，执行调用方法后的下一条指令。</p>
</blockquote>
<h3 id="6-如果一个程序频繁触发Full-GC，原因可能是什么？"><a href="#6-如果一个程序频繁触发Full-GC，原因可能是什么？" class="headerlink" title="6.如果一个程序频繁触发Full GC，原因可能是什么？"></a>6.如果一个程序频繁触发Full GC，原因可能是什么？</h3><blockquote>
<p>（1）System.gc()方法的调用。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI（Java远程方法调用）调用System.gc。</p>
<p>（2）旧生代空间不足。旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>（3）Permanet Generation空间满了。Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出错误信息：java.lang.OutOfMemoryError: PermGen space 。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
<p>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。</p>
<p>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.java远程调用System.gc()方法</span><br><span class="line">2.老年代空间不足</span><br><span class="line">3.永久代空间满了（java8被元空间替代，使用本地内存，所以这个现在不太可能发生）</span><br><span class="line">4.假如young gc后，进入老年代的平均大小大于老年代可用内存会触发full gc</span><br><span class="line">5.由Eden区，from区向to区复制时（或者颠倒顺序），对象大于to区内存，则移动到老年代，但是老年代内存小于该对象大小</span><br></pre></td></tr></table></figure>


</blockquote>

        </div>

        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%9D%A2%E8%AF%95/"># 面试</a>
                    
                        <a href="/tags/Jvm/"># Jvm</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">后退</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/06/12/Mysql%E9%9D%A2%E8%AF%95(1)/">MySQL面试(1)</a>
            
            
            <a class="next" rel="next" href="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95(1)/">计算机网络面试</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 滚~韬 | Powered by <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
<!-- 搜索功能 -->
<!-- Chic/layout.ejs -->
<div id="u-search">
    <div class="modal">
        <div class="modal-header">
            <div class="container">
                <form id="u-search-modal-form" class="u-search-modal-form">
                    <button type="submit" class="form-submit-btn">
                        <img src="/image/2.png" class="search-btn-img" />
                    </button>
                    <input placeholder="搜索内容..." class="form-input" id="modal-form-input">
                </form>
                <a class="modal-close">x</a>
            </div>
            <div class="search-loading">
                <div class="search-loading-bar"></div>
            </div>
        </div>
        <div class="modal-body">
        </div>
    </div>
    <div class="modal-overlay"></div>
</div>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>


</html>